/**
 * Client
 **/

import * as runtime from './runtime/library.js'
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>

/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model AccountRole
 *
 */
export type AccountRole = $Result.DefaultSelection<Prisma.$AccountRolePayload>
/**
 * Model Cart
 *
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model Category
 *
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Ingredient
 *
 */
export type Ingredient = $Result.DefaultSelection<Prisma.$IngredientPayload>
/**
 * Model ProductIngredients
 *
 */
export type ProductIngredients = $Result.DefaultSelection<Prisma.$ProductIngredientsPayload>
/**
 * Model Product
 *
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Favorite
 *
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model AccountSettings
 *
 */
export type AccountSettings = $Result.DefaultSelection<Prisma.$AccountSettingsPayload>
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model DeliveryAddress
 *
 */
export type DeliveryAddress = $Result.DefaultSelection<Prisma.$DeliveryAddressPayload>
/**
 * Model Order
 *
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 *
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model ProductComment
 *
 */
export type ProductComment = $Result.DefaultSelection<Prisma.$ProductCommentPayload>
/**
 * Model Post
 *
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostComment
 *
 */
export type PostComment = $Result.DefaultSelection<Prisma.$PostCommentPayload>
/**
 * Model PostLike
 *
 */
export type PostLike = $Result.DefaultSelection<Prisma.$PostLikePayload>
/**
 * Model Token
 *
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model Notification
 *
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SupportMessage
 *
 */
export type SupportMessage = $Result.DefaultSelection<Prisma.$SupportMessagePayload>
/**
 * Model LoyaltyLevel
 *
 */
export type LoyaltyLevel = $Result.DefaultSelection<Prisma.$LoyaltyLevelPayload>
/**
 * Model AccountLoyalty
 *
 */
export type AccountLoyalty = $Result.DefaultSelection<Prisma.$AccountLoyaltyPayload>
/**
 * Model LoyaltyTransaction
 *
 */
export type LoyaltyTransaction = $Result.DefaultSelection<Prisma.$LoyaltyTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
	export const LoyaltyTransactionType: {
		REVIEW: 'REVIEW'
		REFERRAL: 'REFERRAL'
		BIRTHDAY: 'BIRTHDAY'
		PURCHASE: 'PURCHASE'
	}

	export type LoyaltyTransactionType = (typeof LoyaltyTransactionType)[keyof typeof LoyaltyTransactionType]

	export const OrderStatus: {
		WAITING_FOR_PAYMENT: 'WAITING_FOR_PAYMENT'
		PAYED: 'PAYED'
		PROCESSING: 'PROCESSING'
		READY_FOR_DELIVERY: 'READY_FOR_DELIVERY'
		DELIVERING: 'DELIVERING'
		COMPLETED: 'COMPLETED'
		CANCELED: 'CANCELED'
		RETURNED: 'RETURNED'
	}

	export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]

	export const NotificationType: {
		ORDER: 'ORDER'
		REVIEW: 'REVIEW'
		ACCOUNT: 'ACCOUNT'
	}

	export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

	export const RoleName: {
		REGULAR: 'REGULAR'
		ADMIN: 'ADMIN'
		SUPER_ADMIN: 'SUPER_ADMIN'
		MANAGER: 'MANAGER'
		SUPPORT: 'SUPPORT'
		EDITOR: 'EDITOR'
	}

	export type RoleName = (typeof RoleName)[keyof typeof RoleName]

	export const TokenTypes: {
		RESET_PASSWORD: 'RESET_PASSWORD'
		VERIFY_EMAIL: 'VERIFY_EMAIL'
		TWO_FACTOR_EMAIL: 'TWO_FACTOR_EMAIL'
		TWO_FACTOR_TOTP: 'TWO_FACTOR_TOTP'
		TELEGRAM_AUTH: 'TELEGRAM_AUTH'
	}

	export type TokenTypes = (typeof TokenTypes)[keyof typeof TokenTypes]

	export const PaymentMethod: {
		CARD: 'CARD'
		CASH: 'CASH'
		ONLINE_WALLET: 'ONLINE_WALLET'
		BANK_TRANSFER: 'BANK_TRANSFER'
	}

	export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]

	export const PaymentStatus: {
		PENDING: 'PENDING'
		COMPLETED: 'COMPLETED'
		FAILED: 'FAILED'
		REFUNDED: 'REFUNDED'
	}

	export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

	export const DeliveryType: {
		COURIER: 'COURIER'
		PICKUP: 'PICKUP'
		EXPRESS: 'EXPRESS'
	}

	export type DeliveryType = (typeof DeliveryType)[keyof typeof DeliveryType]
}

export type LoyaltyTransactionType = $Enums.LoyaltyTransactionType

export const LoyaltyTransactionType: typeof $Enums.LoyaltyTransactionType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type TokenTypes = $Enums.TokenTypes

export const TokenTypes: typeof $Enums.TokenTypes

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type DeliveryType = $Enums.DeliveryType

export const DeliveryType: typeof $Enums.DeliveryType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
	ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
	U = 'log' extends keyof ClientOptions
		? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
			? Prisma.GetEvents<ClientOptions['log']>
			: never
		: never,
	ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
	[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

	/**
	 * ##  Prisma Client ʲˢ
	 *
	 * Type-safe database client for TypeScript & Node.js
	 * @example
	 * ```
	 * const prisma = new PrismaClient()
	 * // Fetch zero or more Roles
	 * const roles = await prisma.role.findMany()
	 * ```
	 *
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
	 */

	constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>)
	$on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient

	/**
	 * Connect with the database
	 */
	$connect(): $Utils.JsPromise<void>

	/**
	 * Disconnect from the database
	 */
	$disconnect(): $Utils.JsPromise<void>

	/**
	 * Add a middleware
	 * @deprecated since 4.16.0. For new code, prefer client extensions instead.
	 * @see https://pris.ly/d/extensions
	 */
	$use(cb: Prisma.Middleware): void

	/**
	 * Executes a prepared raw query and returns the number of affected rows.
	 * @example
	 * ```
	 * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>

	/**
	 * Executes a raw query and returns the number of affected rows.
	 * Susceptible to SQL injections, see documentation.
	 * @example
	 * ```
	 * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>

	/**
	 * Performs a prepared raw query and returns the `SELECT` data.
	 * @example
	 * ```
	 * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>

	/**
	 * Performs a raw query and returns the `SELECT` data.
	 * Susceptible to SQL injections, see documentation.
	 * @example
	 * ```
	 * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>

	/**
	 * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
	 * @example
	 * ```
	 * const [george, bob, alice] = await prisma.$transaction([
	 *   prisma.user.create({ data: { name: 'George' } }),
	 *   prisma.user.create({ data: { name: 'Bob' } }),
	 *   prisma.user.create({ data: { name: 'Alice' } }),
	 * ])
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
	 */
	$transaction<P extends Prisma.PrismaPromise<any>[]>(
		arg: [...P],
		options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
	): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

	$transaction<R>(
		fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
		options?: { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel }
	): $Utils.JsPromise<R>

	$extends: $Extensions.ExtendsHook<
		'extends',
		Prisma.TypeMapCb<ClientOptions>,
		ExtArgs,
		$Utils.Call<
			Prisma.TypeMapCb<ClientOptions>,
			{
				extArgs: ExtArgs
			}
		>
	>

	/**
	 * `prisma.role`: Exposes CRUD operations for the **Role** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Roles
	 * const roles = await prisma.role.findMany()
	 * ```
	 */
	get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.accountRole`: Exposes CRUD operations for the **AccountRole** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more AccountRoles
	 * const accountRoles = await prisma.accountRole.findMany()
	 * ```
	 */
	get accountRole(): Prisma.AccountRoleDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Carts
	 * const carts = await prisma.cart.findMany()
	 * ```
	 */
	get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.category`: Exposes CRUD operations for the **Category** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Categories
	 * const categories = await prisma.category.findMany()
	 * ```
	 */
	get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Ingredients
	 * const ingredients = await prisma.ingredient.findMany()
	 * ```
	 */
	get ingredient(): Prisma.IngredientDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.productIngredients`: Exposes CRUD operations for the **ProductIngredients** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more ProductIngredients
	 * const productIngredients = await prisma.productIngredients.findMany()
	 * ```
	 */
	get productIngredients(): Prisma.ProductIngredientsDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.product`: Exposes CRUD operations for the **Product** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Products
	 * const products = await prisma.product.findMany()
	 * ```
	 */
	get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Favorites
	 * const favorites = await prisma.favorite.findMany()
	 * ```
	 */
	get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.accountSettings`: Exposes CRUD operations for the **AccountSettings** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more AccountSettings
	 * const accountSettings = await prisma.accountSettings.findMany()
	 * ```
	 */
	get accountSettings(): Prisma.AccountSettingsDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.account`: Exposes CRUD operations for the **Account** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Accounts
	 * const accounts = await prisma.account.findMany()
	 * ```
	 */
	get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.deliveryAddress`: Exposes CRUD operations for the **DeliveryAddress** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more DeliveryAddresses
	 * const deliveryAddresses = await prisma.deliveryAddress.findMany()
	 * ```
	 */
	get deliveryAddress(): Prisma.DeliveryAddressDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.order`: Exposes CRUD operations for the **Order** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Orders
	 * const orders = await prisma.order.findMany()
	 * ```
	 */
	get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more OrderItems
	 * const orderItems = await prisma.orderItem.findMany()
	 * ```
	 */
	get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.productComment`: Exposes CRUD operations for the **ProductComment** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more ProductComments
	 * const productComments = await prisma.productComment.findMany()
	 * ```
	 */
	get productComment(): Prisma.ProductCommentDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.post`: Exposes CRUD operations for the **Post** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Posts
	 * const posts = await prisma.post.findMany()
	 * ```
	 */
	get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.postComment`: Exposes CRUD operations for the **PostComment** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more PostComments
	 * const postComments = await prisma.postComment.findMany()
	 * ```
	 */
	get postComment(): Prisma.PostCommentDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.postLike`: Exposes CRUD operations for the **PostLike** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more PostLikes
	 * const postLikes = await prisma.postLike.findMany()
	 * ```
	 */
	get postLike(): Prisma.PostLikeDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.token`: Exposes CRUD operations for the **Token** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Tokens
	 * const tokens = await prisma.token.findMany()
	 * ```
	 */
	get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Notifications
	 * const notifications = await prisma.notification.findMany()
	 * ```
	 */
	get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.supportMessage`: Exposes CRUD operations for the **SupportMessage** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more SupportMessages
	 * const supportMessages = await prisma.supportMessage.findMany()
	 * ```
	 */
	get supportMessage(): Prisma.SupportMessageDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.loyaltyLevel`: Exposes CRUD operations for the **LoyaltyLevel** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more LoyaltyLevels
	 * const loyaltyLevels = await prisma.loyaltyLevel.findMany()
	 * ```
	 */
	get loyaltyLevel(): Prisma.LoyaltyLevelDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.accountLoyalty`: Exposes CRUD operations for the **AccountLoyalty** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more AccountLoyalties
	 * const accountLoyalties = await prisma.accountLoyalty.findMany()
	 * ```
	 */
	get accountLoyalty(): Prisma.AccountLoyaltyDelegate<ExtArgs, ClientOptions>

	/**
	 * `prisma.loyaltyTransaction`: Exposes CRUD operations for the **LoyaltyTransaction** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more LoyaltyTransactions
	 * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
	 * ```
	 */
	get loyaltyTransaction(): Prisma.LoyaltyTransactionDelegate<ExtArgs, ClientOptions>
}

export namespace Prisma {
	export import DMMF = runtime.DMMF

	export type PrismaPromise<T> = $Public.PrismaPromise<T>

	/**
	 * Validator
	 */
	export import validator = runtime.Public.validator

	/**
	 * Prisma Errors
	 */
	export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
	export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
	export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
	export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
	export import PrismaClientValidationError = runtime.PrismaClientValidationError

	/**
	 * Re-export of sql-template-tag
	 */
	export import sql = runtime.sqltag
	export import empty = runtime.empty
	export import join = runtime.join
	export import raw = runtime.raw
	export import Sql = runtime.Sql

	/**
	 * Decimal.js
	 */
	export import Decimal = runtime.Decimal

	export type DecimalJsLike = runtime.DecimalJsLike

	/**
	 * Metrics
	 */
	export type Metrics = runtime.Metrics
	export type Metric<T> = runtime.Metric<T>
	export type MetricHistogram = runtime.MetricHistogram
	export type MetricHistogramBucket = runtime.MetricHistogramBucket

	/**
	 * Extensions
	 */
	export import Extension = $Extensions.UserArgs
	export import getExtensionContext = runtime.Extensions.getExtensionContext
	export import Args = $Public.Args
	export import Payload = $Public.Payload
	export import Result = $Public.Result
	export import Exact = $Public.Exact

	/**
	 * Prisma Client JS version: 6.7.0
	 * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
	 */
	export type PrismaVersion = {
		client: string
	}

	export const prismaVersion: PrismaVersion

	/**
	 * Utility Types
	 */

	export import JsonObject = runtime.JsonObject
	export import JsonArray = runtime.JsonArray
	export import JsonValue = runtime.JsonValue
	export import InputJsonObject = runtime.InputJsonObject
	export import InputJsonArray = runtime.InputJsonArray
	export import InputJsonValue = runtime.InputJsonValue

	/**
	 * Types of the values used to represent different kinds of `null` values when working with JSON fields.
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	namespace NullTypes {
		/**
		 * Type of `Prisma.DbNull`.
		 *
		 * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
		 *
		 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
		 */
		class DbNull {
			private DbNull: never
			private constructor()
		}

		/**
		 * Type of `Prisma.JsonNull`.
		 *
		 * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
		 *
		 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
		 */
		class JsonNull {
			private JsonNull: never
			private constructor()
		}

		/**
		 * Type of `Prisma.AnyNull`.
		 *
		 * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
		 *
		 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
		 */
		class AnyNull {
			private AnyNull: never
			private constructor()
		}
	}

	/**
	 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	export const DbNull: NullTypes.DbNull

	/**
	 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	export const JsonNull: NullTypes.JsonNull

	/**
	 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	export const AnyNull: NullTypes.AnyNull

	type SelectAndInclude = {
		select: any
		include: any
	}

	type SelectAndOmit = {
		select: any
		omit: any
	}

	/**
	 * Get the type of the value, that the Promise holds.
	 */
	export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T

	/**
	 * Get the return type of a function which returns a Promise.
	 */
	export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

	/**
	 * From T, pick a set of properties whose keys are in the union K
	 */
	type Prisma__Pick<T, K extends keyof T> = {
		[P in K]: T[P]
	}

	export type Enumerable<T> = T | Array<T>

	export type RequiredKeys<T> = {
		[K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
	}[keyof T]

	export type TruthyKeys<T> = keyof {
		[K in keyof T as T[K] extends false | undefined | null ? never : K]: K
	}

	export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

	/**
	 * Subset
	 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
	 */
	export type Subset<T, U> = {
		[key in keyof T]: key extends keyof U ? T[key] : never
	}

	/**
	 * SelectSubset
	 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
	 * Additionally, it validates, if both select and include are present. If the case, it errors.
	 */
	export type SelectSubset<T, U> = {
		[key in keyof T]: key extends keyof U ? T[key] : never
	} & (T extends SelectAndInclude
		? 'Please either choose `select` or `include`.'
		: T extends SelectAndOmit
			? 'Please either choose `select` or `omit`.'
			: {})

	/**
	 * Subset + Intersection
	 * @desc From `T` pick properties that exist in `U` and intersect `K`
	 */
	export type SubsetIntersection<T, U, K> = {
		[key in keyof T]: key extends keyof U ? T[key] : never
	} & K

	type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }

	/**
	 * XOR is needed to have a real mutually exclusive union type
	 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
	 */
	type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T

	/**
	 * Is T a Record?
	 */
	type IsObject<T extends any> =
		T extends Array<any>
			? False
			: T extends Date
				? False
				: T extends Uint8Array
					? False
					: T extends BigInt
						? False
						: T extends object
							? True
							: False

	/**
	 * If it's T[], return T
	 */
	export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

	/**
	 * From ts-toolbelt
	 */

	type __Either<O extends object, K extends Key> = Omit<O, K> &
		{
			// Merge all but K
			[P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
		}[K]

	type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

	type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

	type _Either<O extends object, K extends Key, strict extends Boolean> = {
		1: EitherStrict<O, K>
		0: EitherLoose<O, K>
	}[strict]

	type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown ? _Either<O, K, strict> : never

	export type Union = any

	type PatchUndefined<O extends object, O1 extends object> = {
		[K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
	} & {}

	/** Helper Types for "Merge" **/
	export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never

	export type Overwrite<O extends object, O1 extends object> = {
		[K in keyof O]: K extends keyof O1 ? O1[K] : O[K]
	} & {}

	type _Merge<U extends object> = IntersectOf<
		Overwrite<
			U,
			{
				[K in keyof U]-?: At<U, K>
			}
		>
	>

	type Key = string | number | symbol
	type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never
	type AtStrict<O extends object, K extends Key> = O[K & keyof O]
	type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never
	export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
		1: AtStrict<O, K>
		0: AtLoose<O, K>
	}[strict]

	export type ComputeRaw<A extends any> = A extends Function
		? A
		: {
				[K in keyof A]: A[K]
			} & {}

	export type OptionalFlat<O> = {
		[K in keyof O]?: O[K]
	} & {}

	type _Record<K extends keyof any, T> = {
		[P in K]: T
	}

	// cause typescript not to expand types and preserve names
	type NoExpand<T> = T extends unknown ? T : never

	// this type assumes the passed object is entirely optional
	type AtLeast<O extends object, K extends string> = NoExpand<
		O extends unknown
			? (K extends keyof O ? { [P in K]: O[P] } & O : O) | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
			: never
	>

	type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never

	export type Strict<U extends object> = ComputeRaw<_Strict<U>>
	/** End Helper Types for "Merge" **/

	export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>

	/**
  A [[Boolean]]
  */
	export type Boolean = True | False

	// /**
	// 1
	// */
	export type True = 1

	/**
  0
  */
	export type False = 0

	export type Not<B extends Boolean> = {
		0: 1
		1: 0
	}[B]

	export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
		? 0 // anything `never` is false
		: A1 extends A2
			? 1
			: 0

	export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>

	export type Or<B1 extends Boolean, B2 extends Boolean> = {
		0: {
			0: 0
			1: 1
		}
		1: {
			0: 1
			1: 1
		}
	}[B1][B2]

	export type Keys<U extends Union> = U extends unknown ? keyof U : never

	type Cast<A, B> = A extends B ? A : B

	export const type: unique symbol

	/**
	 * Used by group by
	 */

	export type GetScalarType<T, O> = O extends object
		? {
				[P in keyof T]: P extends keyof O ? O[P] : never
			}
		: never

	type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> = IsObject<T> extends True ? U : T

	type GetHavingFields<T> = {
		[K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
			? // infer is only needed to not hit TS limit
				// based on the brilliant idea of Pierre-Antoine Mills
				// https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
				T[K] extends infer TK
				? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
				: never
			: {} extends FieldPaths<T[K]>
				? never
				: K
	}[keyof T]

	/**
	 * Convert tuple to union
	 */
	type _TupleToUnion<T> = T extends (infer E)[] ? E : never
	type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
	type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

	/**
	 * Like `Pick`, but additionally can also accept an array of keys
	 */
	type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

	/**
	 * Exclude all keys with underscores
	 */
	type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

	export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

	type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

	export const ModelName: {
		Role: 'Role'
		AccountRole: 'AccountRole'
		Cart: 'Cart'
		Category: 'Category'
		Ingredient: 'Ingredient'
		ProductIngredients: 'ProductIngredients'
		Product: 'Product'
		Favorite: 'Favorite'
		AccountSettings: 'AccountSettings'
		Account: 'Account'
		DeliveryAddress: 'DeliveryAddress'
		Order: 'Order'
		OrderItem: 'OrderItem'
		ProductComment: 'ProductComment'
		Post: 'Post'
		PostComment: 'PostComment'
		PostLike: 'PostLike'
		Token: 'Token'
		Notification: 'Notification'
		SupportMessage: 'SupportMessage'
		LoyaltyLevel: 'LoyaltyLevel'
		AccountLoyalty: 'AccountLoyalty'
		LoyaltyTransaction: 'LoyaltyTransaction'
	}

	export type ModelName = (typeof ModelName)[keyof typeof ModelName]

	export type Datasources = {
		db?: Datasource
	}

	interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
		returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
	}

	export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
		globalOmitOptions: {
			omit: GlobalOmitOptions
		}
		meta: {
			modelProps:
				| 'role'
				| 'accountRole'
				| 'cart'
				| 'category'
				| 'ingredient'
				| 'productIngredients'
				| 'product'
				| 'favorite'
				| 'accountSettings'
				| 'account'
				| 'deliveryAddress'
				| 'order'
				| 'orderItem'
				| 'productComment'
				| 'post'
				| 'postComment'
				| 'postLike'
				| 'token'
				| 'notification'
				| 'supportMessage'
				| 'loyaltyLevel'
				| 'accountLoyalty'
				| 'loyaltyTransaction'
			txIsolationLevel: Prisma.TransactionIsolationLevel
		}
		model: {
			Role: {
				payload: Prisma.$RolePayload<ExtArgs>
				fields: Prisma.RoleFieldRefs
				operations: {
					findUnique: {
						args: Prisma.RoleFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>
					}
					findFirst: {
						args: Prisma.RoleFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>
					}
					findMany: {
						args: Prisma.RoleFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
					}
					create: {
						args: Prisma.RoleCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>
					}
					createMany: {
						args: Prisma.RoleCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
					}
					delete: {
						args: Prisma.RoleDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>
					}
					update: {
						args: Prisma.RoleUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>
					}
					deleteMany: {
						args: Prisma.RoleDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.RoleUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
					}
					upsert: {
						args: Prisma.RoleUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$RolePayload>
					}
					aggregate: {
						args: Prisma.RoleAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateRole>
					}
					groupBy: {
						args: Prisma.RoleGroupByArgs<ExtArgs>
						result: $Utils.Optional<RoleGroupByOutputType>[]
					}
					count: {
						args: Prisma.RoleCountArgs<ExtArgs>
						result: $Utils.Optional<RoleCountAggregateOutputType> | number
					}
				}
			}
			AccountRole: {
				payload: Prisma.$AccountRolePayload<ExtArgs>
				fields: Prisma.AccountRoleFieldRefs
				operations: {
					findUnique: {
						args: Prisma.AccountRoleFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.AccountRoleFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>
					}
					findFirst: {
						args: Prisma.AccountRoleFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.AccountRoleFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>
					}
					findMany: {
						args: Prisma.AccountRoleFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>[]
					}
					create: {
						args: Prisma.AccountRoleCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>
					}
					createMany: {
						args: Prisma.AccountRoleCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.AccountRoleCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>[]
					}
					delete: {
						args: Prisma.AccountRoleDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>
					}
					update: {
						args: Prisma.AccountRoleUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>
					}
					deleteMany: {
						args: Prisma.AccountRoleDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.AccountRoleUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.AccountRoleUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>[]
					}
					upsert: {
						args: Prisma.AccountRoleUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountRolePayload>
					}
					aggregate: {
						args: Prisma.AccountRoleAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateAccountRole>
					}
					groupBy: {
						args: Prisma.AccountRoleGroupByArgs<ExtArgs>
						result: $Utils.Optional<AccountRoleGroupByOutputType>[]
					}
					count: {
						args: Prisma.AccountRoleCountArgs<ExtArgs>
						result: $Utils.Optional<AccountRoleCountAggregateOutputType> | number
					}
				}
			}
			Cart: {
				payload: Prisma.$CartPayload<ExtArgs>
				fields: Prisma.CartFieldRefs
				operations: {
					findUnique: {
						args: Prisma.CartFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>
					}
					findFirst: {
						args: Prisma.CartFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>
					}
					findMany: {
						args: Prisma.CartFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
					}
					create: {
						args: Prisma.CartCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>
					}
					createMany: {
						args: Prisma.CartCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
					}
					delete: {
						args: Prisma.CartDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>
					}
					update: {
						args: Prisma.CartUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>
					}
					deleteMany: {
						args: Prisma.CartDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.CartUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
					}
					upsert: {
						args: Prisma.CartUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CartPayload>
					}
					aggregate: {
						args: Prisma.CartAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateCart>
					}
					groupBy: {
						args: Prisma.CartGroupByArgs<ExtArgs>
						result: $Utils.Optional<CartGroupByOutputType>[]
					}
					count: {
						args: Prisma.CartCountArgs<ExtArgs>
						result: $Utils.Optional<CartCountAggregateOutputType> | number
					}
				}
			}
			Category: {
				payload: Prisma.$CategoryPayload<ExtArgs>
				fields: Prisma.CategoryFieldRefs
				operations: {
					findUnique: {
						args: Prisma.CategoryFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
					}
					findFirst: {
						args: Prisma.CategoryFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
					}
					findMany: {
						args: Prisma.CategoryFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
					}
					create: {
						args: Prisma.CategoryCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
					}
					createMany: {
						args: Prisma.CategoryCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
					}
					delete: {
						args: Prisma.CategoryDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
					}
					update: {
						args: Prisma.CategoryUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
					}
					deleteMany: {
						args: Prisma.CategoryDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.CategoryUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
					}
					upsert: {
						args: Prisma.CategoryUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
					}
					aggregate: {
						args: Prisma.CategoryAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateCategory>
					}
					groupBy: {
						args: Prisma.CategoryGroupByArgs<ExtArgs>
						result: $Utils.Optional<CategoryGroupByOutputType>[]
					}
					count: {
						args: Prisma.CategoryCountArgs<ExtArgs>
						result: $Utils.Optional<CategoryCountAggregateOutputType> | number
					}
				}
			}
			Ingredient: {
				payload: Prisma.$IngredientPayload<ExtArgs>
				fields: Prisma.IngredientFieldRefs
				operations: {
					findUnique: {
						args: Prisma.IngredientFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.IngredientFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
					}
					findFirst: {
						args: Prisma.IngredientFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.IngredientFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
					}
					findMany: {
						args: Prisma.IngredientFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
					}
					create: {
						args: Prisma.IngredientCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
					}
					createMany: {
						args: Prisma.IngredientCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.IngredientCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
					}
					delete: {
						args: Prisma.IngredientDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
					}
					update: {
						args: Prisma.IngredientUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
					}
					deleteMany: {
						args: Prisma.IngredientDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.IngredientUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.IngredientUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
					}
					upsert: {
						args: Prisma.IngredientUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
					}
					aggregate: {
						args: Prisma.IngredientAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateIngredient>
					}
					groupBy: {
						args: Prisma.IngredientGroupByArgs<ExtArgs>
						result: $Utils.Optional<IngredientGroupByOutputType>[]
					}
					count: {
						args: Prisma.IngredientCountArgs<ExtArgs>
						result: $Utils.Optional<IngredientCountAggregateOutputType> | number
					}
				}
			}
			ProductIngredients: {
				payload: Prisma.$ProductIngredientsPayload<ExtArgs>
				fields: Prisma.ProductIngredientsFieldRefs
				operations: {
					findUnique: {
						args: Prisma.ProductIngredientsFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.ProductIngredientsFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>
					}
					findFirst: {
						args: Prisma.ProductIngredientsFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.ProductIngredientsFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>
					}
					findMany: {
						args: Prisma.ProductIngredientsFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>[]
					}
					create: {
						args: Prisma.ProductIngredientsCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>
					}
					createMany: {
						args: Prisma.ProductIngredientsCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.ProductIngredientsCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>[]
					}
					delete: {
						args: Prisma.ProductIngredientsDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>
					}
					update: {
						args: Prisma.ProductIngredientsUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>
					}
					deleteMany: {
						args: Prisma.ProductIngredientsDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.ProductIngredientsUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.ProductIngredientsUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>[]
					}
					upsert: {
						args: Prisma.ProductIngredientsUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductIngredientsPayload>
					}
					aggregate: {
						args: Prisma.ProductIngredientsAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateProductIngredients>
					}
					groupBy: {
						args: Prisma.ProductIngredientsGroupByArgs<ExtArgs>
						result: $Utils.Optional<ProductIngredientsGroupByOutputType>[]
					}
					count: {
						args: Prisma.ProductIngredientsCountArgs<ExtArgs>
						result: $Utils.Optional<ProductIngredientsCountAggregateOutputType> | number
					}
				}
			}
			Product: {
				payload: Prisma.$ProductPayload<ExtArgs>
				fields: Prisma.ProductFieldRefs
				operations: {
					findUnique: {
						args: Prisma.ProductFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>
					}
					findFirst: {
						args: Prisma.ProductFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>
					}
					findMany: {
						args: Prisma.ProductFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
					}
					create: {
						args: Prisma.ProductCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>
					}
					createMany: {
						args: Prisma.ProductCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
					}
					delete: {
						args: Prisma.ProductDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>
					}
					update: {
						args: Prisma.ProductUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>
					}
					deleteMany: {
						args: Prisma.ProductDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.ProductUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
					}
					upsert: {
						args: Prisma.ProductUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductPayload>
					}
					aggregate: {
						args: Prisma.ProductAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateProduct>
					}
					groupBy: {
						args: Prisma.ProductGroupByArgs<ExtArgs>
						result: $Utils.Optional<ProductGroupByOutputType>[]
					}
					count: {
						args: Prisma.ProductCountArgs<ExtArgs>
						result: $Utils.Optional<ProductCountAggregateOutputType> | number
					}
				}
			}
			Favorite: {
				payload: Prisma.$FavoritePayload<ExtArgs>
				fields: Prisma.FavoriteFieldRefs
				operations: {
					findUnique: {
						args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
					}
					findFirst: {
						args: Prisma.FavoriteFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
					}
					findMany: {
						args: Prisma.FavoriteFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
					}
					create: {
						args: Prisma.FavoriteCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
					}
					createMany: {
						args: Prisma.FavoriteCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
					}
					delete: {
						args: Prisma.FavoriteDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
					}
					update: {
						args: Prisma.FavoriteUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
					}
					deleteMany: {
						args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
					}
					upsert: {
						args: Prisma.FavoriteUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
					}
					aggregate: {
						args: Prisma.FavoriteAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateFavorite>
					}
					groupBy: {
						args: Prisma.FavoriteGroupByArgs<ExtArgs>
						result: $Utils.Optional<FavoriteGroupByOutputType>[]
					}
					count: {
						args: Prisma.FavoriteCountArgs<ExtArgs>
						result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
					}
				}
			}
			AccountSettings: {
				payload: Prisma.$AccountSettingsPayload<ExtArgs>
				fields: Prisma.AccountSettingsFieldRefs
				operations: {
					findUnique: {
						args: Prisma.AccountSettingsFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.AccountSettingsFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>
					}
					findFirst: {
						args: Prisma.AccountSettingsFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.AccountSettingsFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>
					}
					findMany: {
						args: Prisma.AccountSettingsFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>[]
					}
					create: {
						args: Prisma.AccountSettingsCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>
					}
					createMany: {
						args: Prisma.AccountSettingsCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.AccountSettingsCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>[]
					}
					delete: {
						args: Prisma.AccountSettingsDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>
					}
					update: {
						args: Prisma.AccountSettingsUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>
					}
					deleteMany: {
						args: Prisma.AccountSettingsDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.AccountSettingsUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.AccountSettingsUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>[]
					}
					upsert: {
						args: Prisma.AccountSettingsUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountSettingsPayload>
					}
					aggregate: {
						args: Prisma.AccountSettingsAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateAccountSettings>
					}
					groupBy: {
						args: Prisma.AccountSettingsGroupByArgs<ExtArgs>
						result: $Utils.Optional<AccountSettingsGroupByOutputType>[]
					}
					count: {
						args: Prisma.AccountSettingsCountArgs<ExtArgs>
						result: $Utils.Optional<AccountSettingsCountAggregateOutputType> | number
					}
				}
			}
			Account: {
				payload: Prisma.$AccountPayload<ExtArgs>
				fields: Prisma.AccountFieldRefs
				operations: {
					findUnique: {
						args: Prisma.AccountFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>
					}
					findFirst: {
						args: Prisma.AccountFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>
					}
					findMany: {
						args: Prisma.AccountFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
					}
					create: {
						args: Prisma.AccountCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>
					}
					createMany: {
						args: Prisma.AccountCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
					}
					delete: {
						args: Prisma.AccountDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>
					}
					update: {
						args: Prisma.AccountUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>
					}
					deleteMany: {
						args: Prisma.AccountDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.AccountUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
					}
					upsert: {
						args: Prisma.AccountUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountPayload>
					}
					aggregate: {
						args: Prisma.AccountAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateAccount>
					}
					groupBy: {
						args: Prisma.AccountGroupByArgs<ExtArgs>
						result: $Utils.Optional<AccountGroupByOutputType>[]
					}
					count: {
						args: Prisma.AccountCountArgs<ExtArgs>
						result: $Utils.Optional<AccountCountAggregateOutputType> | number
					}
				}
			}
			DeliveryAddress: {
				payload: Prisma.$DeliveryAddressPayload<ExtArgs>
				fields: Prisma.DeliveryAddressFieldRefs
				operations: {
					findUnique: {
						args: Prisma.DeliveryAddressFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.DeliveryAddressFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
					}
					findFirst: {
						args: Prisma.DeliveryAddressFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.DeliveryAddressFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
					}
					findMany: {
						args: Prisma.DeliveryAddressFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>[]
					}
					create: {
						args: Prisma.DeliveryAddressCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
					}
					createMany: {
						args: Prisma.DeliveryAddressCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.DeliveryAddressCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>[]
					}
					delete: {
						args: Prisma.DeliveryAddressDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
					}
					update: {
						args: Prisma.DeliveryAddressUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
					}
					deleteMany: {
						args: Prisma.DeliveryAddressDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.DeliveryAddressUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.DeliveryAddressUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>[]
					}
					upsert: {
						args: Prisma.DeliveryAddressUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
					}
					aggregate: {
						args: Prisma.DeliveryAddressAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateDeliveryAddress>
					}
					groupBy: {
						args: Prisma.DeliveryAddressGroupByArgs<ExtArgs>
						result: $Utils.Optional<DeliveryAddressGroupByOutputType>[]
					}
					count: {
						args: Prisma.DeliveryAddressCountArgs<ExtArgs>
						result: $Utils.Optional<DeliveryAddressCountAggregateOutputType> | number
					}
				}
			}
			Order: {
				payload: Prisma.$OrderPayload<ExtArgs>
				fields: Prisma.OrderFieldRefs
				operations: {
					findUnique: {
						args: Prisma.OrderFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>
					}
					findFirst: {
						args: Prisma.OrderFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>
					}
					findMany: {
						args: Prisma.OrderFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
					}
					create: {
						args: Prisma.OrderCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>
					}
					createMany: {
						args: Prisma.OrderCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
					}
					delete: {
						args: Prisma.OrderDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>
					}
					update: {
						args: Prisma.OrderUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>
					}
					deleteMany: {
						args: Prisma.OrderDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.OrderUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
					}
					upsert: {
						args: Prisma.OrderUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderPayload>
					}
					aggregate: {
						args: Prisma.OrderAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateOrder>
					}
					groupBy: {
						args: Prisma.OrderGroupByArgs<ExtArgs>
						result: $Utils.Optional<OrderGroupByOutputType>[]
					}
					count: {
						args: Prisma.OrderCountArgs<ExtArgs>
						result: $Utils.Optional<OrderCountAggregateOutputType> | number
					}
				}
			}
			OrderItem: {
				payload: Prisma.$OrderItemPayload<ExtArgs>
				fields: Prisma.OrderItemFieldRefs
				operations: {
					findUnique: {
						args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
					}
					findFirst: {
						args: Prisma.OrderItemFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
					}
					findMany: {
						args: Prisma.OrderItemFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
					}
					create: {
						args: Prisma.OrderItemCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
					}
					createMany: {
						args: Prisma.OrderItemCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
					}
					delete: {
						args: Prisma.OrderItemDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
					}
					update: {
						args: Prisma.OrderItemUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
					}
					deleteMany: {
						args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
					}
					upsert: {
						args: Prisma.OrderItemUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
					}
					aggregate: {
						args: Prisma.OrderItemAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateOrderItem>
					}
					groupBy: {
						args: Prisma.OrderItemGroupByArgs<ExtArgs>
						result: $Utils.Optional<OrderItemGroupByOutputType>[]
					}
					count: {
						args: Prisma.OrderItemCountArgs<ExtArgs>
						result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
					}
				}
			}
			ProductComment: {
				payload: Prisma.$ProductCommentPayload<ExtArgs>
				fields: Prisma.ProductCommentFieldRefs
				operations: {
					findUnique: {
						args: Prisma.ProductCommentFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.ProductCommentFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>
					}
					findFirst: {
						args: Prisma.ProductCommentFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.ProductCommentFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>
					}
					findMany: {
						args: Prisma.ProductCommentFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>[]
					}
					create: {
						args: Prisma.ProductCommentCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>
					}
					createMany: {
						args: Prisma.ProductCommentCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.ProductCommentCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>[]
					}
					delete: {
						args: Prisma.ProductCommentDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>
					}
					update: {
						args: Prisma.ProductCommentUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>
					}
					deleteMany: {
						args: Prisma.ProductCommentDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.ProductCommentUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.ProductCommentUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>[]
					}
					upsert: {
						args: Prisma.ProductCommentUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$ProductCommentPayload>
					}
					aggregate: {
						args: Prisma.ProductCommentAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateProductComment>
					}
					groupBy: {
						args: Prisma.ProductCommentGroupByArgs<ExtArgs>
						result: $Utils.Optional<ProductCommentGroupByOutputType>[]
					}
					count: {
						args: Prisma.ProductCommentCountArgs<ExtArgs>
						result: $Utils.Optional<ProductCommentCountAggregateOutputType> | number
					}
				}
			}
			Post: {
				payload: Prisma.$PostPayload<ExtArgs>
				fields: Prisma.PostFieldRefs
				operations: {
					findUnique: {
						args: Prisma.PostFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>
					}
					findFirst: {
						args: Prisma.PostFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>
					}
					findMany: {
						args: Prisma.PostFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
					}
					create: {
						args: Prisma.PostCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>
					}
					createMany: {
						args: Prisma.PostCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
					}
					delete: {
						args: Prisma.PostDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>
					}
					update: {
						args: Prisma.PostUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>
					}
					deleteMany: {
						args: Prisma.PostDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.PostUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
					}
					upsert: {
						args: Prisma.PostUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostPayload>
					}
					aggregate: {
						args: Prisma.PostAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregatePost>
					}
					groupBy: {
						args: Prisma.PostGroupByArgs<ExtArgs>
						result: $Utils.Optional<PostGroupByOutputType>[]
					}
					count: {
						args: Prisma.PostCountArgs<ExtArgs>
						result: $Utils.Optional<PostCountAggregateOutputType> | number
					}
				}
			}
			PostComment: {
				payload: Prisma.$PostCommentPayload<ExtArgs>
				fields: Prisma.PostCommentFieldRefs
				operations: {
					findUnique: {
						args: Prisma.PostCommentFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.PostCommentFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
					}
					findFirst: {
						args: Prisma.PostCommentFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.PostCommentFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
					}
					findMany: {
						args: Prisma.PostCommentFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>[]
					}
					create: {
						args: Prisma.PostCommentCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
					}
					createMany: {
						args: Prisma.PostCommentCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.PostCommentCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>[]
					}
					delete: {
						args: Prisma.PostCommentDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
					}
					update: {
						args: Prisma.PostCommentUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
					}
					deleteMany: {
						args: Prisma.PostCommentDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.PostCommentUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.PostCommentUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>[]
					}
					upsert: {
						args: Prisma.PostCommentUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
					}
					aggregate: {
						args: Prisma.PostCommentAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregatePostComment>
					}
					groupBy: {
						args: Prisma.PostCommentGroupByArgs<ExtArgs>
						result: $Utils.Optional<PostCommentGroupByOutputType>[]
					}
					count: {
						args: Prisma.PostCommentCountArgs<ExtArgs>
						result: $Utils.Optional<PostCommentCountAggregateOutputType> | number
					}
				}
			}
			PostLike: {
				payload: Prisma.$PostLikePayload<ExtArgs>
				fields: Prisma.PostLikeFieldRefs
				operations: {
					findUnique: {
						args: Prisma.PostLikeFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.PostLikeFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
					}
					findFirst: {
						args: Prisma.PostLikeFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.PostLikeFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
					}
					findMany: {
						args: Prisma.PostLikeFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
					}
					create: {
						args: Prisma.PostLikeCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
					}
					createMany: {
						args: Prisma.PostLikeCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.PostLikeCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
					}
					delete: {
						args: Prisma.PostLikeDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
					}
					update: {
						args: Prisma.PostLikeUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
					}
					deleteMany: {
						args: Prisma.PostLikeDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.PostLikeUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.PostLikeUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
					}
					upsert: {
						args: Prisma.PostLikeUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
					}
					aggregate: {
						args: Prisma.PostLikeAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregatePostLike>
					}
					groupBy: {
						args: Prisma.PostLikeGroupByArgs<ExtArgs>
						result: $Utils.Optional<PostLikeGroupByOutputType>[]
					}
					count: {
						args: Prisma.PostLikeCountArgs<ExtArgs>
						result: $Utils.Optional<PostLikeCountAggregateOutputType> | number
					}
				}
			}
			Token: {
				payload: Prisma.$TokenPayload<ExtArgs>
				fields: Prisma.TokenFieldRefs
				operations: {
					findUnique: {
						args: Prisma.TokenFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>
					}
					findFirst: {
						args: Prisma.TokenFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>
					}
					findMany: {
						args: Prisma.TokenFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
					}
					create: {
						args: Prisma.TokenCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>
					}
					createMany: {
						args: Prisma.TokenCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
					}
					delete: {
						args: Prisma.TokenDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>
					}
					update: {
						args: Prisma.TokenUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>
					}
					deleteMany: {
						args: Prisma.TokenDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.TokenUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
					}
					upsert: {
						args: Prisma.TokenUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$TokenPayload>
					}
					aggregate: {
						args: Prisma.TokenAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateToken>
					}
					groupBy: {
						args: Prisma.TokenGroupByArgs<ExtArgs>
						result: $Utils.Optional<TokenGroupByOutputType>[]
					}
					count: {
						args: Prisma.TokenCountArgs<ExtArgs>
						result: $Utils.Optional<TokenCountAggregateOutputType> | number
					}
				}
			}
			Notification: {
				payload: Prisma.$NotificationPayload<ExtArgs>
				fields: Prisma.NotificationFieldRefs
				operations: {
					findUnique: {
						args: Prisma.NotificationFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
					}
					findFirst: {
						args: Prisma.NotificationFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
					}
					findMany: {
						args: Prisma.NotificationFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
					}
					create: {
						args: Prisma.NotificationCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
					}
					createMany: {
						args: Prisma.NotificationCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
					}
					delete: {
						args: Prisma.NotificationDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
					}
					update: {
						args: Prisma.NotificationUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
					}
					deleteMany: {
						args: Prisma.NotificationDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.NotificationUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
					}
					upsert: {
						args: Prisma.NotificationUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
					}
					aggregate: {
						args: Prisma.NotificationAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateNotification>
					}
					groupBy: {
						args: Prisma.NotificationGroupByArgs<ExtArgs>
						result: $Utils.Optional<NotificationGroupByOutputType>[]
					}
					count: {
						args: Prisma.NotificationCountArgs<ExtArgs>
						result: $Utils.Optional<NotificationCountAggregateOutputType> | number
					}
				}
			}
			SupportMessage: {
				payload: Prisma.$SupportMessagePayload<ExtArgs>
				fields: Prisma.SupportMessageFieldRefs
				operations: {
					findUnique: {
						args: Prisma.SupportMessageFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.SupportMessageFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
					}
					findFirst: {
						args: Prisma.SupportMessageFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.SupportMessageFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
					}
					findMany: {
						args: Prisma.SupportMessageFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
					}
					create: {
						args: Prisma.SupportMessageCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
					}
					createMany: {
						args: Prisma.SupportMessageCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.SupportMessageCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
					}
					delete: {
						args: Prisma.SupportMessageDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
					}
					update: {
						args: Prisma.SupportMessageUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
					}
					deleteMany: {
						args: Prisma.SupportMessageDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.SupportMessageUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.SupportMessageUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
					}
					upsert: {
						args: Prisma.SupportMessageUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
					}
					aggregate: {
						args: Prisma.SupportMessageAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateSupportMessage>
					}
					groupBy: {
						args: Prisma.SupportMessageGroupByArgs<ExtArgs>
						result: $Utils.Optional<SupportMessageGroupByOutputType>[]
					}
					count: {
						args: Prisma.SupportMessageCountArgs<ExtArgs>
						result: $Utils.Optional<SupportMessageCountAggregateOutputType> | number
					}
				}
			}
			LoyaltyLevel: {
				payload: Prisma.$LoyaltyLevelPayload<ExtArgs>
				fields: Prisma.LoyaltyLevelFieldRefs
				operations: {
					findUnique: {
						args: Prisma.LoyaltyLevelFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.LoyaltyLevelFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>
					}
					findFirst: {
						args: Prisma.LoyaltyLevelFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.LoyaltyLevelFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>
					}
					findMany: {
						args: Prisma.LoyaltyLevelFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>[]
					}
					create: {
						args: Prisma.LoyaltyLevelCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>
					}
					createMany: {
						args: Prisma.LoyaltyLevelCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.LoyaltyLevelCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>[]
					}
					delete: {
						args: Prisma.LoyaltyLevelDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>
					}
					update: {
						args: Prisma.LoyaltyLevelUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>
					}
					deleteMany: {
						args: Prisma.LoyaltyLevelDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.LoyaltyLevelUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.LoyaltyLevelUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>[]
					}
					upsert: {
						args: Prisma.LoyaltyLevelUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyLevelPayload>
					}
					aggregate: {
						args: Prisma.LoyaltyLevelAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateLoyaltyLevel>
					}
					groupBy: {
						args: Prisma.LoyaltyLevelGroupByArgs<ExtArgs>
						result: $Utils.Optional<LoyaltyLevelGroupByOutputType>[]
					}
					count: {
						args: Prisma.LoyaltyLevelCountArgs<ExtArgs>
						result: $Utils.Optional<LoyaltyLevelCountAggregateOutputType> | number
					}
				}
			}
			AccountLoyalty: {
				payload: Prisma.$AccountLoyaltyPayload<ExtArgs>
				fields: Prisma.AccountLoyaltyFieldRefs
				operations: {
					findUnique: {
						args: Prisma.AccountLoyaltyFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.AccountLoyaltyFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>
					}
					findFirst: {
						args: Prisma.AccountLoyaltyFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.AccountLoyaltyFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>
					}
					findMany: {
						args: Prisma.AccountLoyaltyFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>[]
					}
					create: {
						args: Prisma.AccountLoyaltyCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>
					}
					createMany: {
						args: Prisma.AccountLoyaltyCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.AccountLoyaltyCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>[]
					}
					delete: {
						args: Prisma.AccountLoyaltyDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>
					}
					update: {
						args: Prisma.AccountLoyaltyUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>
					}
					deleteMany: {
						args: Prisma.AccountLoyaltyDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.AccountLoyaltyUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.AccountLoyaltyUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>[]
					}
					upsert: {
						args: Prisma.AccountLoyaltyUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$AccountLoyaltyPayload>
					}
					aggregate: {
						args: Prisma.AccountLoyaltyAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateAccountLoyalty>
					}
					groupBy: {
						args: Prisma.AccountLoyaltyGroupByArgs<ExtArgs>
						result: $Utils.Optional<AccountLoyaltyGroupByOutputType>[]
					}
					count: {
						args: Prisma.AccountLoyaltyCountArgs<ExtArgs>
						result: $Utils.Optional<AccountLoyaltyCountAggregateOutputType> | number
					}
				}
			}
			LoyaltyTransaction: {
				payload: Prisma.$LoyaltyTransactionPayload<ExtArgs>
				fields: Prisma.LoyaltyTransactionFieldRefs
				operations: {
					findUnique: {
						args: Prisma.LoyaltyTransactionFindUniqueArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload> | null
					}
					findUniqueOrThrow: {
						args: Prisma.LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
					}
					findFirst: {
						args: Prisma.LoyaltyTransactionFindFirstArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload> | null
					}
					findFirstOrThrow: {
						args: Prisma.LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
					}
					findMany: {
						args: Prisma.LoyaltyTransactionFindManyArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
					}
					create: {
						args: Prisma.LoyaltyTransactionCreateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
					}
					createMany: {
						args: Prisma.LoyaltyTransactionCreateManyArgs<ExtArgs>
						result: BatchPayload
					}
					createManyAndReturn: {
						args: Prisma.LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
					}
					delete: {
						args: Prisma.LoyaltyTransactionDeleteArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
					}
					update: {
						args: Prisma.LoyaltyTransactionUpdateArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
					}
					deleteMany: {
						args: Prisma.LoyaltyTransactionDeleteManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateMany: {
						args: Prisma.LoyaltyTransactionUpdateManyArgs<ExtArgs>
						result: BatchPayload
					}
					updateManyAndReturn: {
						args: Prisma.LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
					}
					upsert: {
						args: Prisma.LoyaltyTransactionUpsertArgs<ExtArgs>
						result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
					}
					aggregate: {
						args: Prisma.LoyaltyTransactionAggregateArgs<ExtArgs>
						result: $Utils.Optional<AggregateLoyaltyTransaction>
					}
					groupBy: {
						args: Prisma.LoyaltyTransactionGroupByArgs<ExtArgs>
						result: $Utils.Optional<LoyaltyTransactionGroupByOutputType>[]
					}
					count: {
						args: Prisma.LoyaltyTransactionCountArgs<ExtArgs>
						result: $Utils.Optional<LoyaltyTransactionCountAggregateOutputType> | number
					}
				}
			}
		}
	} & {
		other: {
			payload: any
			operations: {
				$executeRaw: {
					args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
					result: any
				}
				$executeRawUnsafe: {
					args: [query: string, ...values: any[]]
					result: any
				}
				$queryRaw: {
					args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
					result: any
				}
				$queryRawUnsafe: {
					args: [query: string, ...values: any[]]
					result: any
				}
			}
		}
	}
	export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
	export type DefaultPrismaClient = PrismaClient
	export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
	export interface PrismaClientOptions {
		/**
		 * Overwrites the datasource url from your schema.prisma file
		 */
		datasources?: Datasources
		/**
		 * Overwrites the datasource url from your schema.prisma file
		 */
		datasourceUrl?: string
		/**
		 * @default "colorless"
		 */
		errorFormat?: ErrorFormat
		/**
		 * @example
		 * ```
		 * // Defaults to stdout
		 * log: ['query', 'info', 'warn', 'error']
		 *
		 * // Emit as events
		 * log: [
		 *   { emit: 'stdout', level: 'query' },
		 *   { emit: 'stdout', level: 'info' },
		 *   { emit: 'stdout', level: 'warn' }
		 *   { emit: 'stdout', level: 'error' }
		 * ]
		 * ```
		 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
		 */
		log?: (LogLevel | LogDefinition)[]
		/**
		 * The default values for transactionOptions
		 * maxWait ?= 2000
		 * timeout ?= 5000
		 */
		transactionOptions?: {
			maxWait?: number
			timeout?: number
			isolationLevel?: Prisma.TransactionIsolationLevel
		}
		/**
		 * Global configuration for omitting model fields by default.
		 *
		 * @example
		 * ```
		 * const prisma = new PrismaClient({
		 *   omit: {
		 *     user: {
		 *       password: true
		 *     }
		 *   }
		 * })
		 * ```
		 */
		omit?: Prisma.GlobalOmitConfig
	}
	export type GlobalOmitConfig = {
		role?: RoleOmit
		accountRole?: AccountRoleOmit
		cart?: CartOmit
		category?: CategoryOmit
		ingredient?: IngredientOmit
		productIngredients?: ProductIngredientsOmit
		product?: ProductOmit
		favorite?: FavoriteOmit
		accountSettings?: AccountSettingsOmit
		account?: AccountOmit
		deliveryAddress?: DeliveryAddressOmit
		order?: OrderOmit
		orderItem?: OrderItemOmit
		productComment?: ProductCommentOmit
		post?: PostOmit
		postComment?: PostCommentOmit
		postLike?: PostLikeOmit
		token?: TokenOmit
		notification?: NotificationOmit
		supportMessage?: SupportMessageOmit
		loyaltyLevel?: LoyaltyLevelOmit
		accountLoyalty?: AccountLoyaltyOmit
		loyaltyTransaction?: LoyaltyTransactionOmit
	}

	/* Types for Logging */
	export type LogLevel = 'info' | 'query' | 'warn' | 'error'
	export type LogDefinition = {
		level: LogLevel
		emit: 'stdout' | 'event'
	}

	export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
		? T['emit'] extends 'event'
			? T['level']
			: never
		: never
	export type GetEvents<T extends any> =
		T extends Array<LogLevel | LogDefinition> ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> : never

	export type QueryEvent = {
		timestamp: Date
		query: string
		params: string
		duration: number
		target: string
	}

	export type LogEvent = {
		timestamp: Date
		message: string
		target: string
	}
	/* End Types for Logging */

	export type PrismaAction =
		| 'findUnique'
		| 'findUniqueOrThrow'
		| 'findMany'
		| 'findFirst'
		| 'findFirstOrThrow'
		| 'create'
		| 'createMany'
		| 'createManyAndReturn'
		| 'update'
		| 'updateMany'
		| 'updateManyAndReturn'
		| 'upsert'
		| 'delete'
		| 'deleteMany'
		| 'executeRaw'
		| 'queryRaw'
		| 'aggregate'
		| 'count'
		| 'runCommandRaw'
		| 'findRaw'
		| 'groupBy'

	/**
	 * These options are being passed into the middleware as "params"
	 */
	export type MiddlewareParams = {
		model?: ModelName
		action: PrismaAction
		args: any
		dataPath: string[]
		runInTransaction: boolean
	}

	/**
	 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
	 */
	export type Middleware<T = any> = (
		params: MiddlewareParams,
		next: (params: MiddlewareParams) => $Utils.JsPromise<T>
	) => $Utils.JsPromise<T>

	// tested in getLogLevel.test.ts
	export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined

	/**
	 * `PrismaClient` proxy available in interactive transactions.
	 */
	export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

	export type Datasource = {
		url?: string
	}

	/**
	 * Count Types
	 */

	/**
	 * Count Type RoleCountOutputType
	 */

	export type RoleCountOutputType = {
		accountRoles: number
	}

	export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountRoles?: boolean | RoleCountOutputTypeCountAccountRolesArgs
	}

	// Custom InputTypes
	/**
	 * RoleCountOutputType without action
	 */
	export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the RoleCountOutputType
		 */
		select?: RoleCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * RoleCountOutputType without action
	 */
	export type RoleCountOutputTypeCountAccountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: AccountRoleWhereInput
	}

	/**
	 * Count Type CategoryCountOutputType
	 */

	export type CategoryCountOutputType = {
		products: number
	}

	export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		products?: boolean | CategoryCountOutputTypeCountProductsArgs
	}

	// Custom InputTypes
	/**
	 * CategoryCountOutputType without action
	 */
	export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the CategoryCountOutputType
		 */
		select?: CategoryCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * CategoryCountOutputType without action
	 */
	export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: ProductWhereInput
	}

	/**
	 * Count Type IngredientCountOutputType
	 */

	export type IngredientCountOutputType = {
		productIngredients: number
	}

	export type IngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		productIngredients?: boolean | IngredientCountOutputTypeCountProductIngredientsArgs
	}

	// Custom InputTypes
	/**
	 * IngredientCountOutputType without action
	 */
	export type IngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the IngredientCountOutputType
		 */
		select?: IngredientCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * IngredientCountOutputType without action
	 */
	export type IngredientCountOutputTypeCountProductIngredientsArgs<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
	> = {
		where?: ProductIngredientsWhereInput
	}

	/**
	 * Count Type ProductCountOutputType
	 */

	export type ProductCountOutputType = {
		cart: number
		favorite: number
		ingredients: number
		orderItem: number
		comments: number
	}

	export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		cart?: boolean | ProductCountOutputTypeCountCartArgs
		favorite?: boolean | ProductCountOutputTypeCountFavoriteArgs
		ingredients?: boolean | ProductCountOutputTypeCountIngredientsArgs
		orderItem?: boolean | ProductCountOutputTypeCountOrderItemArgs
		comments?: boolean | ProductCountOutputTypeCountCommentsArgs
	}

	// Custom InputTypes
	/**
	 * ProductCountOutputType without action
	 */
	export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductCountOutputType
		 */
		select?: ProductCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * ProductCountOutputType without action
	 */
	export type ProductCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: CartWhereInput
	}

	/**
	 * ProductCountOutputType without action
	 */
	export type ProductCountOutputTypeCountFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: FavoriteWhereInput
	}

	/**
	 * ProductCountOutputType without action
	 */
	export type ProductCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: ProductIngredientsWhereInput
	}

	/**
	 * ProductCountOutputType without action
	 */
	export type ProductCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: OrderItemWhereInput
	}

	/**
	 * ProductCountOutputType without action
	 */
	export type ProductCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: ProductCommentWhereInput
	}

	/**
	 * Count Type AccountCountOutputType
	 */

	export type AccountCountOutputType = {
		roles: number
		cart: number
		favorites: number
		orders: number
		productComments: number
		deliveryAdresses: number
		notifications: number
		posts: number
		postComments: number
		postLikes: number
		tokens: number
		sentMessages: number
		receivedMessages: number
	}

	export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		roles?: boolean | AccountCountOutputTypeCountRolesArgs
		cart?: boolean | AccountCountOutputTypeCountCartArgs
		favorites?: boolean | AccountCountOutputTypeCountFavoritesArgs
		orders?: boolean | AccountCountOutputTypeCountOrdersArgs
		productComments?: boolean | AccountCountOutputTypeCountProductCommentsArgs
		deliveryAdresses?: boolean | AccountCountOutputTypeCountDeliveryAdressesArgs
		notifications?: boolean | AccountCountOutputTypeCountNotificationsArgs
		posts?: boolean | AccountCountOutputTypeCountPostsArgs
		postComments?: boolean | AccountCountOutputTypeCountPostCommentsArgs
		postLikes?: boolean | AccountCountOutputTypeCountPostLikesArgs
		tokens?: boolean | AccountCountOutputTypeCountTokensArgs
		sentMessages?: boolean | AccountCountOutputTypeCountSentMessagesArgs
		receivedMessages?: boolean | AccountCountOutputTypeCountReceivedMessagesArgs
	}

	// Custom InputTypes
	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountCountOutputType
		 */
		select?: AccountCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: AccountRoleWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: CartWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: FavoriteWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: OrderWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountProductCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		{
			where?: ProductCommentWhereInput
		}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountDeliveryAdressesArgs<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
	> = {
		where?: DeliveryAddressWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: NotificationWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountPostCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostCommentWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountPostLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostLikeWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: TokenWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: SupportMessageWhereInput
	}

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeCountReceivedMessagesArgs<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
	> = {
		where?: SupportMessageWhereInput
	}

	/**
	 * Count Type OrderCountOutputType
	 */

	export type OrderCountOutputType = {
		items: number
	}

	export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		items?: boolean | OrderCountOutputTypeCountItemsArgs
	}

	// Custom InputTypes
	/**
	 * OrderCountOutputType without action
	 */
	export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderCountOutputType
		 */
		select?: OrderCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * OrderCountOutputType without action
	 */
	export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: OrderItemWhereInput
	}

	/**
	 * Count Type ProductCommentCountOutputType
	 */

	export type ProductCommentCountOutputType = {
		replies: number
	}

	export type ProductCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		replies?: boolean | ProductCommentCountOutputTypeCountRepliesArgs
	}

	// Custom InputTypes
	/**
	 * ProductCommentCountOutputType without action
	 */
	export type ProductCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductCommentCountOutputType
		 */
		select?: ProductCommentCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * ProductCommentCountOutputType without action
	 */
	export type ProductCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		{
			where?: ProductCommentWhereInput
		}

	/**
	 * Count Type PostCountOutputType
	 */

	export type PostCountOutputType = {
		comments: number
		likes: number
	}

	export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		comments?: boolean | PostCountOutputTypeCountCommentsArgs
		likes?: boolean | PostCountOutputTypeCountLikesArgs
	}

	// Custom InputTypes
	/**
	 * PostCountOutputType without action
	 */
	export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostCountOutputType
		 */
		select?: PostCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * PostCountOutputType without action
	 */
	export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostCommentWhereInput
	}

	/**
	 * PostCountOutputType without action
	 */
	export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostLikeWhereInput
	}

	/**
	 * Count Type LoyaltyLevelCountOutputType
	 */

	export type LoyaltyLevelCountOutputType = {
		accountLoyalties: number
	}

	export type LoyaltyLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountLoyalties?: boolean | LoyaltyLevelCountOutputTypeCountAccountLoyaltiesArgs
	}

	// Custom InputTypes
	/**
	 * LoyaltyLevelCountOutputType without action
	 */
	export type LoyaltyLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevelCountOutputType
		 */
		select?: LoyaltyLevelCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * LoyaltyLevelCountOutputType without action
	 */
	export type LoyaltyLevelCountOutputTypeCountAccountLoyaltiesArgs<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
	> = {
		where?: AccountLoyaltyWhereInput
	}

	/**
	 * Count Type AccountLoyaltyCountOutputType
	 */

	export type AccountLoyaltyCountOutputType = {
		transactions: number
	}

	export type AccountLoyaltyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		transactions?: boolean | AccountLoyaltyCountOutputTypeCountTransactionsArgs
	}

	// Custom InputTypes
	/**
	 * AccountLoyaltyCountOutputType without action
	 */
	export type AccountLoyaltyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyaltyCountOutputType
		 */
		select?: AccountLoyaltyCountOutputTypeSelect<ExtArgs> | null
	}

	/**
	 * AccountLoyaltyCountOutputType without action
	 */
	export type AccountLoyaltyCountOutputTypeCountTransactionsArgs<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
	> = {
		where?: LoyaltyTransactionWhereInput
	}

	/**
	 * Models
	 */

	/**
	 * Model Role
	 */

	export type AggregateRole = {
		_count: RoleCountAggregateOutputType | null
		_min: RoleMinAggregateOutputType | null
		_max: RoleMaxAggregateOutputType | null
	}

	export type RoleMinAggregateOutputType = {
		id: string | null
		name: $Enums.RoleName | null
	}

	export type RoleMaxAggregateOutputType = {
		id: string | null
		name: $Enums.RoleName | null
	}

	export type RoleCountAggregateOutputType = {
		id: number
		name: number
		_all: number
	}

	export type RoleMinAggregateInputType = {
		id?: true
		name?: true
	}

	export type RoleMaxAggregateInputType = {
		id?: true
		name?: true
	}

	export type RoleCountAggregateInputType = {
		id?: true
		name?: true
		_all?: true
	}

	export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Role to aggregate.
		 */
		where?: RoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Roles to fetch.
		 */
		orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: RoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Roles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Roles.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Roles
		 **/
		_count?: true | RoleCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: RoleMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: RoleMaxAggregateInputType
	}

	export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
		[P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateRole[P]>
			: GetScalarType<T[P], AggregateRole[P]>
	}

	export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: RoleWhereInput
		orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
		by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
		having?: RoleScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: RoleCountAggregateInputType | true
		_min?: RoleMinAggregateInputType
		_max?: RoleMaxAggregateInputType
	}

	export type RoleGroupByOutputType = {
		id: string
		name: $Enums.RoleName
		_count: RoleCountAggregateOutputType | null
		_min: RoleMinAggregateOutputType | null
		_max: RoleMaxAggregateOutputType | null
	}

	type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<RoleGroupByOutputType, T['by']> & {
				[P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], RoleGroupByOutputType[P]>
					: GetScalarType<T[P], RoleGroupByOutputType[P]>
			}
		>
	>

	export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			name?: boolean
			accountRoles?: boolean | Role$accountRolesArgs<ExtArgs>
			_count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['role']
	>

	export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				name?: boolean
			},
			ExtArgs['result']['role']
		>

	export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				name?: boolean
			},
			ExtArgs['result']['role']
		>

	export type RoleSelectScalar = {
		id?: boolean
		name?: boolean
	}

	export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'name',
		ExtArgs['result']['role']
	>
	export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountRoles?: boolean | Role$accountRolesArgs<ExtArgs>
		_count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
	export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

	export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Role'
		objects: {
			accountRoles: Prisma.$AccountRolePayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				name: $Enums.RoleName
			},
			ExtArgs['result']['role']
		>
		composites: {}
	}

	type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

	type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		RoleFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: RoleCountAggregateInputType | true
	}

	export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role']; meta: { name: 'Role' } }
		/**
		 * Find zero or one Role that matches the filter.
		 * @param {RoleFindUniqueArgs} args - Arguments to find a Role
		 * @example
		 * // Get one Role
		 * const role = await prisma.role.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends RoleFindUniqueArgs>(
			args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Role that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
		 * @example
		 * // Get one Role
		 * const role = await prisma.role.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
			args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Role that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleFindFirstArgs} args - Arguments to find a Role
		 * @example
		 * // Get one Role
		 * const role = await prisma.role.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends RoleFindFirstArgs>(
			args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Role that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
		 * @example
		 * // Get one Role
		 * const role = await prisma.role.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
			args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Roles that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Roles
		 * const roles = await prisma.role.findMany()
		 *
		 * // Get first 10 Roles
		 * const roles = await prisma.role.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends RoleFindManyArgs>(
			args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Role.
		 * @param {RoleCreateArgs} args - Arguments to create a Role.
		 * @example
		 * // Create one Role
		 * const Role = await prisma.role.create({
		 *   data: {
		 *     // ... data to create a Role
		 *   }
		 * })
		 *
		 */
		create<T extends RoleCreateArgs>(
			args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Roles.
		 * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
		 * @example
		 * // Create many Roles
		 * const role = await prisma.role.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends RoleCreateManyArgs>(
			args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Roles and returns the data saved in the database.
		 * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
		 * @example
		 * // Create many Roles
		 * const role = await prisma.role.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Roles and only return the `id`
		 * const roleWithIdOnly = await prisma.role.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(
			args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Role.
		 * @param {RoleDeleteArgs} args - Arguments to delete one Role.
		 * @example
		 * // Delete one Role
		 * const Role = await prisma.role.delete({
		 *   where: {
		 *     // ... filter to delete one Role
		 *   }
		 * })
		 *
		 */
		delete<T extends RoleDeleteArgs>(
			args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Role.
		 * @param {RoleUpdateArgs} args - Arguments to update one Role.
		 * @example
		 * // Update one Role
		 * const role = await prisma.role.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends RoleUpdateArgs>(
			args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Roles.
		 * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
		 * @example
		 * // Delete a few Roles
		 * const { count } = await prisma.role.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends RoleDeleteManyArgs>(
			args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Roles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Roles
		 * const role = await prisma.role.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends RoleUpdateManyArgs>(
			args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Roles and returns the data updated in the database.
		 * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
		 * @example
		 * // Update many Roles
		 * const role = await prisma.role.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Roles and only return the `id`
		 * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(
			args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Role.
		 * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
		 * @example
		 * // Update or create a Role
		 * const role = await prisma.role.upsert({
		 *   create: {
		 *     // ... data to create a Role
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Role we want to update
		 *   }
		 * })
		 */
		upsert<T extends RoleUpsertArgs>(
			args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Roles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleCountArgs} args - Arguments to filter Roles to count.
		 * @example
		 * // Count the number of Roles
		 * const count = await prisma.role.count({
		 *   where: {
		 *     // ... the filter for the Roles we want to count
		 *   }
		 * })
		 **/
		count<T extends RoleCountArgs>(
			args?: Subset<T, RoleCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], RoleCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Role.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

		/**
		 * Group by Role.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {RoleGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends RoleGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: RoleGroupByArgs['orderBy'] }
				: { orderBy?: RoleGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Role model
		 */
		readonly fields: RoleFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Role.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__RoleClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		accountRoles<T extends Role$accountRolesArgs<ExtArgs> = {}>(
			args?: Subset<T, Role$accountRolesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Role model
	 */
	interface RoleFieldRefs {
		readonly id: FieldRef<'Role', 'String'>
		readonly name: FieldRef<'Role', 'RoleName'>
	}

	// Custom InputTypes
	/**
	 * Role findUnique
	 */
	export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * Filter, which Role to fetch.
		 */
		where: RoleWhereUniqueInput
	}

	/**
	 * Role findUniqueOrThrow
	 */
	export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * Filter, which Role to fetch.
		 */
		where: RoleWhereUniqueInput
	}

	/**
	 * Role findFirst
	 */
	export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * Filter, which Role to fetch.
		 */
		where?: RoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Roles to fetch.
		 */
		orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Roles.
		 */
		cursor?: RoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Roles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Roles.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Roles.
		 */
		distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
	}

	/**
	 * Role findFirstOrThrow
	 */
	export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * Filter, which Role to fetch.
		 */
		where?: RoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Roles to fetch.
		 */
		orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Roles.
		 */
		cursor?: RoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Roles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Roles.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Roles.
		 */
		distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
	}

	/**
	 * Role findMany
	 */
	export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * Filter, which Roles to fetch.
		 */
		where?: RoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Roles to fetch.
		 */
		orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Roles.
		 */
		cursor?: RoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Roles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Roles.
		 */
		skip?: number
		distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
	}

	/**
	 * Role create
	 */
	export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * The data needed to create a Role.
		 */
		data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
	}

	/**
	 * Role createMany
	 */
	export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Roles.
		 */
		data: RoleCreateManyInput | RoleCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Role createManyAndReturn
	 */
	export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * The data used to create many Roles.
		 */
		data: RoleCreateManyInput | RoleCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Role update
	 */
	export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * The data needed to update a Role.
		 */
		data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
		/**
		 * Choose, which Role to update.
		 */
		where: RoleWhereUniqueInput
	}

	/**
	 * Role updateMany
	 */
	export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Roles.
		 */
		data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
		/**
		 * Filter which Roles to update
		 */
		where?: RoleWhereInput
		/**
		 * Limit how many Roles to update.
		 */
		limit?: number
	}

	/**
	 * Role updateManyAndReturn
	 */
	export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * The data used to update Roles.
		 */
		data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
		/**
		 * Filter which Roles to update
		 */
		where?: RoleWhereInput
		/**
		 * Limit how many Roles to update.
		 */
		limit?: number
	}

	/**
	 * Role upsert
	 */
	export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * The filter to search for the Role to update in case it exists.
		 */
		where: RoleWhereUniqueInput
		/**
		 * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
		 */
		create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
		/**
		 * In case the Role was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
	}

	/**
	 * Role delete
	 */
	export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
		/**
		 * Filter which Role to delete.
		 */
		where: RoleWhereUniqueInput
	}

	/**
	 * Role deleteMany
	 */
	export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Roles to delete
		 */
		where?: RoleWhereInput
		/**
		 * Limit how many Roles to delete.
		 */
		limit?: number
	}

	/**
	 * Role.accountRoles
	 */
	export type Role$accountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		where?: AccountRoleWhereInput
		orderBy?: AccountRoleOrderByWithRelationInput | AccountRoleOrderByWithRelationInput[]
		cursor?: AccountRoleWhereUniqueInput
		take?: number
		skip?: number
		distinct?: AccountRoleScalarFieldEnum | AccountRoleScalarFieldEnum[]
	}

	/**
	 * Role without action
	 */
	export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Role
		 */
		select?: RoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Role
		 */
		omit?: RoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: RoleInclude<ExtArgs> | null
	}

	/**
	 * Model AccountRole
	 */

	export type AggregateAccountRole = {
		_count: AccountRoleCountAggregateOutputType | null
		_min: AccountRoleMinAggregateOutputType | null
		_max: AccountRoleMaxAggregateOutputType | null
	}

	export type AccountRoleMinAggregateOutputType = {
		id: string | null
		accountId: string | null
		roleId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type AccountRoleMaxAggregateOutputType = {
		id: string | null
		accountId: string | null
		roleId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type AccountRoleCountAggregateOutputType = {
		id: number
		accountId: number
		roleId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type AccountRoleMinAggregateInputType = {
		id?: true
		accountId?: true
		roleId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type AccountRoleMaxAggregateInputType = {
		id?: true
		accountId?: true
		roleId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type AccountRoleCountAggregateInputType = {
		id?: true
		accountId?: true
		roleId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type AccountRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which AccountRole to aggregate.
		 */
		where?: AccountRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountRoles to fetch.
		 */
		orderBy?: AccountRoleOrderByWithRelationInput | AccountRoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: AccountRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountRoles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountRoles.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned AccountRoles
		 **/
		_count?: true | AccountRoleCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: AccountRoleMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: AccountRoleMaxAggregateInputType
	}

	export type GetAccountRoleAggregateType<T extends AccountRoleAggregateArgs> = {
		[P in keyof T & keyof AggregateAccountRole]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateAccountRole[P]>
			: GetScalarType<T[P], AggregateAccountRole[P]>
	}

	export type AccountRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: AccountRoleWhereInput
		orderBy?: AccountRoleOrderByWithAggregationInput | AccountRoleOrderByWithAggregationInput[]
		by: AccountRoleScalarFieldEnum[] | AccountRoleScalarFieldEnum
		having?: AccountRoleScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: AccountRoleCountAggregateInputType | true
		_min?: AccountRoleMinAggregateInputType
		_max?: AccountRoleMaxAggregateInputType
	}

	export type AccountRoleGroupByOutputType = {
		id: string
		accountId: string
		roleId: string
		createdAt: Date
		updatedAt: Date
		_count: AccountRoleCountAggregateOutputType | null
		_min: AccountRoleMinAggregateOutputType | null
		_max: AccountRoleMaxAggregateOutputType | null
	}

	type GetAccountRoleGroupByPayload<T extends AccountRoleGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<AccountRoleGroupByOutputType, T['by']> & {
				[P in keyof T & keyof AccountRoleGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], AccountRoleGroupByOutputType[P]>
					: GetScalarType<T[P], AccountRoleGroupByOutputType[P]>
			}
		>
	>

	export type AccountRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			accountId?: boolean
			roleId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			account?: boolean | AccountDefaultArgs<ExtArgs>
			role?: boolean | RoleDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['accountRole']
	>

	export type AccountRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				roleId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
				role?: boolean | RoleDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['accountRole']
		>

	export type AccountRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				roleId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
				role?: boolean | RoleDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['accountRole']
		>

	export type AccountRoleSelectScalar = {
		id?: boolean
		accountId?: boolean
		roleId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type AccountRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'accountId' | 'roleId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['accountRole']
	>
	export type AccountRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		role?: boolean | RoleDefaultArgs<ExtArgs>
	}
	export type AccountRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		role?: boolean | RoleDefaultArgs<ExtArgs>
	}
	export type AccountRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		role?: boolean | RoleDefaultArgs<ExtArgs>
	}

	export type $AccountRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'AccountRole'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs>
			role: Prisma.$RolePayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				accountId: string
				roleId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['accountRole']
		>
		composites: {}
	}

	type AccountRoleGetPayload<S extends boolean | null | undefined | AccountRoleDefaultArgs> = $Result.GetResult<
		Prisma.$AccountRolePayload,
		S
	>

	type AccountRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		AccountRoleFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: AccountRoleCountAggregateInputType | true
	}

	export interface AccountRoleDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountRole']; meta: { name: 'AccountRole' } }
		/**
		 * Find zero or one AccountRole that matches the filter.
		 * @param {AccountRoleFindUniqueArgs} args - Arguments to find a AccountRole
		 * @example
		 * // Get one AccountRole
		 * const accountRole = await prisma.accountRole.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends AccountRoleFindUniqueArgs>(
			args: SelectSubset<T, AccountRoleFindUniqueArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one AccountRole that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {AccountRoleFindUniqueOrThrowArgs} args - Arguments to find a AccountRole
		 * @example
		 * // Get one AccountRole
		 * const accountRole = await prisma.accountRole.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends AccountRoleFindUniqueOrThrowArgs>(
			args: SelectSubset<T, AccountRoleFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first AccountRole that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleFindFirstArgs} args - Arguments to find a AccountRole
		 * @example
		 * // Get one AccountRole
		 * const accountRole = await prisma.accountRole.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends AccountRoleFindFirstArgs>(
			args?: SelectSubset<T, AccountRoleFindFirstArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first AccountRole that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleFindFirstOrThrowArgs} args - Arguments to find a AccountRole
		 * @example
		 * // Get one AccountRole
		 * const accountRole = await prisma.accountRole.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends AccountRoleFindFirstOrThrowArgs>(
			args?: SelectSubset<T, AccountRoleFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more AccountRoles that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all AccountRoles
		 * const accountRoles = await prisma.accountRole.findMany()
		 *
		 * // Get first 10 AccountRoles
		 * const accountRoles = await prisma.accountRole.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const accountRoleWithIdOnly = await prisma.accountRole.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends AccountRoleFindManyArgs>(
			args?: SelectSubset<T, AccountRoleFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a AccountRole.
		 * @param {AccountRoleCreateArgs} args - Arguments to create a AccountRole.
		 * @example
		 * // Create one AccountRole
		 * const AccountRole = await prisma.accountRole.create({
		 *   data: {
		 *     // ... data to create a AccountRole
		 *   }
		 * })
		 *
		 */
		create<T extends AccountRoleCreateArgs>(
			args: SelectSubset<T, AccountRoleCreateArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many AccountRoles.
		 * @param {AccountRoleCreateManyArgs} args - Arguments to create many AccountRoles.
		 * @example
		 * // Create many AccountRoles
		 * const accountRole = await prisma.accountRole.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends AccountRoleCreateManyArgs>(
			args?: SelectSubset<T, AccountRoleCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many AccountRoles and returns the data saved in the database.
		 * @param {AccountRoleCreateManyAndReturnArgs} args - Arguments to create many AccountRoles.
		 * @example
		 * // Create many AccountRoles
		 * const accountRole = await prisma.accountRole.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many AccountRoles and only return the `id`
		 * const accountRoleWithIdOnly = await prisma.accountRole.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends AccountRoleCreateManyAndReturnArgs>(
			args?: SelectSubset<T, AccountRoleCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a AccountRole.
		 * @param {AccountRoleDeleteArgs} args - Arguments to delete one AccountRole.
		 * @example
		 * // Delete one AccountRole
		 * const AccountRole = await prisma.accountRole.delete({
		 *   where: {
		 *     // ... filter to delete one AccountRole
		 *   }
		 * })
		 *
		 */
		delete<T extends AccountRoleDeleteArgs>(
			args: SelectSubset<T, AccountRoleDeleteArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one AccountRole.
		 * @param {AccountRoleUpdateArgs} args - Arguments to update one AccountRole.
		 * @example
		 * // Update one AccountRole
		 * const accountRole = await prisma.accountRole.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends AccountRoleUpdateArgs>(
			args: SelectSubset<T, AccountRoleUpdateArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more AccountRoles.
		 * @param {AccountRoleDeleteManyArgs} args - Arguments to filter AccountRoles to delete.
		 * @example
		 * // Delete a few AccountRoles
		 * const { count } = await prisma.accountRole.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends AccountRoleDeleteManyArgs>(
			args?: SelectSubset<T, AccountRoleDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more AccountRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many AccountRoles
		 * const accountRole = await prisma.accountRole.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends AccountRoleUpdateManyArgs>(
			args: SelectSubset<T, AccountRoleUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more AccountRoles and returns the data updated in the database.
		 * @param {AccountRoleUpdateManyAndReturnArgs} args - Arguments to update many AccountRoles.
		 * @example
		 * // Update many AccountRoles
		 * const accountRole = await prisma.accountRole.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more AccountRoles and only return the `id`
		 * const accountRoleWithIdOnly = await prisma.accountRole.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends AccountRoleUpdateManyAndReturnArgs>(
			args: SelectSubset<T, AccountRoleUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one AccountRole.
		 * @param {AccountRoleUpsertArgs} args - Arguments to update or create a AccountRole.
		 * @example
		 * // Update or create a AccountRole
		 * const accountRole = await prisma.accountRole.upsert({
		 *   create: {
		 *     // ... data to create a AccountRole
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the AccountRole we want to update
		 *   }
		 * })
		 */
		upsert<T extends AccountRoleUpsertArgs>(
			args: SelectSubset<T, AccountRoleUpsertArgs<ExtArgs>>
		): Prisma__AccountRoleClient<
			$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of AccountRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleCountArgs} args - Arguments to filter AccountRoles to count.
		 * @example
		 * // Count the number of AccountRoles
		 * const count = await prisma.accountRole.count({
		 *   where: {
		 *     // ... the filter for the AccountRoles we want to count
		 *   }
		 * })
		 **/
		count<T extends AccountRoleCountArgs>(
			args?: Subset<T, AccountRoleCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], AccountRoleCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a AccountRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends AccountRoleAggregateArgs>(
			args: Subset<T, AccountRoleAggregateArgs>
		): Prisma.PrismaPromise<GetAccountRoleAggregateType<T>>

		/**
		 * Group by AccountRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountRoleGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends AccountRoleGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: AccountRoleGroupByArgs['orderBy'] }
				: { orderBy?: AccountRoleGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, AccountRoleGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetAccountRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the AccountRole model
		 */
		readonly fields: AccountRoleFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for AccountRole.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__AccountRoleClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		role<T extends RoleDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, RoleDefaultArgs<ExtArgs>>
		): Prisma__RoleClient<
			$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the AccountRole model
	 */
	interface AccountRoleFieldRefs {
		readonly id: FieldRef<'AccountRole', 'String'>
		readonly accountId: FieldRef<'AccountRole', 'String'>
		readonly roleId: FieldRef<'AccountRole', 'String'>
		readonly createdAt: FieldRef<'AccountRole', 'DateTime'>
		readonly updatedAt: FieldRef<'AccountRole', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * AccountRole findUnique
	 */
	export type AccountRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * Filter, which AccountRole to fetch.
		 */
		where: AccountRoleWhereUniqueInput
	}

	/**
	 * AccountRole findUniqueOrThrow
	 */
	export type AccountRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * Filter, which AccountRole to fetch.
		 */
		where: AccountRoleWhereUniqueInput
	}

	/**
	 * AccountRole findFirst
	 */
	export type AccountRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * Filter, which AccountRole to fetch.
		 */
		where?: AccountRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountRoles to fetch.
		 */
		orderBy?: AccountRoleOrderByWithRelationInput | AccountRoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for AccountRoles.
		 */
		cursor?: AccountRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountRoles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountRoles.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of AccountRoles.
		 */
		distinct?: AccountRoleScalarFieldEnum | AccountRoleScalarFieldEnum[]
	}

	/**
	 * AccountRole findFirstOrThrow
	 */
	export type AccountRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * Filter, which AccountRole to fetch.
		 */
		where?: AccountRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountRoles to fetch.
		 */
		orderBy?: AccountRoleOrderByWithRelationInput | AccountRoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for AccountRoles.
		 */
		cursor?: AccountRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountRoles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountRoles.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of AccountRoles.
		 */
		distinct?: AccountRoleScalarFieldEnum | AccountRoleScalarFieldEnum[]
	}

	/**
	 * AccountRole findMany
	 */
	export type AccountRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * Filter, which AccountRoles to fetch.
		 */
		where?: AccountRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountRoles to fetch.
		 */
		orderBy?: AccountRoleOrderByWithRelationInput | AccountRoleOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing AccountRoles.
		 */
		cursor?: AccountRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountRoles from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountRoles.
		 */
		skip?: number
		distinct?: AccountRoleScalarFieldEnum | AccountRoleScalarFieldEnum[]
	}

	/**
	 * AccountRole create
	 */
	export type AccountRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * The data needed to create a AccountRole.
		 */
		data: XOR<AccountRoleCreateInput, AccountRoleUncheckedCreateInput>
	}

	/**
	 * AccountRole createMany
	 */
	export type AccountRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many AccountRoles.
		 */
		data: AccountRoleCreateManyInput | AccountRoleCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * AccountRole createManyAndReturn
	 */
	export type AccountRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * The data used to create many AccountRoles.
		 */
		data: AccountRoleCreateManyInput | AccountRoleCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * AccountRole update
	 */
	export type AccountRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * The data needed to update a AccountRole.
		 */
		data: XOR<AccountRoleUpdateInput, AccountRoleUncheckedUpdateInput>
		/**
		 * Choose, which AccountRole to update.
		 */
		where: AccountRoleWhereUniqueInput
	}

	/**
	 * AccountRole updateMany
	 */
	export type AccountRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update AccountRoles.
		 */
		data: XOR<AccountRoleUpdateManyMutationInput, AccountRoleUncheckedUpdateManyInput>
		/**
		 * Filter which AccountRoles to update
		 */
		where?: AccountRoleWhereInput
		/**
		 * Limit how many AccountRoles to update.
		 */
		limit?: number
	}

	/**
	 * AccountRole updateManyAndReturn
	 */
	export type AccountRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * The data used to update AccountRoles.
		 */
		data: XOR<AccountRoleUpdateManyMutationInput, AccountRoleUncheckedUpdateManyInput>
		/**
		 * Filter which AccountRoles to update
		 */
		where?: AccountRoleWhereInput
		/**
		 * Limit how many AccountRoles to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * AccountRole upsert
	 */
	export type AccountRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * The filter to search for the AccountRole to update in case it exists.
		 */
		where: AccountRoleWhereUniqueInput
		/**
		 * In case the AccountRole found by the `where` argument doesn't exist, create a new AccountRole with this data.
		 */
		create: XOR<AccountRoleCreateInput, AccountRoleUncheckedCreateInput>
		/**
		 * In case the AccountRole was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<AccountRoleUpdateInput, AccountRoleUncheckedUpdateInput>
	}

	/**
	 * AccountRole delete
	 */
	export type AccountRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		/**
		 * Filter which AccountRole to delete.
		 */
		where: AccountRoleWhereUniqueInput
	}

	/**
	 * AccountRole deleteMany
	 */
	export type AccountRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which AccountRoles to delete
		 */
		where?: AccountRoleWhereInput
		/**
		 * Limit how many AccountRoles to delete.
		 */
		limit?: number
	}

	/**
	 * AccountRole without action
	 */
	export type AccountRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
	}

	/**
	 * Model Cart
	 */

	export type AggregateCart = {
		_count: CartCountAggregateOutputType | null
		_avg: CartAvgAggregateOutputType | null
		_sum: CartSumAggregateOutputType | null
		_min: CartMinAggregateOutputType | null
		_max: CartMaxAggregateOutputType | null
	}

	export type CartAvgAggregateOutputType = {
		quantity: number | null
	}

	export type CartSumAggregateOutputType = {
		quantity: number | null
	}

	export type CartMinAggregateOutputType = {
		id: string | null
		accountId: string | null
		productId: string | null
		quantity: number | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type CartMaxAggregateOutputType = {
		id: string | null
		accountId: string | null
		productId: string | null
		quantity: number | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type CartCountAggregateOutputType = {
		id: number
		accountId: number
		productId: number
		quantity: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type CartAvgAggregateInputType = {
		quantity?: true
	}

	export type CartSumAggregateInputType = {
		quantity?: true
	}

	export type CartMinAggregateInputType = {
		id?: true
		accountId?: true
		productId?: true
		quantity?: true
		createdAt?: true
		updatedAt?: true
	}

	export type CartMaxAggregateInputType = {
		id?: true
		accountId?: true
		productId?: true
		quantity?: true
		createdAt?: true
		updatedAt?: true
	}

	export type CartCountAggregateInputType = {
		id?: true
		accountId?: true
		productId?: true
		quantity?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Cart to aggregate.
		 */
		where?: CartWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Carts to fetch.
		 */
		orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: CartWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Carts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Carts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Carts
		 **/
		_count?: true | CartCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: CartAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: CartSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: CartMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: CartMaxAggregateInputType
	}

	export type GetCartAggregateType<T extends CartAggregateArgs> = {
		[P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateCart[P]>
			: GetScalarType<T[P], AggregateCart[P]>
	}

	export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: CartWhereInput
		orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
		by: CartScalarFieldEnum[] | CartScalarFieldEnum
		having?: CartScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: CartCountAggregateInputType | true
		_avg?: CartAvgAggregateInputType
		_sum?: CartSumAggregateInputType
		_min?: CartMinAggregateInputType
		_max?: CartMaxAggregateInputType
	}

	export type CartGroupByOutputType = {
		id: string
		accountId: string
		productId: string
		quantity: number
		createdAt: Date
		updatedAt: Date
		_count: CartCountAggregateOutputType | null
		_avg: CartAvgAggregateOutputType | null
		_sum: CartSumAggregateOutputType | null
		_min: CartMinAggregateOutputType | null
		_max: CartMaxAggregateOutputType | null
	}

	type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<CartGroupByOutputType, T['by']> & {
				[P in keyof T & keyof CartGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], CartGroupByOutputType[P]>
					: GetScalarType<T[P], CartGroupByOutputType[P]>
			}
		>
	>

	export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			accountId?: boolean
			productId?: boolean
			quantity?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			account?: boolean | AccountDefaultArgs<ExtArgs>
			product?: boolean | ProductDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['cart']
	>

	export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				productId?: boolean
				quantity?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
				product?: boolean | ProductDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['cart']
		>

	export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				productId?: boolean
				quantity?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
				product?: boolean | ProductDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['cart']
		>

	export type CartSelectScalar = {
		id?: boolean
		accountId?: boolean
		productId?: boolean
		quantity?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'accountId' | 'productId' | 'quantity' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['cart']
	>
	export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
	}
	export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
	}
	export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
	}

	export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Cart'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs>
			product: Prisma.$ProductPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				accountId: string
				productId: string
				quantity: number
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['cart']
		>
		composites: {}
	}

	type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

	type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		CartFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: CartCountAggregateInputType | true
	}

	export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart']; meta: { name: 'Cart' } }
		/**
		 * Find zero or one Cart that matches the filter.
		 * @param {CartFindUniqueArgs} args - Arguments to find a Cart
		 * @example
		 * // Get one Cart
		 * const cart = await prisma.cart.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends CartFindUniqueArgs>(
			args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
		 * @example
		 * // Get one Cart
		 * const cart = await prisma.cart.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(
			args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Cart that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartFindFirstArgs} args - Arguments to find a Cart
		 * @example
		 * // Get one Cart
		 * const cart = await prisma.cart.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends CartFindFirstArgs>(
			args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Cart that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
		 * @example
		 * // Get one Cart
		 * const cart = await prisma.cart.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(
			args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Carts that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Carts
		 * const carts = await prisma.cart.findMany()
		 *
		 * // Get first 10 Carts
		 * const carts = await prisma.cart.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends CartFindManyArgs>(
			args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Cart.
		 * @param {CartCreateArgs} args - Arguments to create a Cart.
		 * @example
		 * // Create one Cart
		 * const Cart = await prisma.cart.create({
		 *   data: {
		 *     // ... data to create a Cart
		 *   }
		 * })
		 *
		 */
		create<T extends CartCreateArgs>(
			args: SelectSubset<T, CartCreateArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Carts.
		 * @param {CartCreateManyArgs} args - Arguments to create many Carts.
		 * @example
		 * // Create many Carts
		 * const cart = await prisma.cart.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends CartCreateManyArgs>(
			args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Carts and returns the data saved in the database.
		 * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
		 * @example
		 * // Create many Carts
		 * const cart = await prisma.cart.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Carts and only return the `id`
		 * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends CartCreateManyAndReturnArgs>(
			args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Cart.
		 * @param {CartDeleteArgs} args - Arguments to delete one Cart.
		 * @example
		 * // Delete one Cart
		 * const Cart = await prisma.cart.delete({
		 *   where: {
		 *     // ... filter to delete one Cart
		 *   }
		 * })
		 *
		 */
		delete<T extends CartDeleteArgs>(
			args: SelectSubset<T, CartDeleteArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Cart.
		 * @param {CartUpdateArgs} args - Arguments to update one Cart.
		 * @example
		 * // Update one Cart
		 * const cart = await prisma.cart.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends CartUpdateArgs>(
			args: SelectSubset<T, CartUpdateArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Carts.
		 * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
		 * @example
		 * // Delete a few Carts
		 * const { count } = await prisma.cart.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends CartDeleteManyArgs>(
			args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Carts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Carts
		 * const cart = await prisma.cart.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends CartUpdateManyArgs>(
			args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Carts and returns the data updated in the database.
		 * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
		 * @example
		 * // Update many Carts
		 * const cart = await prisma.cart.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Carts and only return the `id`
		 * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(
			args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Cart.
		 * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
		 * @example
		 * // Update or create a Cart
		 * const cart = await prisma.cart.upsert({
		 *   create: {
		 *     // ... data to create a Cart
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Cart we want to update
		 *   }
		 * })
		 */
		upsert<T extends CartUpsertArgs>(
			args: SelectSubset<T, CartUpsertArgs<ExtArgs>>
		): Prisma__CartClient<
			$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Carts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartCountArgs} args - Arguments to filter Carts to count.
		 * @example
		 * // Count the number of Carts
		 * const count = await prisma.cart.count({
		 *   where: {
		 *     // ... the filter for the Carts we want to count
		 *   }
		 * })
		 **/
		count<T extends CartCountArgs>(
			args?: Subset<T, CartCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], CartCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Cart.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

		/**
		 * Group by Cart.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CartGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends CartGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: CartGroupByArgs['orderBy'] }
				: { orderBy?: CartGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Cart model
		 */
		readonly fields: CartFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Cart.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__CartClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		product<T extends ProductDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductDefaultArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Cart model
	 */
	interface CartFieldRefs {
		readonly id: FieldRef<'Cart', 'String'>
		readonly accountId: FieldRef<'Cart', 'String'>
		readonly productId: FieldRef<'Cart', 'String'>
		readonly quantity: FieldRef<'Cart', 'Int'>
		readonly createdAt: FieldRef<'Cart', 'DateTime'>
		readonly updatedAt: FieldRef<'Cart', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Cart findUnique
	 */
	export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * Filter, which Cart to fetch.
		 */
		where: CartWhereUniqueInput
	}

	/**
	 * Cart findUniqueOrThrow
	 */
	export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * Filter, which Cart to fetch.
		 */
		where: CartWhereUniqueInput
	}

	/**
	 * Cart findFirst
	 */
	export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * Filter, which Cart to fetch.
		 */
		where?: CartWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Carts to fetch.
		 */
		orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Carts.
		 */
		cursor?: CartWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Carts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Carts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Carts.
		 */
		distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
	}

	/**
	 * Cart findFirstOrThrow
	 */
	export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * Filter, which Cart to fetch.
		 */
		where?: CartWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Carts to fetch.
		 */
		orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Carts.
		 */
		cursor?: CartWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Carts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Carts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Carts.
		 */
		distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
	}

	/**
	 * Cart findMany
	 */
	export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * Filter, which Carts to fetch.
		 */
		where?: CartWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Carts to fetch.
		 */
		orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Carts.
		 */
		cursor?: CartWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Carts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Carts.
		 */
		skip?: number
		distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
	}

	/**
	 * Cart create
	 */
	export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * The data needed to create a Cart.
		 */
		data: XOR<CartCreateInput, CartUncheckedCreateInput>
	}

	/**
	 * Cart createMany
	 */
	export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Carts.
		 */
		data: CartCreateManyInput | CartCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Cart createManyAndReturn
	 */
	export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * The data used to create many Carts.
		 */
		data: CartCreateManyInput | CartCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Cart update
	 */
	export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * The data needed to update a Cart.
		 */
		data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
		/**
		 * Choose, which Cart to update.
		 */
		where: CartWhereUniqueInput
	}

	/**
	 * Cart updateMany
	 */
	export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Carts.
		 */
		data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
		/**
		 * Filter which Carts to update
		 */
		where?: CartWhereInput
		/**
		 * Limit how many Carts to update.
		 */
		limit?: number
	}

	/**
	 * Cart updateManyAndReturn
	 */
	export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * The data used to update Carts.
		 */
		data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
		/**
		 * Filter which Carts to update
		 */
		where?: CartWhereInput
		/**
		 * Limit how many Carts to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Cart upsert
	 */
	export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * The filter to search for the Cart to update in case it exists.
		 */
		where: CartWhereUniqueInput
		/**
		 * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
		 */
		create: XOR<CartCreateInput, CartUncheckedCreateInput>
		/**
		 * In case the Cart was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
	}

	/**
	 * Cart delete
	 */
	export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		/**
		 * Filter which Cart to delete.
		 */
		where: CartWhereUniqueInput
	}

	/**
	 * Cart deleteMany
	 */
	export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Carts to delete
		 */
		where?: CartWhereInput
		/**
		 * Limit how many Carts to delete.
		 */
		limit?: number
	}

	/**
	 * Cart without action
	 */
	export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
	}

	/**
	 * Model Category
	 */

	export type AggregateCategory = {
		_count: CategoryCountAggregateOutputType | null
		_min: CategoryMinAggregateOutputType | null
		_max: CategoryMaxAggregateOutputType | null
	}

	export type CategoryMinAggregateOutputType = {
		id: string | null
		title: string | null
		imageUrl: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type CategoryMaxAggregateOutputType = {
		id: string | null
		title: string | null
		imageUrl: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type CategoryCountAggregateOutputType = {
		id: number
		title: number
		imageUrl: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type CategoryMinAggregateInputType = {
		id?: true
		title?: true
		imageUrl?: true
		createdAt?: true
		updatedAt?: true
	}

	export type CategoryMaxAggregateInputType = {
		id?: true
		title?: true
		imageUrl?: true
		createdAt?: true
		updatedAt?: true
	}

	export type CategoryCountAggregateInputType = {
		id?: true
		title?: true
		imageUrl?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Category to aggregate.
		 */
		where?: CategoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Categories to fetch.
		 */
		orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: CategoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Categories from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Categories.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Categories
		 **/
		_count?: true | CategoryCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: CategoryMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: CategoryMaxAggregateInputType
	}

	export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
		[P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateCategory[P]>
			: GetScalarType<T[P], AggregateCategory[P]>
	}

	export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: CategoryWhereInput
		orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
		by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
		having?: CategoryScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: CategoryCountAggregateInputType | true
		_min?: CategoryMinAggregateInputType
		_max?: CategoryMaxAggregateInputType
	}

	export type CategoryGroupByOutputType = {
		id: string
		title: string
		imageUrl: string | null
		createdAt: Date
		updatedAt: Date
		_count: CategoryCountAggregateOutputType | null
		_min: CategoryMinAggregateOutputType | null
		_max: CategoryMaxAggregateOutputType | null
	}

	type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<CategoryGroupByOutputType, T['by']> & {
				[P in keyof T & keyof CategoryGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], CategoryGroupByOutputType[P]>
					: GetScalarType<T[P], CategoryGroupByOutputType[P]>
			}
		>
	>

	export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			title?: boolean
			imageUrl?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			products?: boolean | Category$productsArgs<ExtArgs>
			_count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['category']
	>

	export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				imageUrl?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['category']
		>

	export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				imageUrl?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['category']
		>

	export type CategorySelectScalar = {
		id?: boolean
		title?: boolean
		imageUrl?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'title' | 'imageUrl' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['category']
	>
	export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		products?: boolean | Category$productsArgs<ExtArgs>
		_count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
	export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

	export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Category'
		objects: {
			products: Prisma.$ProductPayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				title: string
				imageUrl: string | null
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['category']
		>
		composites: {}
	}

	type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<
		Prisma.$CategoryPayload,
		S
	>

	type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		CategoryFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: CategoryCountAggregateInputType | true
	}

	export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category']; meta: { name: 'Category' } }
		/**
		 * Find zero or one Category that matches the filter.
		 * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
		 * @example
		 * // Get one Category
		 * const category = await prisma.category.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends CategoryFindUniqueArgs>(
			args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Category that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
		 * @example
		 * // Get one Category
		 * const category = await prisma.category.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
			args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Category that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryFindFirstArgs} args - Arguments to find a Category
		 * @example
		 * // Get one Category
		 * const category = await prisma.category.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends CategoryFindFirstArgs>(
			args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Category that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
		 * @example
		 * // Get one Category
		 * const category = await prisma.category.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
			args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Categories that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Categories
		 * const categories = await prisma.category.findMany()
		 *
		 * // Get first 10 Categories
		 * const categories = await prisma.category.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends CategoryFindManyArgs>(
			args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Category.
		 * @param {CategoryCreateArgs} args - Arguments to create a Category.
		 * @example
		 * // Create one Category
		 * const Category = await prisma.category.create({
		 *   data: {
		 *     // ... data to create a Category
		 *   }
		 * })
		 *
		 */
		create<T extends CategoryCreateArgs>(
			args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Categories.
		 * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
		 * @example
		 * // Create many Categories
		 * const category = await prisma.category.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends CategoryCreateManyArgs>(
			args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Categories and returns the data saved in the database.
		 * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
		 * @example
		 * // Create many Categories
		 * const category = await prisma.category.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Categories and only return the `id`
		 * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(
			args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Category.
		 * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
		 * @example
		 * // Delete one Category
		 * const Category = await prisma.category.delete({
		 *   where: {
		 *     // ... filter to delete one Category
		 *   }
		 * })
		 *
		 */
		delete<T extends CategoryDeleteArgs>(
			args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Category.
		 * @param {CategoryUpdateArgs} args - Arguments to update one Category.
		 * @example
		 * // Update one Category
		 * const category = await prisma.category.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends CategoryUpdateArgs>(
			args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Categories.
		 * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
		 * @example
		 * // Delete a few Categories
		 * const { count } = await prisma.category.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends CategoryDeleteManyArgs>(
			args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Categories.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Categories
		 * const category = await prisma.category.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends CategoryUpdateManyArgs>(
			args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Categories and returns the data updated in the database.
		 * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
		 * @example
		 * // Update many Categories
		 * const category = await prisma.category.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Categories and only return the `id`
		 * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(
			args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Category.
		 * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
		 * @example
		 * // Update or create a Category
		 * const category = await prisma.category.upsert({
		 *   create: {
		 *     // ... data to create a Category
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Category we want to update
		 *   }
		 * })
		 */
		upsert<T extends CategoryUpsertArgs>(
			args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Categories.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
		 * @example
		 * // Count the number of Categories
		 * const count = await prisma.category.count({
		 *   where: {
		 *     // ... the filter for the Categories we want to count
		 *   }
		 * })
		 **/
		count<T extends CategoryCountArgs>(
			args?: Subset<T, CategoryCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], CategoryCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Category.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends CategoryAggregateArgs>(
			args: Subset<T, CategoryAggregateArgs>
		): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

		/**
		 * Group by Category.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CategoryGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends CategoryGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: CategoryGroupByArgs['orderBy'] }
				: { orderBy?: CategoryGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Category model
		 */
		readonly fields: CategoryFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Category.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__CategoryClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		products<T extends Category$productsArgs<ExtArgs> = {}>(
			args?: Subset<T, Category$productsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Category model
	 */
	interface CategoryFieldRefs {
		readonly id: FieldRef<'Category', 'String'>
		readonly title: FieldRef<'Category', 'String'>
		readonly imageUrl: FieldRef<'Category', 'String'>
		readonly createdAt: FieldRef<'Category', 'DateTime'>
		readonly updatedAt: FieldRef<'Category', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Category findUnique
	 */
	export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * Filter, which Category to fetch.
		 */
		where: CategoryWhereUniqueInput
	}

	/**
	 * Category findUniqueOrThrow
	 */
	export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * Filter, which Category to fetch.
		 */
		where: CategoryWhereUniqueInput
	}

	/**
	 * Category findFirst
	 */
	export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * Filter, which Category to fetch.
		 */
		where?: CategoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Categories to fetch.
		 */
		orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Categories.
		 */
		cursor?: CategoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Categories from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Categories.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Categories.
		 */
		distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
	}

	/**
	 * Category findFirstOrThrow
	 */
	export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * Filter, which Category to fetch.
		 */
		where?: CategoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Categories to fetch.
		 */
		orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Categories.
		 */
		cursor?: CategoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Categories from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Categories.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Categories.
		 */
		distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
	}

	/**
	 * Category findMany
	 */
	export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * Filter, which Categories to fetch.
		 */
		where?: CategoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Categories to fetch.
		 */
		orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Categories.
		 */
		cursor?: CategoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Categories from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Categories.
		 */
		skip?: number
		distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
	}

	/**
	 * Category create
	 */
	export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * The data needed to create a Category.
		 */
		data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
	}

	/**
	 * Category createMany
	 */
	export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Categories.
		 */
		data: CategoryCreateManyInput | CategoryCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Category createManyAndReturn
	 */
	export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * The data used to create many Categories.
		 */
		data: CategoryCreateManyInput | CategoryCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Category update
	 */
	export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * The data needed to update a Category.
		 */
		data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
		/**
		 * Choose, which Category to update.
		 */
		where: CategoryWhereUniqueInput
	}

	/**
	 * Category updateMany
	 */
	export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Categories.
		 */
		data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
		/**
		 * Filter which Categories to update
		 */
		where?: CategoryWhereInput
		/**
		 * Limit how many Categories to update.
		 */
		limit?: number
	}

	/**
	 * Category updateManyAndReturn
	 */
	export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * The data used to update Categories.
		 */
		data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
		/**
		 * Filter which Categories to update
		 */
		where?: CategoryWhereInput
		/**
		 * Limit how many Categories to update.
		 */
		limit?: number
	}

	/**
	 * Category upsert
	 */
	export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * The filter to search for the Category to update in case it exists.
		 */
		where: CategoryWhereUniqueInput
		/**
		 * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
		 */
		create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
		/**
		 * In case the Category was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
	}

	/**
	 * Category delete
	 */
	export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
		/**
		 * Filter which Category to delete.
		 */
		where: CategoryWhereUniqueInput
	}

	/**
	 * Category deleteMany
	 */
	export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Categories to delete
		 */
		where?: CategoryWhereInput
		/**
		 * Limit how many Categories to delete.
		 */
		limit?: number
	}

	/**
	 * Category.products
	 */
	export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		where?: ProductWhereInput
		orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
		cursor?: ProductWhereUniqueInput
		take?: number
		skip?: number
		distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
	}

	/**
	 * Category without action
	 */
	export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Category
		 */
		select?: CategorySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Category
		 */
		omit?: CategoryOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CategoryInclude<ExtArgs> | null
	}

	/**
	 * Model Ingredient
	 */

	export type AggregateIngredient = {
		_count: IngredientCountAggregateOutputType | null
		_min: IngredientMinAggregateOutputType | null
		_max: IngredientMaxAggregateOutputType | null
	}

	export type IngredientMinAggregateOutputType = {
		id: string | null
		title: string | null
		imageUrl: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type IngredientMaxAggregateOutputType = {
		id: string | null
		title: string | null
		imageUrl: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type IngredientCountAggregateOutputType = {
		id: number
		title: number
		imageUrl: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type IngredientMinAggregateInputType = {
		id?: true
		title?: true
		imageUrl?: true
		createdAt?: true
		updatedAt?: true
	}

	export type IngredientMaxAggregateInputType = {
		id?: true
		title?: true
		imageUrl?: true
		createdAt?: true
		updatedAt?: true
	}

	export type IngredientCountAggregateInputType = {
		id?: true
		title?: true
		imageUrl?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type IngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Ingredient to aggregate.
		 */
		where?: IngredientWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Ingredients to fetch.
		 */
		orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: IngredientWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Ingredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Ingredients.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Ingredients
		 **/
		_count?: true | IngredientCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: IngredientMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: IngredientMaxAggregateInputType
	}

	export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
		[P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateIngredient[P]>
			: GetScalarType<T[P], AggregateIngredient[P]>
	}

	export type IngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: IngredientWhereInput
		orderBy?: IngredientOrderByWithAggregationInput | IngredientOrderByWithAggregationInput[]
		by: IngredientScalarFieldEnum[] | IngredientScalarFieldEnum
		having?: IngredientScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: IngredientCountAggregateInputType | true
		_min?: IngredientMinAggregateInputType
		_max?: IngredientMaxAggregateInputType
	}

	export type IngredientGroupByOutputType = {
		id: string
		title: string
		imageUrl: string | null
		createdAt: Date
		updatedAt: Date
		_count: IngredientCountAggregateOutputType | null
		_min: IngredientMinAggregateOutputType | null
		_max: IngredientMaxAggregateOutputType | null
	}

	type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<IngredientGroupByOutputType, T['by']> & {
				[P in keyof T & keyof IngredientGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], IngredientGroupByOutputType[P]>
					: GetScalarType<T[P], IngredientGroupByOutputType[P]>
			}
		>
	>

	export type IngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			title?: boolean
			imageUrl?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			productIngredients?: boolean | Ingredient$productIngredientsArgs<ExtArgs>
			_count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['ingredient']
	>

	export type IngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				imageUrl?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['ingredient']
		>

	export type IngredientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				imageUrl?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['ingredient']
		>

	export type IngredientSelectScalar = {
		id?: boolean
		title?: boolean
		imageUrl?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type IngredientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'title' | 'imageUrl' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['ingredient']
	>
	export type IngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		productIngredients?: boolean | Ingredient$productIngredientsArgs<ExtArgs>
		_count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type IngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
	export type IngredientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

	export type $IngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Ingredient'
		objects: {
			productIngredients: Prisma.$ProductIngredientsPayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				title: string
				imageUrl: string | null
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['ingredient']
		>
		composites: {}
	}

	type IngredientGetPayload<S extends boolean | null | undefined | IngredientDefaultArgs> = $Result.GetResult<
		Prisma.$IngredientPayload,
		S
	>

	type IngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		IngredientFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: IngredientCountAggregateInputType | true
	}

	export interface IngredientDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingredient']; meta: { name: 'Ingredient' } }
		/**
		 * Find zero or one Ingredient that matches the filter.
		 * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
		 * @example
		 * // Get one Ingredient
		 * const ingredient = await prisma.ingredient.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends IngredientFindUniqueArgs>(
			args: SelectSubset<T, IngredientFindUniqueArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Ingredient that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
		 * @example
		 * // Get one Ingredient
		 * const ingredient = await prisma.ingredient.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs>(
			args: SelectSubset<T, IngredientFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Ingredient that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
		 * @example
		 * // Get one Ingredient
		 * const ingredient = await prisma.ingredient.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends IngredientFindFirstArgs>(
			args?: SelectSubset<T, IngredientFindFirstArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Ingredient that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
		 * @example
		 * // Get one Ingredient
		 * const ingredient = await prisma.ingredient.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs>(
			args?: SelectSubset<T, IngredientFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Ingredients that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Ingredients
		 * const ingredients = await prisma.ingredient.findMany()
		 *
		 * // Get first 10 Ingredients
		 * const ingredients = await prisma.ingredient.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends IngredientFindManyArgs>(
			args?: SelectSubset<T, IngredientFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Ingredient.
		 * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
		 * @example
		 * // Create one Ingredient
		 * const Ingredient = await prisma.ingredient.create({
		 *   data: {
		 *     // ... data to create a Ingredient
		 *   }
		 * })
		 *
		 */
		create<T extends IngredientCreateArgs>(
			args: SelectSubset<T, IngredientCreateArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Ingredients.
		 * @param {IngredientCreateManyArgs} args - Arguments to create many Ingredients.
		 * @example
		 * // Create many Ingredients
		 * const ingredient = await prisma.ingredient.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends IngredientCreateManyArgs>(
			args?: SelectSubset<T, IngredientCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Ingredients and returns the data saved in the database.
		 * @param {IngredientCreateManyAndReturnArgs} args - Arguments to create many Ingredients.
		 * @example
		 * // Create many Ingredients
		 * const ingredient = await prisma.ingredient.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Ingredients and only return the `id`
		 * const ingredientWithIdOnly = await prisma.ingredient.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends IngredientCreateManyAndReturnArgs>(
			args?: SelectSubset<T, IngredientCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Ingredient.
		 * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
		 * @example
		 * // Delete one Ingredient
		 * const Ingredient = await prisma.ingredient.delete({
		 *   where: {
		 *     // ... filter to delete one Ingredient
		 *   }
		 * })
		 *
		 */
		delete<T extends IngredientDeleteArgs>(
			args: SelectSubset<T, IngredientDeleteArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Ingredient.
		 * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
		 * @example
		 * // Update one Ingredient
		 * const ingredient = await prisma.ingredient.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends IngredientUpdateArgs>(
			args: SelectSubset<T, IngredientUpdateArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Ingredients.
		 * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
		 * @example
		 * // Delete a few Ingredients
		 * const { count } = await prisma.ingredient.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends IngredientDeleteManyArgs>(
			args?: SelectSubset<T, IngredientDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Ingredients.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Ingredients
		 * const ingredient = await prisma.ingredient.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends IngredientUpdateManyArgs>(
			args: SelectSubset<T, IngredientUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Ingredients and returns the data updated in the database.
		 * @param {IngredientUpdateManyAndReturnArgs} args - Arguments to update many Ingredients.
		 * @example
		 * // Update many Ingredients
		 * const ingredient = await prisma.ingredient.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Ingredients and only return the `id`
		 * const ingredientWithIdOnly = await prisma.ingredient.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends IngredientUpdateManyAndReturnArgs>(
			args: SelectSubset<T, IngredientUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Ingredient.
		 * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
		 * @example
		 * // Update or create a Ingredient
		 * const ingredient = await prisma.ingredient.upsert({
		 *   create: {
		 *     // ... data to create a Ingredient
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Ingredient we want to update
		 *   }
		 * })
		 */
		upsert<T extends IngredientUpsertArgs>(
			args: SelectSubset<T, IngredientUpsertArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Ingredients.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
		 * @example
		 * // Count the number of Ingredients
		 * const count = await prisma.ingredient.count({
		 *   where: {
		 *     // ... the filter for the Ingredients we want to count
		 *   }
		 * })
		 **/
		count<T extends IngredientCountArgs>(
			args?: Subset<T, IngredientCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], IngredientCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Ingredient.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends IngredientAggregateArgs>(
			args: Subset<T, IngredientAggregateArgs>
		): Prisma.PrismaPromise<GetIngredientAggregateType<T>>

		/**
		 * Group by Ingredient.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {IngredientGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends IngredientGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: IngredientGroupByArgs['orderBy'] }
				: { orderBy?: IngredientGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Ingredient model
		 */
		readonly fields: IngredientFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Ingredient.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__IngredientClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		productIngredients<T extends Ingredient$productIngredientsArgs<ExtArgs> = {}>(
			args?: Subset<T, Ingredient$productIngredientsArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Ingredient model
	 */
	interface IngredientFieldRefs {
		readonly id: FieldRef<'Ingredient', 'String'>
		readonly title: FieldRef<'Ingredient', 'String'>
		readonly imageUrl: FieldRef<'Ingredient', 'String'>
		readonly createdAt: FieldRef<'Ingredient', 'DateTime'>
		readonly updatedAt: FieldRef<'Ingredient', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Ingredient findUnique
	 */
	export type IngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * Filter, which Ingredient to fetch.
		 */
		where: IngredientWhereUniqueInput
	}

	/**
	 * Ingredient findUniqueOrThrow
	 */
	export type IngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * Filter, which Ingredient to fetch.
		 */
		where: IngredientWhereUniqueInput
	}

	/**
	 * Ingredient findFirst
	 */
	export type IngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * Filter, which Ingredient to fetch.
		 */
		where?: IngredientWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Ingredients to fetch.
		 */
		orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Ingredients.
		 */
		cursor?: IngredientWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Ingredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Ingredients.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Ingredients.
		 */
		distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
	}

	/**
	 * Ingredient findFirstOrThrow
	 */
	export type IngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * Filter, which Ingredient to fetch.
		 */
		where?: IngredientWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Ingredients to fetch.
		 */
		orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Ingredients.
		 */
		cursor?: IngredientWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Ingredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Ingredients.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Ingredients.
		 */
		distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
	}

	/**
	 * Ingredient findMany
	 */
	export type IngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * Filter, which Ingredients to fetch.
		 */
		where?: IngredientWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Ingredients to fetch.
		 */
		orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Ingredients.
		 */
		cursor?: IngredientWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Ingredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Ingredients.
		 */
		skip?: number
		distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
	}

	/**
	 * Ingredient create
	 */
	export type IngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * The data needed to create a Ingredient.
		 */
		data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
	}

	/**
	 * Ingredient createMany
	 */
	export type IngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Ingredients.
		 */
		data: IngredientCreateManyInput | IngredientCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Ingredient createManyAndReturn
	 */
	export type IngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * The data used to create many Ingredients.
		 */
		data: IngredientCreateManyInput | IngredientCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Ingredient update
	 */
	export type IngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * The data needed to update a Ingredient.
		 */
		data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
		/**
		 * Choose, which Ingredient to update.
		 */
		where: IngredientWhereUniqueInput
	}

	/**
	 * Ingredient updateMany
	 */
	export type IngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Ingredients.
		 */
		data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
		/**
		 * Filter which Ingredients to update
		 */
		where?: IngredientWhereInput
		/**
		 * Limit how many Ingredients to update.
		 */
		limit?: number
	}

	/**
	 * Ingredient updateManyAndReturn
	 */
	export type IngredientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * The data used to update Ingredients.
		 */
		data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
		/**
		 * Filter which Ingredients to update
		 */
		where?: IngredientWhereInput
		/**
		 * Limit how many Ingredients to update.
		 */
		limit?: number
	}

	/**
	 * Ingredient upsert
	 */
	export type IngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * The filter to search for the Ingredient to update in case it exists.
		 */
		where: IngredientWhereUniqueInput
		/**
		 * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
		 */
		create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
		/**
		 * In case the Ingredient was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
	}

	/**
	 * Ingredient delete
	 */
	export type IngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
		/**
		 * Filter which Ingredient to delete.
		 */
		where: IngredientWhereUniqueInput
	}

	/**
	 * Ingredient deleteMany
	 */
	export type IngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Ingredients to delete
		 */
		where?: IngredientWhereInput
		/**
		 * Limit how many Ingredients to delete.
		 */
		limit?: number
	}

	/**
	 * Ingredient.productIngredients
	 */
	export type Ingredient$productIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		where?: ProductIngredientsWhereInput
		orderBy?: ProductIngredientsOrderByWithRelationInput | ProductIngredientsOrderByWithRelationInput[]
		cursor?: ProductIngredientsWhereUniqueInput
		take?: number
		skip?: number
		distinct?: ProductIngredientsScalarFieldEnum | ProductIngredientsScalarFieldEnum[]
	}

	/**
	 * Ingredient without action
	 */
	export type IngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Ingredient
		 */
		select?: IngredientSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Ingredient
		 */
		omit?: IngredientOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: IngredientInclude<ExtArgs> | null
	}

	/**
	 * Model ProductIngredients
	 */

	export type AggregateProductIngredients = {
		_count: ProductIngredientsCountAggregateOutputType | null
		_min: ProductIngredientsMinAggregateOutputType | null
		_max: ProductIngredientsMaxAggregateOutputType | null
	}

	export type ProductIngredientsMinAggregateOutputType = {
		id: string | null
		productId: string | null
		ingredientId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type ProductIngredientsMaxAggregateOutputType = {
		id: string | null
		productId: string | null
		ingredientId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type ProductIngredientsCountAggregateOutputType = {
		id: number
		productId: number
		ingredientId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type ProductIngredientsMinAggregateInputType = {
		id?: true
		productId?: true
		ingredientId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type ProductIngredientsMaxAggregateInputType = {
		id?: true
		productId?: true
		ingredientId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type ProductIngredientsCountAggregateInputType = {
		id?: true
		productId?: true
		ingredientId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type ProductIngredientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which ProductIngredients to aggregate.
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductIngredients to fetch.
		 */
		orderBy?: ProductIngredientsOrderByWithRelationInput | ProductIngredientsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: ProductIngredientsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductIngredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductIngredients.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned ProductIngredients
		 **/
		_count?: true | ProductIngredientsCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ProductIngredientsMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ProductIngredientsMaxAggregateInputType
	}

	export type GetProductIngredientsAggregateType<T extends ProductIngredientsAggregateArgs> = {
		[P in keyof T & keyof AggregateProductIngredients]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateProductIngredients[P]>
			: GetScalarType<T[P], AggregateProductIngredients[P]>
	}

	export type ProductIngredientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: ProductIngredientsWhereInput
		orderBy?: ProductIngredientsOrderByWithAggregationInput | ProductIngredientsOrderByWithAggregationInput[]
		by: ProductIngredientsScalarFieldEnum[] | ProductIngredientsScalarFieldEnum
		having?: ProductIngredientsScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ProductIngredientsCountAggregateInputType | true
		_min?: ProductIngredientsMinAggregateInputType
		_max?: ProductIngredientsMaxAggregateInputType
	}

	export type ProductIngredientsGroupByOutputType = {
		id: string
		productId: string
		ingredientId: string
		createdAt: Date
		updatedAt: Date
		_count: ProductIngredientsCountAggregateOutputType | null
		_min: ProductIngredientsMinAggregateOutputType | null
		_max: ProductIngredientsMaxAggregateOutputType | null
	}

	type GetProductIngredientsGroupByPayload<T extends ProductIngredientsGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<ProductIngredientsGroupByOutputType, T['by']> & {
				[P in keyof T & keyof ProductIngredientsGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], ProductIngredientsGroupByOutputType[P]>
					: GetScalarType<T[P], ProductIngredientsGroupByOutputType[P]>
			}
		>
	>

	export type ProductIngredientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				productId?: boolean
				ingredientId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				product?: boolean | ProductDefaultArgs<ExtArgs>
				ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['productIngredients']
		>

	export type ProductIngredientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				productId?: boolean
				ingredientId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				product?: boolean | ProductDefaultArgs<ExtArgs>
				ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['productIngredients']
		>

	export type ProductIngredientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				productId?: boolean
				ingredientId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				product?: boolean | ProductDefaultArgs<ExtArgs>
				ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['productIngredients']
		>

	export type ProductIngredientsSelectScalar = {
		id?: boolean
		productId?: boolean
		ingredientId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type ProductIngredientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'productId' | 'ingredientId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['productIngredients']
	>
	export type ProductIngredientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		product?: boolean | ProductDefaultArgs<ExtArgs>
		ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
	}
	export type ProductIngredientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		product?: boolean | ProductDefaultArgs<ExtArgs>
		ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
	}
	export type ProductIngredientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		product?: boolean | ProductDefaultArgs<ExtArgs>
		ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
	}

	export type $ProductIngredientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'ProductIngredients'
		objects: {
			product: Prisma.$ProductPayload<ExtArgs>
			ingredient: Prisma.$IngredientPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				productId: string
				ingredientId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['productIngredients']
		>
		composites: {}
	}

	type ProductIngredientsGetPayload<S extends boolean | null | undefined | ProductIngredientsDefaultArgs> = $Result.GetResult<
		Prisma.$ProductIngredientsPayload,
		S
	>

	type ProductIngredientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		ProductIngredientsFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: ProductIngredientsCountAggregateInputType | true
	}

	export interface ProductIngredientsDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductIngredients']; meta: { name: 'ProductIngredients' } }
		/**
		 * Find zero or one ProductIngredients that matches the filter.
		 * @param {ProductIngredientsFindUniqueArgs} args - Arguments to find a ProductIngredients
		 * @example
		 * // Get one ProductIngredients
		 * const productIngredients = await prisma.productIngredients.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends ProductIngredientsFindUniqueArgs>(
			args: SelectSubset<T, ProductIngredientsFindUniqueArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one ProductIngredients that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {ProductIngredientsFindUniqueOrThrowArgs} args - Arguments to find a ProductIngredients
		 * @example
		 * // Get one ProductIngredients
		 * const productIngredients = await prisma.productIngredients.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends ProductIngredientsFindUniqueOrThrowArgs>(
			args: SelectSubset<T, ProductIngredientsFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first ProductIngredients that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsFindFirstArgs} args - Arguments to find a ProductIngredients
		 * @example
		 * // Get one ProductIngredients
		 * const productIngredients = await prisma.productIngredients.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends ProductIngredientsFindFirstArgs>(
			args?: SelectSubset<T, ProductIngredientsFindFirstArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first ProductIngredients that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsFindFirstOrThrowArgs} args - Arguments to find a ProductIngredients
		 * @example
		 * // Get one ProductIngredients
		 * const productIngredients = await prisma.productIngredients.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends ProductIngredientsFindFirstOrThrowArgs>(
			args?: SelectSubset<T, ProductIngredientsFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more ProductIngredients that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all ProductIngredients
		 * const productIngredients = await prisma.productIngredients.findMany()
		 *
		 * // Get first 10 ProductIngredients
		 * const productIngredients = await prisma.productIngredients.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const productIngredientsWithIdOnly = await prisma.productIngredients.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends ProductIngredientsFindManyArgs>(
			args?: SelectSubset<T, ProductIngredientsFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a ProductIngredients.
		 * @param {ProductIngredientsCreateArgs} args - Arguments to create a ProductIngredients.
		 * @example
		 * // Create one ProductIngredients
		 * const ProductIngredients = await prisma.productIngredients.create({
		 *   data: {
		 *     // ... data to create a ProductIngredients
		 *   }
		 * })
		 *
		 */
		create<T extends ProductIngredientsCreateArgs>(
			args: SelectSubset<T, ProductIngredientsCreateArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many ProductIngredients.
		 * @param {ProductIngredientsCreateManyArgs} args - Arguments to create many ProductIngredients.
		 * @example
		 * // Create many ProductIngredients
		 * const productIngredients = await prisma.productIngredients.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends ProductIngredientsCreateManyArgs>(
			args?: SelectSubset<T, ProductIngredientsCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many ProductIngredients and returns the data saved in the database.
		 * @param {ProductIngredientsCreateManyAndReturnArgs} args - Arguments to create many ProductIngredients.
		 * @example
		 * // Create many ProductIngredients
		 * const productIngredients = await prisma.productIngredients.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many ProductIngredients and only return the `id`
		 * const productIngredientsWithIdOnly = await prisma.productIngredients.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends ProductIngredientsCreateManyAndReturnArgs>(
			args?: SelectSubset<T, ProductIngredientsCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a ProductIngredients.
		 * @param {ProductIngredientsDeleteArgs} args - Arguments to delete one ProductIngredients.
		 * @example
		 * // Delete one ProductIngredients
		 * const ProductIngredients = await prisma.productIngredients.delete({
		 *   where: {
		 *     // ... filter to delete one ProductIngredients
		 *   }
		 * })
		 *
		 */
		delete<T extends ProductIngredientsDeleteArgs>(
			args: SelectSubset<T, ProductIngredientsDeleteArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one ProductIngredients.
		 * @param {ProductIngredientsUpdateArgs} args - Arguments to update one ProductIngredients.
		 * @example
		 * // Update one ProductIngredients
		 * const productIngredients = await prisma.productIngredients.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends ProductIngredientsUpdateArgs>(
			args: SelectSubset<T, ProductIngredientsUpdateArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more ProductIngredients.
		 * @param {ProductIngredientsDeleteManyArgs} args - Arguments to filter ProductIngredients to delete.
		 * @example
		 * // Delete a few ProductIngredients
		 * const { count } = await prisma.productIngredients.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends ProductIngredientsDeleteManyArgs>(
			args?: SelectSubset<T, ProductIngredientsDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ProductIngredients.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many ProductIngredients
		 * const productIngredients = await prisma.productIngredients.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends ProductIngredientsUpdateManyArgs>(
			args: SelectSubset<T, ProductIngredientsUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ProductIngredients and returns the data updated in the database.
		 * @param {ProductIngredientsUpdateManyAndReturnArgs} args - Arguments to update many ProductIngredients.
		 * @example
		 * // Update many ProductIngredients
		 * const productIngredients = await prisma.productIngredients.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more ProductIngredients and only return the `id`
		 * const productIngredientsWithIdOnly = await prisma.productIngredients.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends ProductIngredientsUpdateManyAndReturnArgs>(
			args: SelectSubset<T, ProductIngredientsUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one ProductIngredients.
		 * @param {ProductIngredientsUpsertArgs} args - Arguments to update or create a ProductIngredients.
		 * @example
		 * // Update or create a ProductIngredients
		 * const productIngredients = await prisma.productIngredients.upsert({
		 *   create: {
		 *     // ... data to create a ProductIngredients
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the ProductIngredients we want to update
		 *   }
		 * })
		 */
		upsert<T extends ProductIngredientsUpsertArgs>(
			args: SelectSubset<T, ProductIngredientsUpsertArgs<ExtArgs>>
		): Prisma__ProductIngredientsClient<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of ProductIngredients.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsCountArgs} args - Arguments to filter ProductIngredients to count.
		 * @example
		 * // Count the number of ProductIngredients
		 * const count = await prisma.productIngredients.count({
		 *   where: {
		 *     // ... the filter for the ProductIngredients we want to count
		 *   }
		 * })
		 **/
		count<T extends ProductIngredientsCountArgs>(
			args?: Subset<T, ProductIngredientsCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ProductIngredientsCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a ProductIngredients.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ProductIngredientsAggregateArgs>(
			args: Subset<T, ProductIngredientsAggregateArgs>
		): Prisma.PrismaPromise<GetProductIngredientsAggregateType<T>>

		/**
		 * Group by ProductIngredients.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductIngredientsGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ProductIngredientsGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ProductIngredientsGroupByArgs['orderBy'] }
				: { orderBy?: ProductIngredientsGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, ProductIngredientsGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetProductIngredientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the ProductIngredients model
		 */
		readonly fields: ProductIngredientsFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for ProductIngredients.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__ProductIngredientsClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		product<T extends ProductDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductDefaultArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, IngredientDefaultArgs<ExtArgs>>
		): Prisma__IngredientClient<
			$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the ProductIngredients model
	 */
	interface ProductIngredientsFieldRefs {
		readonly id: FieldRef<'ProductIngredients', 'String'>
		readonly productId: FieldRef<'ProductIngredients', 'String'>
		readonly ingredientId: FieldRef<'ProductIngredients', 'String'>
		readonly createdAt: FieldRef<'ProductIngredients', 'DateTime'>
		readonly updatedAt: FieldRef<'ProductIngredients', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * ProductIngredients findUnique
	 */
	export type ProductIngredientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * Filter, which ProductIngredients to fetch.
		 */
		where: ProductIngredientsWhereUniqueInput
	}

	/**
	 * ProductIngredients findUniqueOrThrow
	 */
	export type ProductIngredientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * Filter, which ProductIngredients to fetch.
		 */
		where: ProductIngredientsWhereUniqueInput
	}

	/**
	 * ProductIngredients findFirst
	 */
	export type ProductIngredientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * Filter, which ProductIngredients to fetch.
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductIngredients to fetch.
		 */
		orderBy?: ProductIngredientsOrderByWithRelationInput | ProductIngredientsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ProductIngredients.
		 */
		cursor?: ProductIngredientsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductIngredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductIngredients.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ProductIngredients.
		 */
		distinct?: ProductIngredientsScalarFieldEnum | ProductIngredientsScalarFieldEnum[]
	}

	/**
	 * ProductIngredients findFirstOrThrow
	 */
	export type ProductIngredientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * Filter, which ProductIngredients to fetch.
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductIngredients to fetch.
		 */
		orderBy?: ProductIngredientsOrderByWithRelationInput | ProductIngredientsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ProductIngredients.
		 */
		cursor?: ProductIngredientsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductIngredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductIngredients.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ProductIngredients.
		 */
		distinct?: ProductIngredientsScalarFieldEnum | ProductIngredientsScalarFieldEnum[]
	}

	/**
	 * ProductIngredients findMany
	 */
	export type ProductIngredientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * Filter, which ProductIngredients to fetch.
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductIngredients to fetch.
		 */
		orderBy?: ProductIngredientsOrderByWithRelationInput | ProductIngredientsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing ProductIngredients.
		 */
		cursor?: ProductIngredientsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductIngredients from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductIngredients.
		 */
		skip?: number
		distinct?: ProductIngredientsScalarFieldEnum | ProductIngredientsScalarFieldEnum[]
	}

	/**
	 * ProductIngredients create
	 */
	export type ProductIngredientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * The data needed to create a ProductIngredients.
		 */
		data: XOR<ProductIngredientsCreateInput, ProductIngredientsUncheckedCreateInput>
	}

	/**
	 * ProductIngredients createMany
	 */
	export type ProductIngredientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many ProductIngredients.
		 */
		data: ProductIngredientsCreateManyInput | ProductIngredientsCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * ProductIngredients createManyAndReturn
	 */
	export type ProductIngredientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * The data used to create many ProductIngredients.
		 */
		data: ProductIngredientsCreateManyInput | ProductIngredientsCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * ProductIngredients update
	 */
	export type ProductIngredientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * The data needed to update a ProductIngredients.
		 */
		data: XOR<ProductIngredientsUpdateInput, ProductIngredientsUncheckedUpdateInput>
		/**
		 * Choose, which ProductIngredients to update.
		 */
		where: ProductIngredientsWhereUniqueInput
	}

	/**
	 * ProductIngredients updateMany
	 */
	export type ProductIngredientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update ProductIngredients.
		 */
		data: XOR<ProductIngredientsUpdateManyMutationInput, ProductIngredientsUncheckedUpdateManyInput>
		/**
		 * Filter which ProductIngredients to update
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * Limit how many ProductIngredients to update.
		 */
		limit?: number
	}

	/**
	 * ProductIngredients updateManyAndReturn
	 */
	export type ProductIngredientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * The data used to update ProductIngredients.
		 */
		data: XOR<ProductIngredientsUpdateManyMutationInput, ProductIngredientsUncheckedUpdateManyInput>
		/**
		 * Filter which ProductIngredients to update
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * Limit how many ProductIngredients to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * ProductIngredients upsert
	 */
	export type ProductIngredientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * The filter to search for the ProductIngredients to update in case it exists.
		 */
		where: ProductIngredientsWhereUniqueInput
		/**
		 * In case the ProductIngredients found by the `where` argument doesn't exist, create a new ProductIngredients with this data.
		 */
		create: XOR<ProductIngredientsCreateInput, ProductIngredientsUncheckedCreateInput>
		/**
		 * In case the ProductIngredients was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<ProductIngredientsUpdateInput, ProductIngredientsUncheckedUpdateInput>
	}

	/**
	 * ProductIngredients delete
	 */
	export type ProductIngredientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		/**
		 * Filter which ProductIngredients to delete.
		 */
		where: ProductIngredientsWhereUniqueInput
	}

	/**
	 * ProductIngredients deleteMany
	 */
	export type ProductIngredientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which ProductIngredients to delete
		 */
		where?: ProductIngredientsWhereInput
		/**
		 * Limit how many ProductIngredients to delete.
		 */
		limit?: number
	}

	/**
	 * ProductIngredients without action
	 */
	export type ProductIngredientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
	}

	/**
	 * Model Product
	 */

	export type AggregateProduct = {
		_count: ProductCountAggregateOutputType | null
		_avg: ProductAvgAggregateOutputType | null
		_sum: ProductSumAggregateOutputType | null
		_min: ProductMinAggregateOutputType | null
		_max: ProductMaxAggregateOutputType | null
	}

	export type ProductAvgAggregateOutputType = {
		weight: number | null
		price: number | null
	}

	export type ProductSumAggregateOutputType = {
		weight: number | null
		price: number | null
	}

	export type ProductMinAggregateOutputType = {
		id: string | null
		title: string | null
		description: string | null
		weight: number | null
		imageUrl: string | null
		price: number | null
		onSale: boolean | null
		categoryId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type ProductMaxAggregateOutputType = {
		id: string | null
		title: string | null
		description: string | null
		weight: number | null
		imageUrl: string | null
		price: number | null
		onSale: boolean | null
		categoryId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type ProductCountAggregateOutputType = {
		id: number
		title: number
		description: number
		weight: number
		imageUrl: number
		price: number
		onSale: number
		categoryId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type ProductAvgAggregateInputType = {
		weight?: true
		price?: true
	}

	export type ProductSumAggregateInputType = {
		weight?: true
		price?: true
	}

	export type ProductMinAggregateInputType = {
		id?: true
		title?: true
		description?: true
		weight?: true
		imageUrl?: true
		price?: true
		onSale?: true
		categoryId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type ProductMaxAggregateInputType = {
		id?: true
		title?: true
		description?: true
		weight?: true
		imageUrl?: true
		price?: true
		onSale?: true
		categoryId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type ProductCountAggregateInputType = {
		id?: true
		title?: true
		description?: true
		weight?: true
		imageUrl?: true
		price?: true
		onSale?: true
		categoryId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Product to aggregate.
		 */
		where?: ProductWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Products to fetch.
		 */
		orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: ProductWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Products from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Products.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Products
		 **/
		_count?: true | ProductCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: ProductAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: ProductSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ProductMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ProductMaxAggregateInputType
	}

	export type GetProductAggregateType<T extends ProductAggregateArgs> = {
		[P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateProduct[P]>
			: GetScalarType<T[P], AggregateProduct[P]>
	}

	export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: ProductWhereInput
		orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
		by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
		having?: ProductScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ProductCountAggregateInputType | true
		_avg?: ProductAvgAggregateInputType
		_sum?: ProductSumAggregateInputType
		_min?: ProductMinAggregateInputType
		_max?: ProductMaxAggregateInputType
	}

	export type ProductGroupByOutputType = {
		id: string
		title: string
		description: string | null
		weight: number
		imageUrl: string | null
		price: number
		onSale: boolean
		categoryId: string
		createdAt: Date
		updatedAt: Date
		_count: ProductCountAggregateOutputType | null
		_avg: ProductAvgAggregateOutputType | null
		_sum: ProductSumAggregateOutputType | null
		_min: ProductMinAggregateOutputType | null
		_max: ProductMaxAggregateOutputType | null
	}

	type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<ProductGroupByOutputType, T['by']> & {
				[P in keyof T & keyof ProductGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], ProductGroupByOutputType[P]>
					: GetScalarType<T[P], ProductGroupByOutputType[P]>
			}
		>
	>

	export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			title?: boolean
			description?: boolean
			weight?: boolean
			imageUrl?: boolean
			price?: boolean
			onSale?: boolean
			categoryId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			category?: boolean | CategoryDefaultArgs<ExtArgs>
			cart?: boolean | Product$cartArgs<ExtArgs>
			favorite?: boolean | Product$favoriteArgs<ExtArgs>
			ingredients?: boolean | Product$ingredientsArgs<ExtArgs>
			orderItem?: boolean | Product$orderItemArgs<ExtArgs>
			comments?: boolean | Product$commentsArgs<ExtArgs>
			_count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['product']
	>

	export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				description?: boolean
				weight?: boolean
				imageUrl?: boolean
				price?: boolean
				onSale?: boolean
				categoryId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				category?: boolean | CategoryDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['product']
		>

	export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				description?: boolean
				weight?: boolean
				imageUrl?: boolean
				price?: boolean
				onSale?: boolean
				categoryId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				category?: boolean | CategoryDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['product']
		>

	export type ProductSelectScalar = {
		id?: boolean
		title?: boolean
		description?: boolean
		weight?: boolean
		imageUrl?: boolean
		price?: boolean
		onSale?: boolean
		categoryId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'title' | 'description' | 'weight' | 'imageUrl' | 'price' | 'onSale' | 'categoryId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['product']
	>
	export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		category?: boolean | CategoryDefaultArgs<ExtArgs>
		cart?: boolean | Product$cartArgs<ExtArgs>
		favorite?: boolean | Product$favoriteArgs<ExtArgs>
		ingredients?: boolean | Product$ingredientsArgs<ExtArgs>
		orderItem?: boolean | Product$orderItemArgs<ExtArgs>
		comments?: boolean | Product$commentsArgs<ExtArgs>
		_count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		category?: boolean | CategoryDefaultArgs<ExtArgs>
	}
	export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		category?: boolean | CategoryDefaultArgs<ExtArgs>
	}

	export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Product'
		objects: {
			category: Prisma.$CategoryPayload<ExtArgs>
			cart: Prisma.$CartPayload<ExtArgs>[]
			favorite: Prisma.$FavoritePayload<ExtArgs>[]
			ingredients: Prisma.$ProductIngredientsPayload<ExtArgs>[]
			orderItem: Prisma.$OrderItemPayload<ExtArgs>[]
			comments: Prisma.$ProductCommentPayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				title: string
				description: string | null
				weight: number
				imageUrl: string | null
				price: number
				onSale: boolean
				categoryId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['product']
		>
		composites: {}
	}

	type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

	type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		ProductFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: ProductCountAggregateInputType | true
	}

	export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product']; meta: { name: 'Product' } }
		/**
		 * Find zero or one Product that matches the filter.
		 * @param {ProductFindUniqueArgs} args - Arguments to find a Product
		 * @example
		 * // Get one Product
		 * const product = await prisma.product.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends ProductFindUniqueArgs>(
			args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Product that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
		 * @example
		 * // Get one Product
		 * const product = await prisma.product.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
			args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Product that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductFindFirstArgs} args - Arguments to find a Product
		 * @example
		 * // Get one Product
		 * const product = await prisma.product.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends ProductFindFirstArgs>(
			args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Product that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
		 * @example
		 * // Get one Product
		 * const product = await prisma.product.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
			args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Products that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Products
		 * const products = await prisma.product.findMany()
		 *
		 * // Get first 10 Products
		 * const products = await prisma.product.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends ProductFindManyArgs>(
			args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Product.
		 * @param {ProductCreateArgs} args - Arguments to create a Product.
		 * @example
		 * // Create one Product
		 * const Product = await prisma.product.create({
		 *   data: {
		 *     // ... data to create a Product
		 *   }
		 * })
		 *
		 */
		create<T extends ProductCreateArgs>(
			args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Products.
		 * @param {ProductCreateManyArgs} args - Arguments to create many Products.
		 * @example
		 * // Create many Products
		 * const product = await prisma.product.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends ProductCreateManyArgs>(
			args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Products and returns the data saved in the database.
		 * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
		 * @example
		 * // Create many Products
		 * const product = await prisma.product.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Products and only return the `id`
		 * const productWithIdOnly = await prisma.product.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(
			args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Product.
		 * @param {ProductDeleteArgs} args - Arguments to delete one Product.
		 * @example
		 * // Delete one Product
		 * const Product = await prisma.product.delete({
		 *   where: {
		 *     // ... filter to delete one Product
		 *   }
		 * })
		 *
		 */
		delete<T extends ProductDeleteArgs>(
			args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Product.
		 * @param {ProductUpdateArgs} args - Arguments to update one Product.
		 * @example
		 * // Update one Product
		 * const product = await prisma.product.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends ProductUpdateArgs>(
			args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Products.
		 * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
		 * @example
		 * // Delete a few Products
		 * const { count } = await prisma.product.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends ProductDeleteManyArgs>(
			args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Products.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Products
		 * const product = await prisma.product.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends ProductUpdateManyArgs>(
			args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Products and returns the data updated in the database.
		 * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
		 * @example
		 * // Update many Products
		 * const product = await prisma.product.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Products and only return the `id`
		 * const productWithIdOnly = await prisma.product.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(
			args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Product.
		 * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
		 * @example
		 * // Update or create a Product
		 * const product = await prisma.product.upsert({
		 *   create: {
		 *     // ... data to create a Product
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Product we want to update
		 *   }
		 * })
		 */
		upsert<T extends ProductUpsertArgs>(
			args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Products.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCountArgs} args - Arguments to filter Products to count.
		 * @example
		 * // Count the number of Products
		 * const count = await prisma.product.count({
		 *   where: {
		 *     // ... the filter for the Products we want to count
		 *   }
		 * })
		 **/
		count<T extends ProductCountArgs>(
			args?: Subset<T, ProductCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ProductCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Product.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ProductAggregateArgs>(
			args: Subset<T, ProductAggregateArgs>
		): Prisma.PrismaPromise<GetProductAggregateType<T>>

		/**
		 * Group by Product.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ProductGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ProductGroupByArgs['orderBy'] }
				: { orderBy?: ProductGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Product model
		 */
		readonly fields: ProductFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Product.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__ProductClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		category<T extends CategoryDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, CategoryDefaultArgs<ExtArgs>>
		): Prisma__CategoryClient<
			$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		cart<T extends Product$cartArgs<ExtArgs> = {}>(
			args?: Subset<T, Product$cartArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		favorite<T extends Product$favoriteArgs<ExtArgs> = {}>(
			args?: Subset<T, Product$favoriteArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		ingredients<T extends Product$ingredientsArgs<ExtArgs> = {}>(
			args?: Subset<T, Product$ingredientsArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$ProductIngredientsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
		>
		orderItem<T extends Product$orderItemArgs<ExtArgs> = {}>(
			args?: Subset<T, Product$orderItemArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		comments<T extends Product$commentsArgs<ExtArgs> = {}>(
			args?: Subset<T, Product$commentsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Product model
	 */
	interface ProductFieldRefs {
		readonly id: FieldRef<'Product', 'String'>
		readonly title: FieldRef<'Product', 'String'>
		readonly description: FieldRef<'Product', 'String'>
		readonly weight: FieldRef<'Product', 'Float'>
		readonly imageUrl: FieldRef<'Product', 'String'>
		readonly price: FieldRef<'Product', 'Float'>
		readonly onSale: FieldRef<'Product', 'Boolean'>
		readonly categoryId: FieldRef<'Product', 'String'>
		readonly createdAt: FieldRef<'Product', 'DateTime'>
		readonly updatedAt: FieldRef<'Product', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Product findUnique
	 */
	export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * Filter, which Product to fetch.
		 */
		where: ProductWhereUniqueInput
	}

	/**
	 * Product findUniqueOrThrow
	 */
	export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * Filter, which Product to fetch.
		 */
		where: ProductWhereUniqueInput
	}

	/**
	 * Product findFirst
	 */
	export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * Filter, which Product to fetch.
		 */
		where?: ProductWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Products to fetch.
		 */
		orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Products.
		 */
		cursor?: ProductWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Products from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Products.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Products.
		 */
		distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
	}

	/**
	 * Product findFirstOrThrow
	 */
	export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * Filter, which Product to fetch.
		 */
		where?: ProductWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Products to fetch.
		 */
		orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Products.
		 */
		cursor?: ProductWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Products from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Products.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Products.
		 */
		distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
	}

	/**
	 * Product findMany
	 */
	export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * Filter, which Products to fetch.
		 */
		where?: ProductWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Products to fetch.
		 */
		orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Products.
		 */
		cursor?: ProductWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Products from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Products.
		 */
		skip?: number
		distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
	}

	/**
	 * Product create
	 */
	export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * The data needed to create a Product.
		 */
		data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
	}

	/**
	 * Product createMany
	 */
	export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Products.
		 */
		data: ProductCreateManyInput | ProductCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Product createManyAndReturn
	 */
	export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * The data used to create many Products.
		 */
		data: ProductCreateManyInput | ProductCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Product update
	 */
	export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * The data needed to update a Product.
		 */
		data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
		/**
		 * Choose, which Product to update.
		 */
		where: ProductWhereUniqueInput
	}

	/**
	 * Product updateMany
	 */
	export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Products.
		 */
		data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
		/**
		 * Filter which Products to update
		 */
		where?: ProductWhereInput
		/**
		 * Limit how many Products to update.
		 */
		limit?: number
	}

	/**
	 * Product updateManyAndReturn
	 */
	export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * The data used to update Products.
		 */
		data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
		/**
		 * Filter which Products to update
		 */
		where?: ProductWhereInput
		/**
		 * Limit how many Products to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Product upsert
	 */
	export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * The filter to search for the Product to update in case it exists.
		 */
		where: ProductWhereUniqueInput
		/**
		 * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
		 */
		create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
		/**
		 * In case the Product was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
	}

	/**
	 * Product delete
	 */
	export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
		/**
		 * Filter which Product to delete.
		 */
		where: ProductWhereUniqueInput
	}

	/**
	 * Product deleteMany
	 */
	export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Products to delete
		 */
		where?: ProductWhereInput
		/**
		 * Limit how many Products to delete.
		 */
		limit?: number
	}

	/**
	 * Product.cart
	 */
	export type Product$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		where?: CartWhereInput
		orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
		cursor?: CartWhereUniqueInput
		take?: number
		skip?: number
		distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
	}

	/**
	 * Product.favorite
	 */
	export type Product$favoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		where?: FavoriteWhereInput
		orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
		cursor?: FavoriteWhereUniqueInput
		take?: number
		skip?: number
		distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
	}

	/**
	 * Product.ingredients
	 */
	export type Product$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductIngredients
		 */
		select?: ProductIngredientsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductIngredients
		 */
		omit?: ProductIngredientsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductIngredientsInclude<ExtArgs> | null
		where?: ProductIngredientsWhereInput
		orderBy?: ProductIngredientsOrderByWithRelationInput | ProductIngredientsOrderByWithRelationInput[]
		cursor?: ProductIngredientsWhereUniqueInput
		take?: number
		skip?: number
		distinct?: ProductIngredientsScalarFieldEnum | ProductIngredientsScalarFieldEnum[]
	}

	/**
	 * Product.orderItem
	 */
	export type Product$orderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		where?: OrderItemWhereInput
		orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
		cursor?: OrderItemWhereUniqueInput
		take?: number
		skip?: number
		distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
	}

	/**
	 * Product.comments
	 */
	export type Product$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		where?: ProductCommentWhereInput
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		cursor?: ProductCommentWhereUniqueInput
		take?: number
		skip?: number
		distinct?: ProductCommentScalarFieldEnum | ProductCommentScalarFieldEnum[]
	}

	/**
	 * Product without action
	 */
	export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Product
		 */
		select?: ProductSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Product
		 */
		omit?: ProductOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductInclude<ExtArgs> | null
	}

	/**
	 * Model Favorite
	 */

	export type AggregateFavorite = {
		_count: FavoriteCountAggregateOutputType | null
		_min: FavoriteMinAggregateOutputType | null
		_max: FavoriteMaxAggregateOutputType | null
	}

	export type FavoriteMinAggregateOutputType = {
		id: string | null
		productId: string | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type FavoriteMaxAggregateOutputType = {
		id: string | null
		productId: string | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type FavoriteCountAggregateOutputType = {
		id: number
		productId: number
		accountId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type FavoriteMinAggregateInputType = {
		id?: true
		productId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type FavoriteMaxAggregateInputType = {
		id?: true
		productId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type FavoriteCountAggregateInputType = {
		id?: true
		productId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Favorite to aggregate.
		 */
		where?: FavoriteWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Favorites to fetch.
		 */
		orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: FavoriteWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Favorites from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Favorites.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Favorites
		 **/
		_count?: true | FavoriteCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: FavoriteMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: FavoriteMaxAggregateInputType
	}

	export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
		[P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateFavorite[P]>
			: GetScalarType<T[P], AggregateFavorite[P]>
	}

	export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: FavoriteWhereInput
		orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
		by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
		having?: FavoriteScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: FavoriteCountAggregateInputType | true
		_min?: FavoriteMinAggregateInputType
		_max?: FavoriteMaxAggregateInputType
	}

	export type FavoriteGroupByOutputType = {
		id: string
		productId: string
		accountId: string
		createdAt: Date
		updatedAt: Date
		_count: FavoriteCountAggregateOutputType | null
		_min: FavoriteMinAggregateOutputType | null
		_max: FavoriteMaxAggregateOutputType | null
	}

	type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<FavoriteGroupByOutputType, T['by']> & {
				[P in keyof T & keyof FavoriteGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], FavoriteGroupByOutputType[P]>
					: GetScalarType<T[P], FavoriteGroupByOutputType[P]>
			}
		>
	>

	export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			productId?: boolean
			accountId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			product?: boolean | ProductDefaultArgs<ExtArgs>
			account?: boolean | AccountDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['favorite']
	>

	export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				productId?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				product?: boolean | ProductDefaultArgs<ExtArgs>
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['favorite']
		>

	export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				productId?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				product?: boolean | ProductDefaultArgs<ExtArgs>
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['favorite']
		>

	export type FavoriteSelectScalar = {
		id?: boolean
		productId?: boolean
		accountId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'productId' | 'accountId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['favorite']
	>
	export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		product?: boolean | ProductDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		product?: boolean | ProductDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		product?: boolean | ProductDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Favorite'
		objects: {
			product: Prisma.$ProductPayload<ExtArgs>
			account: Prisma.$AccountPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				productId: string
				accountId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['favorite']
		>
		composites: {}
	}

	type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<
		Prisma.$FavoritePayload,
		S
	>

	type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		FavoriteFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: FavoriteCountAggregateInputType | true
	}

	export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite']; meta: { name: 'Favorite' } }
		/**
		 * Find zero or one Favorite that matches the filter.
		 * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
		 * @example
		 * // Get one Favorite
		 * const favorite = await prisma.favorite.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends FavoriteFindUniqueArgs>(
			args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
		 * @example
		 * // Get one Favorite
		 * const favorite = await prisma.favorite.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(
			args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Favorite that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
		 * @example
		 * // Get one Favorite
		 * const favorite = await prisma.favorite.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends FavoriteFindFirstArgs>(
			args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Favorite that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
		 * @example
		 * // Get one Favorite
		 * const favorite = await prisma.favorite.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(
			args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Favorites that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Favorites
		 * const favorites = await prisma.favorite.findMany()
		 *
		 * // Get first 10 Favorites
		 * const favorites = await prisma.favorite.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends FavoriteFindManyArgs>(
			args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Favorite.
		 * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
		 * @example
		 * // Create one Favorite
		 * const Favorite = await prisma.favorite.create({
		 *   data: {
		 *     // ... data to create a Favorite
		 *   }
		 * })
		 *
		 */
		create<T extends FavoriteCreateArgs>(
			args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Favorites.
		 * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
		 * @example
		 * // Create many Favorites
		 * const favorite = await prisma.favorite.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends FavoriteCreateManyArgs>(
			args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Favorites and returns the data saved in the database.
		 * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
		 * @example
		 * // Create many Favorites
		 * const favorite = await prisma.favorite.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Favorites and only return the `id`
		 * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(
			args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Favorite.
		 * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
		 * @example
		 * // Delete one Favorite
		 * const Favorite = await prisma.favorite.delete({
		 *   where: {
		 *     // ... filter to delete one Favorite
		 *   }
		 * })
		 *
		 */
		delete<T extends FavoriteDeleteArgs>(
			args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Favorite.
		 * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
		 * @example
		 * // Update one Favorite
		 * const favorite = await prisma.favorite.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends FavoriteUpdateArgs>(
			args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Favorites.
		 * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
		 * @example
		 * // Delete a few Favorites
		 * const { count } = await prisma.favorite.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends FavoriteDeleteManyArgs>(
			args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Favorites.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Favorites
		 * const favorite = await prisma.favorite.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends FavoriteUpdateManyArgs>(
			args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Favorites and returns the data updated in the database.
		 * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
		 * @example
		 * // Update many Favorites
		 * const favorite = await prisma.favorite.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Favorites and only return the `id`
		 * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(
			args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Favorite.
		 * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
		 * @example
		 * // Update or create a Favorite
		 * const favorite = await prisma.favorite.upsert({
		 *   create: {
		 *     // ... data to create a Favorite
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Favorite we want to update
		 *   }
		 * })
		 */
		upsert<T extends FavoriteUpsertArgs>(
			args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>
		): Prisma__FavoriteClient<
			$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Favorites.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
		 * @example
		 * // Count the number of Favorites
		 * const count = await prisma.favorite.count({
		 *   where: {
		 *     // ... the filter for the Favorites we want to count
		 *   }
		 * })
		 **/
		count<T extends FavoriteCountArgs>(
			args?: Subset<T, FavoriteCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], FavoriteCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Favorite.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends FavoriteAggregateArgs>(
			args: Subset<T, FavoriteAggregateArgs>
		): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

		/**
		 * Group by Favorite.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {FavoriteGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends FavoriteGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: FavoriteGroupByArgs['orderBy'] }
				: { orderBy?: FavoriteGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Favorite model
		 */
		readonly fields: FavoriteFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Favorite.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__FavoriteClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		product<T extends ProductDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductDefaultArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Favorite model
	 */
	interface FavoriteFieldRefs {
		readonly id: FieldRef<'Favorite', 'String'>
		readonly productId: FieldRef<'Favorite', 'String'>
		readonly accountId: FieldRef<'Favorite', 'String'>
		readonly createdAt: FieldRef<'Favorite', 'DateTime'>
		readonly updatedAt: FieldRef<'Favorite', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Favorite findUnique
	 */
	export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * Filter, which Favorite to fetch.
		 */
		where: FavoriteWhereUniqueInput
	}

	/**
	 * Favorite findUniqueOrThrow
	 */
	export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * Filter, which Favorite to fetch.
		 */
		where: FavoriteWhereUniqueInput
	}

	/**
	 * Favorite findFirst
	 */
	export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * Filter, which Favorite to fetch.
		 */
		where?: FavoriteWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Favorites to fetch.
		 */
		orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Favorites.
		 */
		cursor?: FavoriteWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Favorites from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Favorites.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Favorites.
		 */
		distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
	}

	/**
	 * Favorite findFirstOrThrow
	 */
	export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * Filter, which Favorite to fetch.
		 */
		where?: FavoriteWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Favorites to fetch.
		 */
		orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Favorites.
		 */
		cursor?: FavoriteWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Favorites from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Favorites.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Favorites.
		 */
		distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
	}

	/**
	 * Favorite findMany
	 */
	export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * Filter, which Favorites to fetch.
		 */
		where?: FavoriteWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Favorites to fetch.
		 */
		orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Favorites.
		 */
		cursor?: FavoriteWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Favorites from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Favorites.
		 */
		skip?: number
		distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
	}

	/**
	 * Favorite create
	 */
	export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * The data needed to create a Favorite.
		 */
		data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
	}

	/**
	 * Favorite createMany
	 */
	export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Favorites.
		 */
		data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Favorite createManyAndReturn
	 */
	export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * The data used to create many Favorites.
		 */
		data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Favorite update
	 */
	export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * The data needed to update a Favorite.
		 */
		data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
		/**
		 * Choose, which Favorite to update.
		 */
		where: FavoriteWhereUniqueInput
	}

	/**
	 * Favorite updateMany
	 */
	export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Favorites.
		 */
		data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
		/**
		 * Filter which Favorites to update
		 */
		where?: FavoriteWhereInput
		/**
		 * Limit how many Favorites to update.
		 */
		limit?: number
	}

	/**
	 * Favorite updateManyAndReturn
	 */
	export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * The data used to update Favorites.
		 */
		data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
		/**
		 * Filter which Favorites to update
		 */
		where?: FavoriteWhereInput
		/**
		 * Limit how many Favorites to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Favorite upsert
	 */
	export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * The filter to search for the Favorite to update in case it exists.
		 */
		where: FavoriteWhereUniqueInput
		/**
		 * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
		 */
		create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
		/**
		 * In case the Favorite was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
	}

	/**
	 * Favorite delete
	 */
	export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		/**
		 * Filter which Favorite to delete.
		 */
		where: FavoriteWhereUniqueInput
	}

	/**
	 * Favorite deleteMany
	 */
	export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Favorites to delete
		 */
		where?: FavoriteWhereInput
		/**
		 * Limit how many Favorites to delete.
		 */
		limit?: number
	}

	/**
	 * Favorite without action
	 */
	export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
	}

	/**
	 * Model AccountSettings
	 */

	export type AggregateAccountSettings = {
		_count: AccountSettingsCountAggregateOutputType | null
		_min: AccountSettingsMinAggregateOutputType | null
		_max: AccountSettingsMaxAggregateOutputType | null
	}

	export type AccountSettingsMinAggregateOutputType = {
		id: string | null
		accountId: string | null
		telegramId: string | null
		isVerifiedEmail: boolean | null
		isTwoFactorEmailEnabled: boolean | null
		isTwoFactorTotpEnabled: boolean | null
		totpSecret: string | null
		siteNotification: boolean | null
		telegramNotification: boolean | null
	}

	export type AccountSettingsMaxAggregateOutputType = {
		id: string | null
		accountId: string | null
		telegramId: string | null
		isVerifiedEmail: boolean | null
		isTwoFactorEmailEnabled: boolean | null
		isTwoFactorTotpEnabled: boolean | null
		totpSecret: string | null
		siteNotification: boolean | null
		telegramNotification: boolean | null
	}

	export type AccountSettingsCountAggregateOutputType = {
		id: number
		accountId: number
		telegramId: number
		isVerifiedEmail: number
		isTwoFactorEmailEnabled: number
		isTwoFactorTotpEnabled: number
		totpSecret: number
		siteNotification: number
		telegramNotification: number
		_all: number
	}

	export type AccountSettingsMinAggregateInputType = {
		id?: true
		accountId?: true
		telegramId?: true
		isVerifiedEmail?: true
		isTwoFactorEmailEnabled?: true
		isTwoFactorTotpEnabled?: true
		totpSecret?: true
		siteNotification?: true
		telegramNotification?: true
	}

	export type AccountSettingsMaxAggregateInputType = {
		id?: true
		accountId?: true
		telegramId?: true
		isVerifiedEmail?: true
		isTwoFactorEmailEnabled?: true
		isTwoFactorTotpEnabled?: true
		totpSecret?: true
		siteNotification?: true
		telegramNotification?: true
	}

	export type AccountSettingsCountAggregateInputType = {
		id?: true
		accountId?: true
		telegramId?: true
		isVerifiedEmail?: true
		isTwoFactorEmailEnabled?: true
		isTwoFactorTotpEnabled?: true
		totpSecret?: true
		siteNotification?: true
		telegramNotification?: true
		_all?: true
	}

	export type AccountSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which AccountSettings to aggregate.
		 */
		where?: AccountSettingsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountSettings to fetch.
		 */
		orderBy?: AccountSettingsOrderByWithRelationInput | AccountSettingsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: AccountSettingsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountSettings from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountSettings.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned AccountSettings
		 **/
		_count?: true | AccountSettingsCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: AccountSettingsMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: AccountSettingsMaxAggregateInputType
	}

	export type GetAccountSettingsAggregateType<T extends AccountSettingsAggregateArgs> = {
		[P in keyof T & keyof AggregateAccountSettings]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateAccountSettings[P]>
			: GetScalarType<T[P], AggregateAccountSettings[P]>
	}

	export type AccountSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: AccountSettingsWhereInput
		orderBy?: AccountSettingsOrderByWithAggregationInput | AccountSettingsOrderByWithAggregationInput[]
		by: AccountSettingsScalarFieldEnum[] | AccountSettingsScalarFieldEnum
		having?: AccountSettingsScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: AccountSettingsCountAggregateInputType | true
		_min?: AccountSettingsMinAggregateInputType
		_max?: AccountSettingsMaxAggregateInputType
	}

	export type AccountSettingsGroupByOutputType = {
		id: string
		accountId: string
		telegramId: string | null
		isVerifiedEmail: boolean
		isTwoFactorEmailEnabled: boolean
		isTwoFactorTotpEnabled: boolean
		totpSecret: string | null
		siteNotification: boolean
		telegramNotification: boolean
		_count: AccountSettingsCountAggregateOutputType | null
		_min: AccountSettingsMinAggregateOutputType | null
		_max: AccountSettingsMaxAggregateOutputType | null
	}

	type GetAccountSettingsGroupByPayload<T extends AccountSettingsGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<AccountSettingsGroupByOutputType, T['by']> & {
				[P in keyof T & keyof AccountSettingsGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], AccountSettingsGroupByOutputType[P]>
					: GetScalarType<T[P], AccountSettingsGroupByOutputType[P]>
			}
		>
	>

	export type AccountSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			accountId?: boolean
			telegramId?: boolean
			isVerifiedEmail?: boolean
			isTwoFactorEmailEnabled?: boolean
			isTwoFactorTotpEnabled?: boolean
			totpSecret?: boolean
			siteNotification?: boolean
			telegramNotification?: boolean
			account?: boolean | AccountDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['accountSettings']
	>

	export type AccountSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				telegramId?: boolean
				isVerifiedEmail?: boolean
				isTwoFactorEmailEnabled?: boolean
				isTwoFactorTotpEnabled?: boolean
				totpSecret?: boolean
				siteNotification?: boolean
				telegramNotification?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['accountSettings']
		>

	export type AccountSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				telegramId?: boolean
				isVerifiedEmail?: boolean
				isTwoFactorEmailEnabled?: boolean
				isTwoFactorTotpEnabled?: boolean
				totpSecret?: boolean
				siteNotification?: boolean
				telegramNotification?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['accountSettings']
		>

	export type AccountSettingsSelectScalar = {
		id?: boolean
		accountId?: boolean
		telegramId?: boolean
		isVerifiedEmail?: boolean
		isTwoFactorEmailEnabled?: boolean
		isTwoFactorTotpEnabled?: boolean
		totpSecret?: boolean
		siteNotification?: boolean
		telegramNotification?: boolean
	}

	export type AccountSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		| 'id'
		| 'accountId'
		| 'telegramId'
		| 'isVerifiedEmail'
		| 'isTwoFactorEmailEnabled'
		| 'isTwoFactorTotpEnabled'
		| 'totpSecret'
		| 'siteNotification'
		| 'telegramNotification',
		ExtArgs['result']['accountSettings']
	>
	export type AccountSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type AccountSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type AccountSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $AccountSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'AccountSettings'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				accountId: string
				telegramId: string | null
				isVerifiedEmail: boolean
				isTwoFactorEmailEnabled: boolean
				isTwoFactorTotpEnabled: boolean
				totpSecret: string | null
				siteNotification: boolean
				telegramNotification: boolean
			},
			ExtArgs['result']['accountSettings']
		>
		composites: {}
	}

	type AccountSettingsGetPayload<S extends boolean | null | undefined | AccountSettingsDefaultArgs> = $Result.GetResult<
		Prisma.$AccountSettingsPayload,
		S
	>

	type AccountSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		AccountSettingsFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: AccountSettingsCountAggregateInputType | true
	}

	export interface AccountSettingsDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountSettings']; meta: { name: 'AccountSettings' } }
		/**
		 * Find zero or one AccountSettings that matches the filter.
		 * @param {AccountSettingsFindUniqueArgs} args - Arguments to find a AccountSettings
		 * @example
		 * // Get one AccountSettings
		 * const accountSettings = await prisma.accountSettings.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends AccountSettingsFindUniqueArgs>(
			args: SelectSubset<T, AccountSettingsFindUniqueArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one AccountSettings that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {AccountSettingsFindUniqueOrThrowArgs} args - Arguments to find a AccountSettings
		 * @example
		 * // Get one AccountSettings
		 * const accountSettings = await prisma.accountSettings.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends AccountSettingsFindUniqueOrThrowArgs>(
			args: SelectSubset<T, AccountSettingsFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first AccountSettings that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsFindFirstArgs} args - Arguments to find a AccountSettings
		 * @example
		 * // Get one AccountSettings
		 * const accountSettings = await prisma.accountSettings.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends AccountSettingsFindFirstArgs>(
			args?: SelectSubset<T, AccountSettingsFindFirstArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first AccountSettings that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsFindFirstOrThrowArgs} args - Arguments to find a AccountSettings
		 * @example
		 * // Get one AccountSettings
		 * const accountSettings = await prisma.accountSettings.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends AccountSettingsFindFirstOrThrowArgs>(
			args?: SelectSubset<T, AccountSettingsFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more AccountSettings that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all AccountSettings
		 * const accountSettings = await prisma.accountSettings.findMany()
		 *
		 * // Get first 10 AccountSettings
		 * const accountSettings = await prisma.accountSettings.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const accountSettingsWithIdOnly = await prisma.accountSettings.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends AccountSettingsFindManyArgs>(
			args?: SelectSubset<T, AccountSettingsFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a AccountSettings.
		 * @param {AccountSettingsCreateArgs} args - Arguments to create a AccountSettings.
		 * @example
		 * // Create one AccountSettings
		 * const AccountSettings = await prisma.accountSettings.create({
		 *   data: {
		 *     // ... data to create a AccountSettings
		 *   }
		 * })
		 *
		 */
		create<T extends AccountSettingsCreateArgs>(
			args: SelectSubset<T, AccountSettingsCreateArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many AccountSettings.
		 * @param {AccountSettingsCreateManyArgs} args - Arguments to create many AccountSettings.
		 * @example
		 * // Create many AccountSettings
		 * const accountSettings = await prisma.accountSettings.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends AccountSettingsCreateManyArgs>(
			args?: SelectSubset<T, AccountSettingsCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many AccountSettings and returns the data saved in the database.
		 * @param {AccountSettingsCreateManyAndReturnArgs} args - Arguments to create many AccountSettings.
		 * @example
		 * // Create many AccountSettings
		 * const accountSettings = await prisma.accountSettings.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many AccountSettings and only return the `id`
		 * const accountSettingsWithIdOnly = await prisma.accountSettings.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends AccountSettingsCreateManyAndReturnArgs>(
			args?: SelectSubset<T, AccountSettingsCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a AccountSettings.
		 * @param {AccountSettingsDeleteArgs} args - Arguments to delete one AccountSettings.
		 * @example
		 * // Delete one AccountSettings
		 * const AccountSettings = await prisma.accountSettings.delete({
		 *   where: {
		 *     // ... filter to delete one AccountSettings
		 *   }
		 * })
		 *
		 */
		delete<T extends AccountSettingsDeleteArgs>(
			args: SelectSubset<T, AccountSettingsDeleteArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one AccountSettings.
		 * @param {AccountSettingsUpdateArgs} args - Arguments to update one AccountSettings.
		 * @example
		 * // Update one AccountSettings
		 * const accountSettings = await prisma.accountSettings.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends AccountSettingsUpdateArgs>(
			args: SelectSubset<T, AccountSettingsUpdateArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more AccountSettings.
		 * @param {AccountSettingsDeleteManyArgs} args - Arguments to filter AccountSettings to delete.
		 * @example
		 * // Delete a few AccountSettings
		 * const { count } = await prisma.accountSettings.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends AccountSettingsDeleteManyArgs>(
			args?: SelectSubset<T, AccountSettingsDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more AccountSettings.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many AccountSettings
		 * const accountSettings = await prisma.accountSettings.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends AccountSettingsUpdateManyArgs>(
			args: SelectSubset<T, AccountSettingsUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more AccountSettings and returns the data updated in the database.
		 * @param {AccountSettingsUpdateManyAndReturnArgs} args - Arguments to update many AccountSettings.
		 * @example
		 * // Update many AccountSettings
		 * const accountSettings = await prisma.accountSettings.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more AccountSettings and only return the `id`
		 * const accountSettingsWithIdOnly = await prisma.accountSettings.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends AccountSettingsUpdateManyAndReturnArgs>(
			args: SelectSubset<T, AccountSettingsUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one AccountSettings.
		 * @param {AccountSettingsUpsertArgs} args - Arguments to update or create a AccountSettings.
		 * @example
		 * // Update or create a AccountSettings
		 * const accountSettings = await prisma.accountSettings.upsert({
		 *   create: {
		 *     // ... data to create a AccountSettings
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the AccountSettings we want to update
		 *   }
		 * })
		 */
		upsert<T extends AccountSettingsUpsertArgs>(
			args: SelectSubset<T, AccountSettingsUpsertArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of AccountSettings.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsCountArgs} args - Arguments to filter AccountSettings to count.
		 * @example
		 * // Count the number of AccountSettings
		 * const count = await prisma.accountSettings.count({
		 *   where: {
		 *     // ... the filter for the AccountSettings we want to count
		 *   }
		 * })
		 **/
		count<T extends AccountSettingsCountArgs>(
			args?: Subset<T, AccountSettingsCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], AccountSettingsCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a AccountSettings.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends AccountSettingsAggregateArgs>(
			args: Subset<T, AccountSettingsAggregateArgs>
		): Prisma.PrismaPromise<GetAccountSettingsAggregateType<T>>

		/**
		 * Group by AccountSettings.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountSettingsGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends AccountSettingsGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: AccountSettingsGroupByArgs['orderBy'] }
				: { orderBy?: AccountSettingsGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, AccountSettingsGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetAccountSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the AccountSettings model
		 */
		readonly fields: AccountSettingsFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for AccountSettings.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__AccountSettingsClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the AccountSettings model
	 */
	interface AccountSettingsFieldRefs {
		readonly id: FieldRef<'AccountSettings', 'String'>
		readonly accountId: FieldRef<'AccountSettings', 'String'>
		readonly telegramId: FieldRef<'AccountSettings', 'String'>
		readonly isVerifiedEmail: FieldRef<'AccountSettings', 'Boolean'>
		readonly isTwoFactorEmailEnabled: FieldRef<'AccountSettings', 'Boolean'>
		readonly isTwoFactorTotpEnabled: FieldRef<'AccountSettings', 'Boolean'>
		readonly totpSecret: FieldRef<'AccountSettings', 'String'>
		readonly siteNotification: FieldRef<'AccountSettings', 'Boolean'>
		readonly telegramNotification: FieldRef<'AccountSettings', 'Boolean'>
	}

	// Custom InputTypes
	/**
	 * AccountSettings findUnique
	 */
	export type AccountSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * Filter, which AccountSettings to fetch.
		 */
		where: AccountSettingsWhereUniqueInput
	}

	/**
	 * AccountSettings findUniqueOrThrow
	 */
	export type AccountSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * Filter, which AccountSettings to fetch.
		 */
		where: AccountSettingsWhereUniqueInput
	}

	/**
	 * AccountSettings findFirst
	 */
	export type AccountSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * Filter, which AccountSettings to fetch.
		 */
		where?: AccountSettingsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountSettings to fetch.
		 */
		orderBy?: AccountSettingsOrderByWithRelationInput | AccountSettingsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for AccountSettings.
		 */
		cursor?: AccountSettingsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountSettings from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountSettings.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of AccountSettings.
		 */
		distinct?: AccountSettingsScalarFieldEnum | AccountSettingsScalarFieldEnum[]
	}

	/**
	 * AccountSettings findFirstOrThrow
	 */
	export type AccountSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * Filter, which AccountSettings to fetch.
		 */
		where?: AccountSettingsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountSettings to fetch.
		 */
		orderBy?: AccountSettingsOrderByWithRelationInput | AccountSettingsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for AccountSettings.
		 */
		cursor?: AccountSettingsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountSettings from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountSettings.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of AccountSettings.
		 */
		distinct?: AccountSettingsScalarFieldEnum | AccountSettingsScalarFieldEnum[]
	}

	/**
	 * AccountSettings findMany
	 */
	export type AccountSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * Filter, which AccountSettings to fetch.
		 */
		where?: AccountSettingsWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountSettings to fetch.
		 */
		orderBy?: AccountSettingsOrderByWithRelationInput | AccountSettingsOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing AccountSettings.
		 */
		cursor?: AccountSettingsWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountSettings from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountSettings.
		 */
		skip?: number
		distinct?: AccountSettingsScalarFieldEnum | AccountSettingsScalarFieldEnum[]
	}

	/**
	 * AccountSettings create
	 */
	export type AccountSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * The data needed to create a AccountSettings.
		 */
		data: XOR<AccountSettingsCreateInput, AccountSettingsUncheckedCreateInput>
	}

	/**
	 * AccountSettings createMany
	 */
	export type AccountSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many AccountSettings.
		 */
		data: AccountSettingsCreateManyInput | AccountSettingsCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * AccountSettings createManyAndReturn
	 */
	export type AccountSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * The data used to create many AccountSettings.
		 */
		data: AccountSettingsCreateManyInput | AccountSettingsCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * AccountSettings update
	 */
	export type AccountSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * The data needed to update a AccountSettings.
		 */
		data: XOR<AccountSettingsUpdateInput, AccountSettingsUncheckedUpdateInput>
		/**
		 * Choose, which AccountSettings to update.
		 */
		where: AccountSettingsWhereUniqueInput
	}

	/**
	 * AccountSettings updateMany
	 */
	export type AccountSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update AccountSettings.
		 */
		data: XOR<AccountSettingsUpdateManyMutationInput, AccountSettingsUncheckedUpdateManyInput>
		/**
		 * Filter which AccountSettings to update
		 */
		where?: AccountSettingsWhereInput
		/**
		 * Limit how many AccountSettings to update.
		 */
		limit?: number
	}

	/**
	 * AccountSettings updateManyAndReturn
	 */
	export type AccountSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * The data used to update AccountSettings.
		 */
		data: XOR<AccountSettingsUpdateManyMutationInput, AccountSettingsUncheckedUpdateManyInput>
		/**
		 * Filter which AccountSettings to update
		 */
		where?: AccountSettingsWhereInput
		/**
		 * Limit how many AccountSettings to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * AccountSettings upsert
	 */
	export type AccountSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * The filter to search for the AccountSettings to update in case it exists.
		 */
		where: AccountSettingsWhereUniqueInput
		/**
		 * In case the AccountSettings found by the `where` argument doesn't exist, create a new AccountSettings with this data.
		 */
		create: XOR<AccountSettingsCreateInput, AccountSettingsUncheckedCreateInput>
		/**
		 * In case the AccountSettings was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<AccountSettingsUpdateInput, AccountSettingsUncheckedUpdateInput>
	}

	/**
	 * AccountSettings delete
	 */
	export type AccountSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		/**
		 * Filter which AccountSettings to delete.
		 */
		where: AccountSettingsWhereUniqueInput
	}

	/**
	 * AccountSettings deleteMany
	 */
	export type AccountSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which AccountSettings to delete
		 */
		where?: AccountSettingsWhereInput
		/**
		 * Limit how many AccountSettings to delete.
		 */
		limit?: number
	}

	/**
	 * AccountSettings without action
	 */
	export type AccountSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
	}

	/**
	 * Model Account
	 */

	export type AggregateAccount = {
		_count: AccountCountAggregateOutputType | null
		_min: AccountMinAggregateOutputType | null
		_max: AccountMaxAggregateOutputType | null
	}

	export type AccountMinAggregateOutputType = {
		id: string | null
		email: string | null
		password: string | null
		userName: string | null
		picture: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type AccountMaxAggregateOutputType = {
		id: string | null
		email: string | null
		password: string | null
		userName: string | null
		picture: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type AccountCountAggregateOutputType = {
		id: number
		email: number
		password: number
		userName: number
		picture: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type AccountMinAggregateInputType = {
		id?: true
		email?: true
		password?: true
		userName?: true
		picture?: true
		createdAt?: true
		updatedAt?: true
	}

	export type AccountMaxAggregateInputType = {
		id?: true
		email?: true
		password?: true
		userName?: true
		picture?: true
		createdAt?: true
		updatedAt?: true
	}

	export type AccountCountAggregateInputType = {
		id?: true
		email?: true
		password?: true
		userName?: true
		picture?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Account to aggregate.
		 */
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 */
		orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Accounts
		 **/
		_count?: true | AccountCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: AccountMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: AccountMaxAggregateInputType
	}

	export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
		[P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateAccount[P]>
			: GetScalarType<T[P], AggregateAccount[P]>
	}

	export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: AccountWhereInput
		orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
		by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
		having?: AccountScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: AccountCountAggregateInputType | true
		_min?: AccountMinAggregateInputType
		_max?: AccountMaxAggregateInputType
	}

	export type AccountGroupByOutputType = {
		id: string
		email: string
		password: string
		userName: string
		picture: string | null
		createdAt: Date
		updatedAt: Date
		_count: AccountCountAggregateOutputType | null
		_min: AccountMinAggregateOutputType | null
		_max: AccountMaxAggregateOutputType | null
	}

	type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<AccountGroupByOutputType, T['by']> & {
				[P in keyof T & keyof AccountGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], AccountGroupByOutputType[P]>
					: GetScalarType<T[P], AccountGroupByOutputType[P]>
			}
		>
	>

	export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			email?: boolean
			password?: boolean
			userName?: boolean
			picture?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			roles?: boolean | Account$rolesArgs<ExtArgs>
			cart?: boolean | Account$cartArgs<ExtArgs>
			favorites?: boolean | Account$favoritesArgs<ExtArgs>
			orders?: boolean | Account$ordersArgs<ExtArgs>
			productComments?: boolean | Account$productCommentsArgs<ExtArgs>
			deliveryAdresses?: boolean | Account$deliveryAdressesArgs<ExtArgs>
			notifications?: boolean | Account$notificationsArgs<ExtArgs>
			posts?: boolean | Account$postsArgs<ExtArgs>
			postComments?: boolean | Account$postCommentsArgs<ExtArgs>
			postLikes?: boolean | Account$postLikesArgs<ExtArgs>
			tokens?: boolean | Account$tokensArgs<ExtArgs>
			accountSettings?: boolean | Account$accountSettingsArgs<ExtArgs>
			accountLoyalty?: boolean | Account$accountLoyaltyArgs<ExtArgs>
			sentMessages?: boolean | Account$sentMessagesArgs<ExtArgs>
			receivedMessages?: boolean | Account$receivedMessagesArgs<ExtArgs>
			_count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['account']
	>

	export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				email?: boolean
				password?: boolean
				userName?: boolean
				picture?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['account']
		>

	export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				email?: boolean
				password?: boolean
				userName?: boolean
				picture?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['account']
		>

	export type AccountSelectScalar = {
		id?: boolean
		email?: boolean
		password?: boolean
		userName?: boolean
		picture?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'email' | 'password' | 'userName' | 'picture' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['account']
	>
	export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		roles?: boolean | Account$rolesArgs<ExtArgs>
		cart?: boolean | Account$cartArgs<ExtArgs>
		favorites?: boolean | Account$favoritesArgs<ExtArgs>
		orders?: boolean | Account$ordersArgs<ExtArgs>
		productComments?: boolean | Account$productCommentsArgs<ExtArgs>
		deliveryAdresses?: boolean | Account$deliveryAdressesArgs<ExtArgs>
		notifications?: boolean | Account$notificationsArgs<ExtArgs>
		posts?: boolean | Account$postsArgs<ExtArgs>
		postComments?: boolean | Account$postCommentsArgs<ExtArgs>
		postLikes?: boolean | Account$postLikesArgs<ExtArgs>
		tokens?: boolean | Account$tokensArgs<ExtArgs>
		accountSettings?: boolean | Account$accountSettingsArgs<ExtArgs>
		accountLoyalty?: boolean | Account$accountLoyaltyArgs<ExtArgs>
		sentMessages?: boolean | Account$sentMessagesArgs<ExtArgs>
		receivedMessages?: boolean | Account$receivedMessagesArgs<ExtArgs>
		_count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
	export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

	export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Account'
		objects: {
			roles: Prisma.$AccountRolePayload<ExtArgs>[]
			cart: Prisma.$CartPayload<ExtArgs>[]
			favorites: Prisma.$FavoritePayload<ExtArgs>[]
			orders: Prisma.$OrderPayload<ExtArgs>[]
			productComments: Prisma.$ProductCommentPayload<ExtArgs>[]
			deliveryAdresses: Prisma.$DeliveryAddressPayload<ExtArgs>[]
			notifications: Prisma.$NotificationPayload<ExtArgs>[]
			posts: Prisma.$PostPayload<ExtArgs>[]
			postComments: Prisma.$PostCommentPayload<ExtArgs>[]
			postLikes: Prisma.$PostLikePayload<ExtArgs>[]
			tokens: Prisma.$TokenPayload<ExtArgs>[]
			accountSettings: Prisma.$AccountSettingsPayload<ExtArgs> | null
			accountLoyalty: Prisma.$AccountLoyaltyPayload<ExtArgs> | null
			sentMessages: Prisma.$SupportMessagePayload<ExtArgs>[]
			receivedMessages: Prisma.$SupportMessagePayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				email: string
				password: string
				userName: string
				picture: string | null
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['account']
		>
		composites: {}
	}

	type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

	type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		AccountFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: AccountCountAggregateInputType | true
	}

	export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account']; meta: { name: 'Account' } }
		/**
		 * Find zero or one Account that matches the filter.
		 * @param {AccountFindUniqueArgs} args - Arguments to find a Account
		 * @example
		 * // Get one Account
		 * const account = await prisma.account.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends AccountFindUniqueArgs>(
			args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Account that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
		 * @example
		 * // Get one Account
		 * const account = await prisma.account.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
			args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Account that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountFindFirstArgs} args - Arguments to find a Account
		 * @example
		 * // Get one Account
		 * const account = await prisma.account.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends AccountFindFirstArgs>(
			args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Account that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
		 * @example
		 * // Get one Account
		 * const account = await prisma.account.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
			args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Accounts that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Accounts
		 * const accounts = await prisma.account.findMany()
		 *
		 * // Get first 10 Accounts
		 * const accounts = await prisma.account.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends AccountFindManyArgs>(
			args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Account.
		 * @param {AccountCreateArgs} args - Arguments to create a Account.
		 * @example
		 * // Create one Account
		 * const Account = await prisma.account.create({
		 *   data: {
		 *     // ... data to create a Account
		 *   }
		 * })
		 *
		 */
		create<T extends AccountCreateArgs>(
			args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Accounts.
		 * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
		 * @example
		 * // Create many Accounts
		 * const account = await prisma.account.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends AccountCreateManyArgs>(
			args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Accounts and returns the data saved in the database.
		 * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
		 * @example
		 * // Create many Accounts
		 * const account = await prisma.account.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Accounts and only return the `id`
		 * const accountWithIdOnly = await prisma.account.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
			args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Account.
		 * @param {AccountDeleteArgs} args - Arguments to delete one Account.
		 * @example
		 * // Delete one Account
		 * const Account = await prisma.account.delete({
		 *   where: {
		 *     // ... filter to delete one Account
		 *   }
		 * })
		 *
		 */
		delete<T extends AccountDeleteArgs>(
			args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Account.
		 * @param {AccountUpdateArgs} args - Arguments to update one Account.
		 * @example
		 * // Update one Account
		 * const account = await prisma.account.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends AccountUpdateArgs>(
			args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Accounts.
		 * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
		 * @example
		 * // Delete a few Accounts
		 * const { count } = await prisma.account.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends AccountDeleteManyArgs>(
			args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Accounts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Accounts
		 * const account = await prisma.account.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends AccountUpdateManyArgs>(
			args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Accounts and returns the data updated in the database.
		 * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
		 * @example
		 * // Update many Accounts
		 * const account = await prisma.account.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Accounts and only return the `id`
		 * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
			args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Account.
		 * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
		 * @example
		 * // Update or create a Account
		 * const account = await prisma.account.upsert({
		 *   create: {
		 *     // ... data to create a Account
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Account we want to update
		 *   }
		 * })
		 */
		upsert<T extends AccountUpsertArgs>(
			args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Accounts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
		 * @example
		 * // Count the number of Accounts
		 * const count = await prisma.account.count({
		 *   where: {
		 *     // ... the filter for the Accounts we want to count
		 *   }
		 * })
		 **/
		count<T extends AccountCountArgs>(
			args?: Subset<T, AccountCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], AccountCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Account.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends AccountAggregateArgs>(
			args: Subset<T, AccountAggregateArgs>
		): Prisma.PrismaPromise<GetAccountAggregateType<T>>

		/**
		 * Group by Account.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends AccountGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: AccountGroupByArgs['orderBy'] }
				: { orderBy?: AccountGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Account model
		 */
		readonly fields: AccountFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Account.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__AccountClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		roles<T extends Account$rolesArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$rolesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		cart<T extends Account$cartArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$cartArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		favorites<T extends Account$favoritesArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$favoritesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		orders<T extends Account$ordersArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$ordersArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		productComments<T extends Account$productCommentsArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$productCommentsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		deliveryAdresses<T extends Account$deliveryAdressesArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$deliveryAdressesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		notifications<T extends Account$notificationsArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$notificationsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		posts<T extends Account$postsArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$postsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		postComments<T extends Account$postCommentsArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$postCommentsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		postLikes<T extends Account$postLikesArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$postLikesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		tokens<T extends Account$tokensArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$tokensArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		accountSettings<T extends Account$accountSettingsArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$accountSettingsArgs<ExtArgs>>
		): Prisma__AccountSettingsClient<
			$Result.GetResult<Prisma.$AccountSettingsPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		accountLoyalty<T extends Account$accountLoyaltyArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$accountLoyaltyArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		sentMessages<T extends Account$sentMessagesArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$sentMessagesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		receivedMessages<T extends Account$receivedMessagesArgs<ExtArgs> = {}>(
			args?: Subset<T, Account$receivedMessagesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Account model
	 */
	interface AccountFieldRefs {
		readonly id: FieldRef<'Account', 'String'>
		readonly email: FieldRef<'Account', 'String'>
		readonly password: FieldRef<'Account', 'String'>
		readonly userName: FieldRef<'Account', 'String'>
		readonly picture: FieldRef<'Account', 'String'>
		readonly createdAt: FieldRef<'Account', 'DateTime'>
		readonly updatedAt: FieldRef<'Account', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Account findUnique
	 */
	export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * Filter, which Account to fetch.
		 */
		where: AccountWhereUniqueInput
	}

	/**
	 * Account findUniqueOrThrow
	 */
	export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * Filter, which Account to fetch.
		 */
		where: AccountWhereUniqueInput
	}

	/**
	 * Account findFirst
	 */
	export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * Filter, which Account to fetch.
		 */
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 */
		orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Accounts.
		 */
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Accounts.
		 */
		distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
	}

	/**
	 * Account findFirstOrThrow
	 */
	export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * Filter, which Account to fetch.
		 */
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 */
		orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Accounts.
		 */
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Accounts.
		 */
		distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
	}

	/**
	 * Account findMany
	 */
	export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * Filter, which Accounts to fetch.
		 */
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 */
		orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Accounts.
		 */
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 */
		skip?: number
		distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
	}

	/**
	 * Account create
	 */
	export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * The data needed to create a Account.
		 */
		data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
	}

	/**
	 * Account createMany
	 */
	export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Accounts.
		 */
		data: AccountCreateManyInput | AccountCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Account createManyAndReturn
	 */
	export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * The data used to create many Accounts.
		 */
		data: AccountCreateManyInput | AccountCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Account update
	 */
	export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * The data needed to update a Account.
		 */
		data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
		/**
		 * Choose, which Account to update.
		 */
		where: AccountWhereUniqueInput
	}

	/**
	 * Account updateMany
	 */
	export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Accounts.
		 */
		data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
		/**
		 * Filter which Accounts to update
		 */
		where?: AccountWhereInput
		/**
		 * Limit how many Accounts to update.
		 */
		limit?: number
	}

	/**
	 * Account updateManyAndReturn
	 */
	export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * The data used to update Accounts.
		 */
		data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
		/**
		 * Filter which Accounts to update
		 */
		where?: AccountWhereInput
		/**
		 * Limit how many Accounts to update.
		 */
		limit?: number
	}

	/**
	 * Account upsert
	 */
	export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * The filter to search for the Account to update in case it exists.
		 */
		where: AccountWhereUniqueInput
		/**
		 * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
		 */
		create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
		/**
		 * In case the Account was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
	}

	/**
	 * Account delete
	 */
	export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		/**
		 * Filter which Account to delete.
		 */
		where: AccountWhereUniqueInput
	}

	/**
	 * Account deleteMany
	 */
	export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Accounts to delete
		 */
		where?: AccountWhereInput
		/**
		 * Limit how many Accounts to delete.
		 */
		limit?: number
	}

	/**
	 * Account.roles
	 */
	export type Account$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountRole
		 */
		select?: AccountRoleSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountRole
		 */
		omit?: AccountRoleOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountRoleInclude<ExtArgs> | null
		where?: AccountRoleWhereInput
		orderBy?: AccountRoleOrderByWithRelationInput | AccountRoleOrderByWithRelationInput[]
		cursor?: AccountRoleWhereUniqueInput
		take?: number
		skip?: number
		distinct?: AccountRoleScalarFieldEnum | AccountRoleScalarFieldEnum[]
	}

	/**
	 * Account.cart
	 */
	export type Account$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Cart
		 */
		select?: CartSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Cart
		 */
		omit?: CartOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: CartInclude<ExtArgs> | null
		where?: CartWhereInput
		orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
		cursor?: CartWhereUniqueInput
		take?: number
		skip?: number
		distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
	}

	/**
	 * Account.favorites
	 */
	export type Account$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Favorite
		 */
		select?: FavoriteSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Favorite
		 */
		omit?: FavoriteOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: FavoriteInclude<ExtArgs> | null
		where?: FavoriteWhereInput
		orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
		cursor?: FavoriteWhereUniqueInput
		take?: number
		skip?: number
		distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
	}

	/**
	 * Account.orders
	 */
	export type Account$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		where?: OrderWhereInput
		orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
		cursor?: OrderWhereUniqueInput
		take?: number
		skip?: number
		distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
	}

	/**
	 * Account.productComments
	 */
	export type Account$productCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		where?: ProductCommentWhereInput
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		cursor?: ProductCommentWhereUniqueInput
		take?: number
		skip?: number
		distinct?: ProductCommentScalarFieldEnum | ProductCommentScalarFieldEnum[]
	}

	/**
	 * Account.deliveryAdresses
	 */
	export type Account$deliveryAdressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		where?: DeliveryAddressWhereInput
		orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
		cursor?: DeliveryAddressWhereUniqueInput
		take?: number
		skip?: number
		distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
	}

	/**
	 * Account.notifications
	 */
	export type Account$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		where?: NotificationWhereInput
		orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
		cursor?: NotificationWhereUniqueInput
		take?: number
		skip?: number
		distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
	}

	/**
	 * Account.posts
	 */
	export type Account$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		where?: PostWhereInput
		orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
		cursor?: PostWhereUniqueInput
		take?: number
		skip?: number
		distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
	}

	/**
	 * Account.postComments
	 */
	export type Account$postCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		where?: PostCommentWhereInput
		orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
		cursor?: PostCommentWhereUniqueInput
		take?: number
		skip?: number
		distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
	}

	/**
	 * Account.postLikes
	 */
	export type Account$postLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		where?: PostLikeWhereInput
		orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
		cursor?: PostLikeWhereUniqueInput
		take?: number
		skip?: number
		distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
	}

	/**
	 * Account.tokens
	 */
	export type Account$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		where?: TokenWhereInput
		orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
		cursor?: TokenWhereUniqueInput
		take?: number
		skip?: number
		distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
	}

	/**
	 * Account.accountSettings
	 */
	export type Account$accountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountSettings
		 */
		select?: AccountSettingsSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountSettings
		 */
		omit?: AccountSettingsOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountSettingsInclude<ExtArgs> | null
		where?: AccountSettingsWhereInput
	}

	/**
	 * Account.accountLoyalty
	 */
	export type Account$accountLoyaltyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		where?: AccountLoyaltyWhereInput
	}

	/**
	 * Account.sentMessages
	 */
	export type Account$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		where?: SupportMessageWhereInput
		orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
		cursor?: SupportMessageWhereUniqueInput
		take?: number
		skip?: number
		distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
	}

	/**
	 * Account.receivedMessages
	 */
	export type Account$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		where?: SupportMessageWhereInput
		orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
		cursor?: SupportMessageWhereUniqueInput
		take?: number
		skip?: number
		distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
	}

	/**
	 * Account without action
	 */
	export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
	}

	/**
	 * Model DeliveryAddress
	 */

	export type AggregateDeliveryAddress = {
		_count: DeliveryAddressCountAggregateOutputType | null
		_min: DeliveryAddressMinAggregateOutputType | null
		_max: DeliveryAddressMaxAggregateOutputType | null
	}

	export type DeliveryAddressMinAggregateOutputType = {
		id: string | null
		accountId: string | null
		city: string | null
		street: string | null
		house: string | null
		flat: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type DeliveryAddressMaxAggregateOutputType = {
		id: string | null
		accountId: string | null
		city: string | null
		street: string | null
		house: string | null
		flat: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type DeliveryAddressCountAggregateOutputType = {
		id: number
		accountId: number
		city: number
		street: number
		house: number
		flat: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type DeliveryAddressMinAggregateInputType = {
		id?: true
		accountId?: true
		city?: true
		street?: true
		house?: true
		flat?: true
		createdAt?: true
		updatedAt?: true
	}

	export type DeliveryAddressMaxAggregateInputType = {
		id?: true
		accountId?: true
		city?: true
		street?: true
		house?: true
		flat?: true
		createdAt?: true
		updatedAt?: true
	}

	export type DeliveryAddressCountAggregateInputType = {
		id?: true
		accountId?: true
		city?: true
		street?: true
		house?: true
		flat?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type DeliveryAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which DeliveryAddress to aggregate.
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of DeliveryAddresses to fetch.
		 */
		orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: DeliveryAddressWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` DeliveryAddresses from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` DeliveryAddresses.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned DeliveryAddresses
		 **/
		_count?: true | DeliveryAddressCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: DeliveryAddressMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: DeliveryAddressMaxAggregateInputType
	}

	export type GetDeliveryAddressAggregateType<T extends DeliveryAddressAggregateArgs> = {
		[P in keyof T & keyof AggregateDeliveryAddress]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateDeliveryAddress[P]>
			: GetScalarType<T[P], AggregateDeliveryAddress[P]>
	}

	export type DeliveryAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: DeliveryAddressWhereInput
		orderBy?: DeliveryAddressOrderByWithAggregationInput | DeliveryAddressOrderByWithAggregationInput[]
		by: DeliveryAddressScalarFieldEnum[] | DeliveryAddressScalarFieldEnum
		having?: DeliveryAddressScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: DeliveryAddressCountAggregateInputType | true
		_min?: DeliveryAddressMinAggregateInputType
		_max?: DeliveryAddressMaxAggregateInputType
	}

	export type DeliveryAddressGroupByOutputType = {
		id: string
		accountId: string
		city: string
		street: string
		house: string
		flat: string
		createdAt: Date
		updatedAt: Date
		_count: DeliveryAddressCountAggregateOutputType | null
		_min: DeliveryAddressMinAggregateOutputType | null
		_max: DeliveryAddressMaxAggregateOutputType | null
	}

	type GetDeliveryAddressGroupByPayload<T extends DeliveryAddressGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<DeliveryAddressGroupByOutputType, T['by']> & {
				[P in keyof T & keyof DeliveryAddressGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], DeliveryAddressGroupByOutputType[P]>
					: GetScalarType<T[P], DeliveryAddressGroupByOutputType[P]>
			}
		>
	>

	export type DeliveryAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			accountId?: boolean
			city?: boolean
			street?: boolean
			house?: boolean
			flat?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			account?: boolean | AccountDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['deliveryAddress']
	>

	export type DeliveryAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				city?: boolean
				street?: boolean
				house?: boolean
				flat?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['deliveryAddress']
		>

	export type DeliveryAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				city?: boolean
				street?: boolean
				house?: boolean
				flat?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['deliveryAddress']
		>

	export type DeliveryAddressSelectScalar = {
		id?: boolean
		accountId?: boolean
		city?: boolean
		street?: boolean
		house?: boolean
		flat?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type DeliveryAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'accountId' | 'city' | 'street' | 'house' | 'flat' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['deliveryAddress']
	>
	export type DeliveryAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type DeliveryAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type DeliveryAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $DeliveryAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'DeliveryAddress'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				accountId: string
				city: string
				street: string
				house: string
				flat: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['deliveryAddress']
		>
		composites: {}
	}

	type DeliveryAddressGetPayload<S extends boolean | null | undefined | DeliveryAddressDefaultArgs> = $Result.GetResult<
		Prisma.$DeliveryAddressPayload,
		S
	>

	type DeliveryAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		DeliveryAddressFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: DeliveryAddressCountAggregateInputType | true
	}

	export interface DeliveryAddressDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryAddress']; meta: { name: 'DeliveryAddress' } }
		/**
		 * Find zero or one DeliveryAddress that matches the filter.
		 * @param {DeliveryAddressFindUniqueArgs} args - Arguments to find a DeliveryAddress
		 * @example
		 * // Get one DeliveryAddress
		 * const deliveryAddress = await prisma.deliveryAddress.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends DeliveryAddressFindUniqueArgs>(
			args: SelectSubset<T, DeliveryAddressFindUniqueArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one DeliveryAddress that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {DeliveryAddressFindUniqueOrThrowArgs} args - Arguments to find a DeliveryAddress
		 * @example
		 * // Get one DeliveryAddress
		 * const deliveryAddress = await prisma.deliveryAddress.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends DeliveryAddressFindUniqueOrThrowArgs>(
			args: SelectSubset<T, DeliveryAddressFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first DeliveryAddress that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressFindFirstArgs} args - Arguments to find a DeliveryAddress
		 * @example
		 * // Get one DeliveryAddress
		 * const deliveryAddress = await prisma.deliveryAddress.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends DeliveryAddressFindFirstArgs>(
			args?: SelectSubset<T, DeliveryAddressFindFirstArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first DeliveryAddress that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressFindFirstOrThrowArgs} args - Arguments to find a DeliveryAddress
		 * @example
		 * // Get one DeliveryAddress
		 * const deliveryAddress = await prisma.deliveryAddress.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends DeliveryAddressFindFirstOrThrowArgs>(
			args?: SelectSubset<T, DeliveryAddressFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more DeliveryAddresses that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all DeliveryAddresses
		 * const deliveryAddresses = await prisma.deliveryAddress.findMany()
		 *
		 * // Get first 10 DeliveryAddresses
		 * const deliveryAddresses = await prisma.deliveryAddress.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends DeliveryAddressFindManyArgs>(
			args?: SelectSubset<T, DeliveryAddressFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a DeliveryAddress.
		 * @param {DeliveryAddressCreateArgs} args - Arguments to create a DeliveryAddress.
		 * @example
		 * // Create one DeliveryAddress
		 * const DeliveryAddress = await prisma.deliveryAddress.create({
		 *   data: {
		 *     // ... data to create a DeliveryAddress
		 *   }
		 * })
		 *
		 */
		create<T extends DeliveryAddressCreateArgs>(
			args: SelectSubset<T, DeliveryAddressCreateArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many DeliveryAddresses.
		 * @param {DeliveryAddressCreateManyArgs} args - Arguments to create many DeliveryAddresses.
		 * @example
		 * // Create many DeliveryAddresses
		 * const deliveryAddress = await prisma.deliveryAddress.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends DeliveryAddressCreateManyArgs>(
			args?: SelectSubset<T, DeliveryAddressCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many DeliveryAddresses and returns the data saved in the database.
		 * @param {DeliveryAddressCreateManyAndReturnArgs} args - Arguments to create many DeliveryAddresses.
		 * @example
		 * // Create many DeliveryAddresses
		 * const deliveryAddress = await prisma.deliveryAddress.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many DeliveryAddresses and only return the `id`
		 * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends DeliveryAddressCreateManyAndReturnArgs>(
			args?: SelectSubset<T, DeliveryAddressCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a DeliveryAddress.
		 * @param {DeliveryAddressDeleteArgs} args - Arguments to delete one DeliveryAddress.
		 * @example
		 * // Delete one DeliveryAddress
		 * const DeliveryAddress = await prisma.deliveryAddress.delete({
		 *   where: {
		 *     // ... filter to delete one DeliveryAddress
		 *   }
		 * })
		 *
		 */
		delete<T extends DeliveryAddressDeleteArgs>(
			args: SelectSubset<T, DeliveryAddressDeleteArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one DeliveryAddress.
		 * @param {DeliveryAddressUpdateArgs} args - Arguments to update one DeliveryAddress.
		 * @example
		 * // Update one DeliveryAddress
		 * const deliveryAddress = await prisma.deliveryAddress.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends DeliveryAddressUpdateArgs>(
			args: SelectSubset<T, DeliveryAddressUpdateArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more DeliveryAddresses.
		 * @param {DeliveryAddressDeleteManyArgs} args - Arguments to filter DeliveryAddresses to delete.
		 * @example
		 * // Delete a few DeliveryAddresses
		 * const { count } = await prisma.deliveryAddress.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends DeliveryAddressDeleteManyArgs>(
			args?: SelectSubset<T, DeliveryAddressDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more DeliveryAddresses.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many DeliveryAddresses
		 * const deliveryAddress = await prisma.deliveryAddress.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends DeliveryAddressUpdateManyArgs>(
			args: SelectSubset<T, DeliveryAddressUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more DeliveryAddresses and returns the data updated in the database.
		 * @param {DeliveryAddressUpdateManyAndReturnArgs} args - Arguments to update many DeliveryAddresses.
		 * @example
		 * // Update many DeliveryAddresses
		 * const deliveryAddress = await prisma.deliveryAddress.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more DeliveryAddresses and only return the `id`
		 * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends DeliveryAddressUpdateManyAndReturnArgs>(
			args: SelectSubset<T, DeliveryAddressUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one DeliveryAddress.
		 * @param {DeliveryAddressUpsertArgs} args - Arguments to update or create a DeliveryAddress.
		 * @example
		 * // Update or create a DeliveryAddress
		 * const deliveryAddress = await prisma.deliveryAddress.upsert({
		 *   create: {
		 *     // ... data to create a DeliveryAddress
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the DeliveryAddress we want to update
		 *   }
		 * })
		 */
		upsert<T extends DeliveryAddressUpsertArgs>(
			args: SelectSubset<T, DeliveryAddressUpsertArgs<ExtArgs>>
		): Prisma__DeliveryAddressClient<
			$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of DeliveryAddresses.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressCountArgs} args - Arguments to filter DeliveryAddresses to count.
		 * @example
		 * // Count the number of DeliveryAddresses
		 * const count = await prisma.deliveryAddress.count({
		 *   where: {
		 *     // ... the filter for the DeliveryAddresses we want to count
		 *   }
		 * })
		 **/
		count<T extends DeliveryAddressCountArgs>(
			args?: Subset<T, DeliveryAddressCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], DeliveryAddressCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a DeliveryAddress.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends DeliveryAddressAggregateArgs>(
			args: Subset<T, DeliveryAddressAggregateArgs>
		): Prisma.PrismaPromise<GetDeliveryAddressAggregateType<T>>

		/**
		 * Group by DeliveryAddress.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeliveryAddressGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends DeliveryAddressGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: DeliveryAddressGroupByArgs['orderBy'] }
				: { orderBy?: DeliveryAddressGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, DeliveryAddressGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetDeliveryAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the DeliveryAddress model
		 */
		readonly fields: DeliveryAddressFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for DeliveryAddress.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__DeliveryAddressClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the DeliveryAddress model
	 */
	interface DeliveryAddressFieldRefs {
		readonly id: FieldRef<'DeliveryAddress', 'String'>
		readonly accountId: FieldRef<'DeliveryAddress', 'String'>
		readonly city: FieldRef<'DeliveryAddress', 'String'>
		readonly street: FieldRef<'DeliveryAddress', 'String'>
		readonly house: FieldRef<'DeliveryAddress', 'String'>
		readonly flat: FieldRef<'DeliveryAddress', 'String'>
		readonly createdAt: FieldRef<'DeliveryAddress', 'DateTime'>
		readonly updatedAt: FieldRef<'DeliveryAddress', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * DeliveryAddress findUnique
	 */
	export type DeliveryAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * Filter, which DeliveryAddress to fetch.
		 */
		where: DeliveryAddressWhereUniqueInput
	}

	/**
	 * DeliveryAddress findUniqueOrThrow
	 */
	export type DeliveryAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * Filter, which DeliveryAddress to fetch.
		 */
		where: DeliveryAddressWhereUniqueInput
	}

	/**
	 * DeliveryAddress findFirst
	 */
	export type DeliveryAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * Filter, which DeliveryAddress to fetch.
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of DeliveryAddresses to fetch.
		 */
		orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for DeliveryAddresses.
		 */
		cursor?: DeliveryAddressWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` DeliveryAddresses from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` DeliveryAddresses.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of DeliveryAddresses.
		 */
		distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
	}

	/**
	 * DeliveryAddress findFirstOrThrow
	 */
	export type DeliveryAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * Filter, which DeliveryAddress to fetch.
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of DeliveryAddresses to fetch.
		 */
		orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for DeliveryAddresses.
		 */
		cursor?: DeliveryAddressWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` DeliveryAddresses from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` DeliveryAddresses.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of DeliveryAddresses.
		 */
		distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
	}

	/**
	 * DeliveryAddress findMany
	 */
	export type DeliveryAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * Filter, which DeliveryAddresses to fetch.
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of DeliveryAddresses to fetch.
		 */
		orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing DeliveryAddresses.
		 */
		cursor?: DeliveryAddressWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` DeliveryAddresses from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` DeliveryAddresses.
		 */
		skip?: number
		distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
	}

	/**
	 * DeliveryAddress create
	 */
	export type DeliveryAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * The data needed to create a DeliveryAddress.
		 */
		data: XOR<DeliveryAddressCreateInput, DeliveryAddressUncheckedCreateInput>
	}

	/**
	 * DeliveryAddress createMany
	 */
	export type DeliveryAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many DeliveryAddresses.
		 */
		data: DeliveryAddressCreateManyInput | DeliveryAddressCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * DeliveryAddress createManyAndReturn
	 */
	export type DeliveryAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * The data used to create many DeliveryAddresses.
		 */
		data: DeliveryAddressCreateManyInput | DeliveryAddressCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * DeliveryAddress update
	 */
	export type DeliveryAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * The data needed to update a DeliveryAddress.
		 */
		data: XOR<DeliveryAddressUpdateInput, DeliveryAddressUncheckedUpdateInput>
		/**
		 * Choose, which DeliveryAddress to update.
		 */
		where: DeliveryAddressWhereUniqueInput
	}

	/**
	 * DeliveryAddress updateMany
	 */
	export type DeliveryAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update DeliveryAddresses.
		 */
		data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyInput>
		/**
		 * Filter which DeliveryAddresses to update
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * Limit how many DeliveryAddresses to update.
		 */
		limit?: number
	}

	/**
	 * DeliveryAddress updateManyAndReturn
	 */
	export type DeliveryAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * The data used to update DeliveryAddresses.
		 */
		data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyInput>
		/**
		 * Filter which DeliveryAddresses to update
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * Limit how many DeliveryAddresses to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * DeliveryAddress upsert
	 */
	export type DeliveryAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * The filter to search for the DeliveryAddress to update in case it exists.
		 */
		where: DeliveryAddressWhereUniqueInput
		/**
		 * In case the DeliveryAddress found by the `where` argument doesn't exist, create a new DeliveryAddress with this data.
		 */
		create: XOR<DeliveryAddressCreateInput, DeliveryAddressUncheckedCreateInput>
		/**
		 * In case the DeliveryAddress was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<DeliveryAddressUpdateInput, DeliveryAddressUncheckedUpdateInput>
	}

	/**
	 * DeliveryAddress delete
	 */
	export type DeliveryAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
		/**
		 * Filter which DeliveryAddress to delete.
		 */
		where: DeliveryAddressWhereUniqueInput
	}

	/**
	 * DeliveryAddress deleteMany
	 */
	export type DeliveryAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which DeliveryAddresses to delete
		 */
		where?: DeliveryAddressWhereInput
		/**
		 * Limit how many DeliveryAddresses to delete.
		 */
		limit?: number
	}

	/**
	 * DeliveryAddress without action
	 */
	export type DeliveryAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the DeliveryAddress
		 */
		select?: DeliveryAddressSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the DeliveryAddress
		 */
		omit?: DeliveryAddressOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: DeliveryAddressInclude<ExtArgs> | null
	}

	/**
	 * Model Order
	 */

	export type AggregateOrder = {
		_count: OrderCountAggregateOutputType | null
		_avg: OrderAvgAggregateOutputType | null
		_sum: OrderSumAggregateOutputType | null
		_min: OrderMinAggregateOutputType | null
		_max: OrderMaxAggregateOutputType | null
	}

	export type OrderAvgAggregateOutputType = {
		total: number | null
	}

	export type OrderSumAggregateOutputType = {
		total: number | null
	}

	export type OrderMinAggregateOutputType = {
		id: string | null
		status: $Enums.OrderStatus | null
		firstName: string | null
		lastName: string | null
		phone: string | null
		email: string | null
		deliveryAddressId: string | null
		deliveryType: $Enums.DeliveryType | null
		paymentMethod: $Enums.PaymentMethod | null
		paymentStatus: $Enums.PaymentStatus | null
		comment: string | null
		total: number | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type OrderMaxAggregateOutputType = {
		id: string | null
		status: $Enums.OrderStatus | null
		firstName: string | null
		lastName: string | null
		phone: string | null
		email: string | null
		deliveryAddressId: string | null
		deliveryType: $Enums.DeliveryType | null
		paymentMethod: $Enums.PaymentMethod | null
		paymentStatus: $Enums.PaymentStatus | null
		comment: string | null
		total: number | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type OrderCountAggregateOutputType = {
		id: number
		status: number
		firstName: number
		lastName: number
		phone: number
		email: number
		deliveryAddressId: number
		deliveryAddress: number
		deliveryType: number
		paymentMethod: number
		paymentStatus: number
		comment: number
		total: number
		accountId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type OrderAvgAggregateInputType = {
		total?: true
	}

	export type OrderSumAggregateInputType = {
		total?: true
	}

	export type OrderMinAggregateInputType = {
		id?: true
		status?: true
		firstName?: true
		lastName?: true
		phone?: true
		email?: true
		deliveryAddressId?: true
		deliveryType?: true
		paymentMethod?: true
		paymentStatus?: true
		comment?: true
		total?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type OrderMaxAggregateInputType = {
		id?: true
		status?: true
		firstName?: true
		lastName?: true
		phone?: true
		email?: true
		deliveryAddressId?: true
		deliveryType?: true
		paymentMethod?: true
		paymentStatus?: true
		comment?: true
		total?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type OrderCountAggregateInputType = {
		id?: true
		status?: true
		firstName?: true
		lastName?: true
		phone?: true
		email?: true
		deliveryAddressId?: true
		deliveryAddress?: true
		deliveryType?: true
		paymentMethod?: true
		paymentStatus?: true
		comment?: true
		total?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Order to aggregate.
		 */
		where?: OrderWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Orders to fetch.
		 */
		orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: OrderWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Orders from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Orders.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Orders
		 **/
		_count?: true | OrderCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: OrderAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: OrderSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: OrderMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: OrderMaxAggregateInputType
	}

	export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
		[P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateOrder[P]>
			: GetScalarType<T[P], AggregateOrder[P]>
	}

	export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: OrderWhereInput
		orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
		by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
		having?: OrderScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: OrderCountAggregateInputType | true
		_avg?: OrderAvgAggregateInputType
		_sum?: OrderSumAggregateInputType
		_min?: OrderMinAggregateInputType
		_max?: OrderMaxAggregateInputType
	}

	export type OrderGroupByOutputType = {
		id: string
		status: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email: string | null
		deliveryAddressId: string | null
		deliveryAddress: JsonValue | null
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment: string | null
		total: number
		accountId: string | null
		createdAt: Date
		updatedAt: Date
		_count: OrderCountAggregateOutputType | null
		_avg: OrderAvgAggregateOutputType | null
		_sum: OrderSumAggregateOutputType | null
		_min: OrderMinAggregateOutputType | null
		_max: OrderMaxAggregateOutputType | null
	}

	type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<OrderGroupByOutputType, T['by']> & {
				[P in keyof T & keyof OrderGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], OrderGroupByOutputType[P]>
					: GetScalarType<T[P], OrderGroupByOutputType[P]>
			}
		>
	>

	export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			status?: boolean
			firstName?: boolean
			lastName?: boolean
			phone?: boolean
			email?: boolean
			deliveryAddressId?: boolean
			deliveryAddress?: boolean
			deliveryType?: boolean
			paymentMethod?: boolean
			paymentStatus?: boolean
			comment?: boolean
			total?: boolean
			accountId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			items?: boolean | Order$itemsArgs<ExtArgs>
			account?: boolean | Order$accountArgs<ExtArgs>
			_count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['order']
	>

	export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				status?: boolean
				firstName?: boolean
				lastName?: boolean
				phone?: boolean
				email?: boolean
				deliveryAddressId?: boolean
				deliveryAddress?: boolean
				deliveryType?: boolean
				paymentMethod?: boolean
				paymentStatus?: boolean
				comment?: boolean
				total?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | Order$accountArgs<ExtArgs>
			},
			ExtArgs['result']['order']
		>

	export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				status?: boolean
				firstName?: boolean
				lastName?: boolean
				phone?: boolean
				email?: boolean
				deliveryAddressId?: boolean
				deliveryAddress?: boolean
				deliveryType?: boolean
				paymentMethod?: boolean
				paymentStatus?: boolean
				comment?: boolean
				total?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | Order$accountArgs<ExtArgs>
			},
			ExtArgs['result']['order']
		>

	export type OrderSelectScalar = {
		id?: boolean
		status?: boolean
		firstName?: boolean
		lastName?: boolean
		phone?: boolean
		email?: boolean
		deliveryAddressId?: boolean
		deliveryAddress?: boolean
		deliveryType?: boolean
		paymentMethod?: boolean
		paymentStatus?: boolean
		comment?: boolean
		total?: boolean
		accountId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		| 'id'
		| 'status'
		| 'firstName'
		| 'lastName'
		| 'phone'
		| 'email'
		| 'deliveryAddressId'
		| 'deliveryAddress'
		| 'deliveryType'
		| 'paymentMethod'
		| 'paymentStatus'
		| 'comment'
		| 'total'
		| 'accountId'
		| 'createdAt'
		| 'updatedAt',
		ExtArgs['result']['order']
	>
	export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		items?: boolean | Order$itemsArgs<ExtArgs>
		account?: boolean | Order$accountArgs<ExtArgs>
		_count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Order$accountArgs<ExtArgs>
	}
	export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Order$accountArgs<ExtArgs>
	}

	export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Order'
		objects: {
			items: Prisma.$OrderItemPayload<ExtArgs>[]
			account: Prisma.$AccountPayload<ExtArgs> | null
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				status: $Enums.OrderStatus
				firstName: string
				lastName: string
				phone: string
				email: string | null
				deliveryAddressId: string | null
				deliveryAddress: Prisma.JsonValue | null
				deliveryType: $Enums.DeliveryType
				paymentMethod: $Enums.PaymentMethod
				paymentStatus: $Enums.PaymentStatus
				comment: string | null
				total: number
				accountId: string | null
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['order']
		>
		composites: {}
	}

	type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

	type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		OrderFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: OrderCountAggregateInputType | true
	}

	export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order']; meta: { name: 'Order' } }
		/**
		 * Find zero or one Order that matches the filter.
		 * @param {OrderFindUniqueArgs} args - Arguments to find a Order
		 * @example
		 * // Get one Order
		 * const order = await prisma.order.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends OrderFindUniqueArgs>(
			args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Order that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
		 * @example
		 * // Get one Order
		 * const order = await prisma.order.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
			args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Order that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderFindFirstArgs} args - Arguments to find a Order
		 * @example
		 * // Get one Order
		 * const order = await prisma.order.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends OrderFindFirstArgs>(
			args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Order that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
		 * @example
		 * // Get one Order
		 * const order = await prisma.order.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
			args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Orders that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Orders
		 * const orders = await prisma.order.findMany()
		 *
		 * // Get first 10 Orders
		 * const orders = await prisma.order.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends OrderFindManyArgs>(
			args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Order.
		 * @param {OrderCreateArgs} args - Arguments to create a Order.
		 * @example
		 * // Create one Order
		 * const Order = await prisma.order.create({
		 *   data: {
		 *     // ... data to create a Order
		 *   }
		 * })
		 *
		 */
		create<T extends OrderCreateArgs>(
			args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Orders.
		 * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
		 * @example
		 * // Create many Orders
		 * const order = await prisma.order.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends OrderCreateManyArgs>(
			args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Orders and returns the data saved in the database.
		 * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
		 * @example
		 * // Create many Orders
		 * const order = await prisma.order.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Orders and only return the `id`
		 * const orderWithIdOnly = await prisma.order.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(
			args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Order.
		 * @param {OrderDeleteArgs} args - Arguments to delete one Order.
		 * @example
		 * // Delete one Order
		 * const Order = await prisma.order.delete({
		 *   where: {
		 *     // ... filter to delete one Order
		 *   }
		 * })
		 *
		 */
		delete<T extends OrderDeleteArgs>(
			args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Order.
		 * @param {OrderUpdateArgs} args - Arguments to update one Order.
		 * @example
		 * // Update one Order
		 * const order = await prisma.order.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends OrderUpdateArgs>(
			args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Orders.
		 * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
		 * @example
		 * // Delete a few Orders
		 * const { count } = await prisma.order.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends OrderDeleteManyArgs>(
			args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Orders.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Orders
		 * const order = await prisma.order.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends OrderUpdateManyArgs>(
			args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Orders and returns the data updated in the database.
		 * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
		 * @example
		 * // Update many Orders
		 * const order = await prisma.order.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Orders and only return the `id`
		 * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(
			args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Order.
		 * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
		 * @example
		 * // Update or create a Order
		 * const order = await prisma.order.upsert({
		 *   create: {
		 *     // ... data to create a Order
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Order we want to update
		 *   }
		 * })
		 */
		upsert<T extends OrderUpsertArgs>(
			args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Orders.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderCountArgs} args - Arguments to filter Orders to count.
		 * @example
		 * // Count the number of Orders
		 * const count = await prisma.order.count({
		 *   where: {
		 *     // ... the filter for the Orders we want to count
		 *   }
		 * })
		 **/
		count<T extends OrderCountArgs>(
			args?: Subset<T, OrderCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], OrderCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Order.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

		/**
		 * Group by Order.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends OrderGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: OrderGroupByArgs['orderBy'] }
				: { orderBy?: OrderGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Order model
		 */
		readonly fields: OrderFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Order.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__OrderClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		items<T extends Order$itemsArgs<ExtArgs> = {}>(
			args?: Subset<T, Order$itemsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		account<T extends Order$accountArgs<ExtArgs> = {}>(
			args?: Subset<T, Order$accountArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Order model
	 */
	interface OrderFieldRefs {
		readonly id: FieldRef<'Order', 'String'>
		readonly status: FieldRef<'Order', 'OrderStatus'>
		readonly firstName: FieldRef<'Order', 'String'>
		readonly lastName: FieldRef<'Order', 'String'>
		readonly phone: FieldRef<'Order', 'String'>
		readonly email: FieldRef<'Order', 'String'>
		readonly deliveryAddressId: FieldRef<'Order', 'String'>
		readonly deliveryAddress: FieldRef<'Order', 'Json'>
		readonly deliveryType: FieldRef<'Order', 'DeliveryType'>
		readonly paymentMethod: FieldRef<'Order', 'PaymentMethod'>
		readonly paymentStatus: FieldRef<'Order', 'PaymentStatus'>
		readonly comment: FieldRef<'Order', 'String'>
		readonly total: FieldRef<'Order', 'Float'>
		readonly accountId: FieldRef<'Order', 'String'>
		readonly createdAt: FieldRef<'Order', 'DateTime'>
		readonly updatedAt: FieldRef<'Order', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Order findUnique
	 */
	export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * Filter, which Order to fetch.
		 */
		where: OrderWhereUniqueInput
	}

	/**
	 * Order findUniqueOrThrow
	 */
	export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * Filter, which Order to fetch.
		 */
		where: OrderWhereUniqueInput
	}

	/**
	 * Order findFirst
	 */
	export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * Filter, which Order to fetch.
		 */
		where?: OrderWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Orders to fetch.
		 */
		orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Orders.
		 */
		cursor?: OrderWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Orders from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Orders.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Orders.
		 */
		distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
	}

	/**
	 * Order findFirstOrThrow
	 */
	export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * Filter, which Order to fetch.
		 */
		where?: OrderWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Orders to fetch.
		 */
		orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Orders.
		 */
		cursor?: OrderWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Orders from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Orders.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Orders.
		 */
		distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
	}

	/**
	 * Order findMany
	 */
	export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * Filter, which Orders to fetch.
		 */
		where?: OrderWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Orders to fetch.
		 */
		orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Orders.
		 */
		cursor?: OrderWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Orders from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Orders.
		 */
		skip?: number
		distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
	}

	/**
	 * Order create
	 */
	export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * The data needed to create a Order.
		 */
		data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
	}

	/**
	 * Order createMany
	 */
	export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Orders.
		 */
		data: OrderCreateManyInput | OrderCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Order createManyAndReturn
	 */
	export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * The data used to create many Orders.
		 */
		data: OrderCreateManyInput | OrderCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Order update
	 */
	export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * The data needed to update a Order.
		 */
		data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
		/**
		 * Choose, which Order to update.
		 */
		where: OrderWhereUniqueInput
	}

	/**
	 * Order updateMany
	 */
	export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Orders.
		 */
		data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
		/**
		 * Filter which Orders to update
		 */
		where?: OrderWhereInput
		/**
		 * Limit how many Orders to update.
		 */
		limit?: number
	}

	/**
	 * Order updateManyAndReturn
	 */
	export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * The data used to update Orders.
		 */
		data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
		/**
		 * Filter which Orders to update
		 */
		where?: OrderWhereInput
		/**
		 * Limit how many Orders to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Order upsert
	 */
	export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * The filter to search for the Order to update in case it exists.
		 */
		where: OrderWhereUniqueInput
		/**
		 * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
		 */
		create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
		/**
		 * In case the Order was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
	}

	/**
	 * Order delete
	 */
	export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		/**
		 * Filter which Order to delete.
		 */
		where: OrderWhereUniqueInput
	}

	/**
	 * Order deleteMany
	 */
	export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Orders to delete
		 */
		where?: OrderWhereInput
		/**
		 * Limit how many Orders to delete.
		 */
		limit?: number
	}

	/**
	 * Order.items
	 */
	export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		where?: OrderItemWhereInput
		orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
		cursor?: OrderItemWhereUniqueInput
		take?: number
		skip?: number
		distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
	}

	/**
	 * Order.account
	 */
	export type Order$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		where?: AccountWhereInput
	}

	/**
	 * Order without action
	 */
	export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
	}

	/**
	 * Model OrderItem
	 */

	export type AggregateOrderItem = {
		_count: OrderItemCountAggregateOutputType | null
		_avg: OrderItemAvgAggregateOutputType | null
		_sum: OrderItemSumAggregateOutputType | null
		_min: OrderItemMinAggregateOutputType | null
		_max: OrderItemMaxAggregateOutputType | null
	}

	export type OrderItemAvgAggregateOutputType = {
		quantity: number | null
		price: number | null
	}

	export type OrderItemSumAggregateOutputType = {
		quantity: number | null
		price: number | null
	}

	export type OrderItemMinAggregateOutputType = {
		id: string | null
		orderId: string | null
		quantity: number | null
		price: number | null
		productTitle: string | null
		productDescription: string | null
		productImageUrl: string | null
		productId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type OrderItemMaxAggregateOutputType = {
		id: string | null
		orderId: string | null
		quantity: number | null
		price: number | null
		productTitle: string | null
		productDescription: string | null
		productImageUrl: string | null
		productId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type OrderItemCountAggregateOutputType = {
		id: number
		orderId: number
		quantity: number
		price: number
		productTitle: number
		productDescription: number
		productImageUrl: number
		productId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type OrderItemAvgAggregateInputType = {
		quantity?: true
		price?: true
	}

	export type OrderItemSumAggregateInputType = {
		quantity?: true
		price?: true
	}

	export type OrderItemMinAggregateInputType = {
		id?: true
		orderId?: true
		quantity?: true
		price?: true
		productTitle?: true
		productDescription?: true
		productImageUrl?: true
		productId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type OrderItemMaxAggregateInputType = {
		id?: true
		orderId?: true
		quantity?: true
		price?: true
		productTitle?: true
		productDescription?: true
		productImageUrl?: true
		productId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type OrderItemCountAggregateInputType = {
		id?: true
		orderId?: true
		quantity?: true
		price?: true
		productTitle?: true
		productDescription?: true
		productImageUrl?: true
		productId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which OrderItem to aggregate.
		 */
		where?: OrderItemWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of OrderItems to fetch.
		 */
		orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: OrderItemWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` OrderItems from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` OrderItems.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned OrderItems
		 **/
		_count?: true | OrderItemCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: OrderItemAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: OrderItemSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: OrderItemMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: OrderItemMaxAggregateInputType
	}

	export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
		[P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateOrderItem[P]>
			: GetScalarType<T[P], AggregateOrderItem[P]>
	}

	export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: OrderItemWhereInput
		orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
		by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
		having?: OrderItemScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: OrderItemCountAggregateInputType | true
		_avg?: OrderItemAvgAggregateInputType
		_sum?: OrderItemSumAggregateInputType
		_min?: OrderItemMinAggregateInputType
		_max?: OrderItemMaxAggregateInputType
	}

	export type OrderItemGroupByOutputType = {
		id: string
		orderId: string | null
		quantity: number
		price: number
		productTitle: string
		productDescription: string | null
		productImageUrl: string | null
		productId: string
		createdAt: Date
		updatedAt: Date
		_count: OrderItemCountAggregateOutputType | null
		_avg: OrderItemAvgAggregateOutputType | null
		_sum: OrderItemSumAggregateOutputType | null
		_min: OrderItemMinAggregateOutputType | null
		_max: OrderItemMaxAggregateOutputType | null
	}

	type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<OrderItemGroupByOutputType, T['by']> & {
				[P in keyof T & keyof OrderItemGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], OrderItemGroupByOutputType[P]>
					: GetScalarType<T[P], OrderItemGroupByOutputType[P]>
			}
		>
	>

	export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			orderId?: boolean
			quantity?: boolean
			price?: boolean
			productTitle?: boolean
			productDescription?: boolean
			productImageUrl?: boolean
			productId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			order?: boolean | OrderItem$orderArgs<ExtArgs>
			product?: boolean | ProductDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['orderItem']
	>

	export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				orderId?: boolean
				quantity?: boolean
				price?: boolean
				productTitle?: boolean
				productDescription?: boolean
				productImageUrl?: boolean
				productId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				order?: boolean | OrderItem$orderArgs<ExtArgs>
				product?: boolean | ProductDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['orderItem']
		>

	export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				orderId?: boolean
				quantity?: boolean
				price?: boolean
				productTitle?: boolean
				productDescription?: boolean
				productImageUrl?: boolean
				productId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				order?: boolean | OrderItem$orderArgs<ExtArgs>
				product?: boolean | ProductDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['orderItem']
		>

	export type OrderItemSelectScalar = {
		id?: boolean
		orderId?: boolean
		quantity?: boolean
		price?: boolean
		productTitle?: boolean
		productDescription?: boolean
		productImageUrl?: boolean
		productId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		| 'id'
		| 'orderId'
		| 'quantity'
		| 'price'
		| 'productTitle'
		| 'productDescription'
		| 'productImageUrl'
		| 'productId'
		| 'createdAt'
		| 'updatedAt',
		ExtArgs['result']['orderItem']
	>
	export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		order?: boolean | OrderItem$orderArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
	}
	export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		order?: boolean | OrderItem$orderArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
	}
	export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		order?: boolean | OrderItem$orderArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
	}

	export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'OrderItem'
		objects: {
			order: Prisma.$OrderPayload<ExtArgs> | null
			product: Prisma.$ProductPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				orderId: string | null
				quantity: number
				price: number
				productTitle: string
				productDescription: string | null
				productImageUrl: string | null
				productId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['orderItem']
		>
		composites: {}
	}

	type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<
		Prisma.$OrderItemPayload,
		S
	>

	type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		OrderItemFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: OrderItemCountAggregateInputType | true
	}

	export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem']; meta: { name: 'OrderItem' } }
		/**
		 * Find zero or one OrderItem that matches the filter.
		 * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
		 * @example
		 * // Get one OrderItem
		 * const orderItem = await prisma.orderItem.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends OrderItemFindUniqueArgs>(
			args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
		 * @example
		 * // Get one OrderItem
		 * const orderItem = await prisma.orderItem.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
			args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first OrderItem that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
		 * @example
		 * // Get one OrderItem
		 * const orderItem = await prisma.orderItem.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends OrderItemFindFirstArgs>(
			args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first OrderItem that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
		 * @example
		 * // Get one OrderItem
		 * const orderItem = await prisma.orderItem.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
			args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more OrderItems that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all OrderItems
		 * const orderItems = await prisma.orderItem.findMany()
		 *
		 * // Get first 10 OrderItems
		 * const orderItems = await prisma.orderItem.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends OrderItemFindManyArgs>(
			args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a OrderItem.
		 * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
		 * @example
		 * // Create one OrderItem
		 * const OrderItem = await prisma.orderItem.create({
		 *   data: {
		 *     // ... data to create a OrderItem
		 *   }
		 * })
		 *
		 */
		create<T extends OrderItemCreateArgs>(
			args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many OrderItems.
		 * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
		 * @example
		 * // Create many OrderItems
		 * const orderItem = await prisma.orderItem.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends OrderItemCreateManyArgs>(
			args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many OrderItems and returns the data saved in the database.
		 * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
		 * @example
		 * // Create many OrderItems
		 * const orderItem = await prisma.orderItem.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many OrderItems and only return the `id`
		 * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(
			args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a OrderItem.
		 * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
		 * @example
		 * // Delete one OrderItem
		 * const OrderItem = await prisma.orderItem.delete({
		 *   where: {
		 *     // ... filter to delete one OrderItem
		 *   }
		 * })
		 *
		 */
		delete<T extends OrderItemDeleteArgs>(
			args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one OrderItem.
		 * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
		 * @example
		 * // Update one OrderItem
		 * const orderItem = await prisma.orderItem.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends OrderItemUpdateArgs>(
			args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more OrderItems.
		 * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
		 * @example
		 * // Delete a few OrderItems
		 * const { count } = await prisma.orderItem.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends OrderItemDeleteManyArgs>(
			args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more OrderItems.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many OrderItems
		 * const orderItem = await prisma.orderItem.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends OrderItemUpdateManyArgs>(
			args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more OrderItems and returns the data updated in the database.
		 * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
		 * @example
		 * // Update many OrderItems
		 * const orderItem = await prisma.orderItem.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more OrderItems and only return the `id`
		 * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(
			args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one OrderItem.
		 * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
		 * @example
		 * // Update or create a OrderItem
		 * const orderItem = await prisma.orderItem.upsert({
		 *   create: {
		 *     // ... data to create a OrderItem
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the OrderItem we want to update
		 *   }
		 * })
		 */
		upsert<T extends OrderItemUpsertArgs>(
			args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>
		): Prisma__OrderItemClient<
			$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of OrderItems.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
		 * @example
		 * // Count the number of OrderItems
		 * const count = await prisma.orderItem.count({
		 *   where: {
		 *     // ... the filter for the OrderItems we want to count
		 *   }
		 * })
		 **/
		count<T extends OrderItemCountArgs>(
			args?: Subset<T, OrderItemCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], OrderItemCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a OrderItem.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends OrderItemAggregateArgs>(
			args: Subset<T, OrderItemAggregateArgs>
		): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

		/**
		 * Group by OrderItem.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {OrderItemGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends OrderItemGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: OrderItemGroupByArgs['orderBy'] }
				: { orderBy?: OrderItemGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the OrderItem model
		 */
		readonly fields: OrderItemFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for OrderItem.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__OrderItemClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		order<T extends OrderItem$orderArgs<ExtArgs> = {}>(
			args?: Subset<T, OrderItem$orderArgs<ExtArgs>>
		): Prisma__OrderClient<
			$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		product<T extends ProductDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductDefaultArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the OrderItem model
	 */
	interface OrderItemFieldRefs {
		readonly id: FieldRef<'OrderItem', 'String'>
		readonly orderId: FieldRef<'OrderItem', 'String'>
		readonly quantity: FieldRef<'OrderItem', 'Int'>
		readonly price: FieldRef<'OrderItem', 'Float'>
		readonly productTitle: FieldRef<'OrderItem', 'String'>
		readonly productDescription: FieldRef<'OrderItem', 'String'>
		readonly productImageUrl: FieldRef<'OrderItem', 'String'>
		readonly productId: FieldRef<'OrderItem', 'String'>
		readonly createdAt: FieldRef<'OrderItem', 'DateTime'>
		readonly updatedAt: FieldRef<'OrderItem', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * OrderItem findUnique
	 */
	export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * Filter, which OrderItem to fetch.
		 */
		where: OrderItemWhereUniqueInput
	}

	/**
	 * OrderItem findUniqueOrThrow
	 */
	export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * Filter, which OrderItem to fetch.
		 */
		where: OrderItemWhereUniqueInput
	}

	/**
	 * OrderItem findFirst
	 */
	export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * Filter, which OrderItem to fetch.
		 */
		where?: OrderItemWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of OrderItems to fetch.
		 */
		orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for OrderItems.
		 */
		cursor?: OrderItemWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` OrderItems from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` OrderItems.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of OrderItems.
		 */
		distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
	}

	/**
	 * OrderItem findFirstOrThrow
	 */
	export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * Filter, which OrderItem to fetch.
		 */
		where?: OrderItemWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of OrderItems to fetch.
		 */
		orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for OrderItems.
		 */
		cursor?: OrderItemWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` OrderItems from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` OrderItems.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of OrderItems.
		 */
		distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
	}

	/**
	 * OrderItem findMany
	 */
	export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * Filter, which OrderItems to fetch.
		 */
		where?: OrderItemWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of OrderItems to fetch.
		 */
		orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing OrderItems.
		 */
		cursor?: OrderItemWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` OrderItems from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` OrderItems.
		 */
		skip?: number
		distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
	}

	/**
	 * OrderItem create
	 */
	export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * The data needed to create a OrderItem.
		 */
		data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
	}

	/**
	 * OrderItem createMany
	 */
	export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many OrderItems.
		 */
		data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * OrderItem createManyAndReturn
	 */
	export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * The data used to create many OrderItems.
		 */
		data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * OrderItem update
	 */
	export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * The data needed to update a OrderItem.
		 */
		data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
		/**
		 * Choose, which OrderItem to update.
		 */
		where: OrderItemWhereUniqueInput
	}

	/**
	 * OrderItem updateMany
	 */
	export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update OrderItems.
		 */
		data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
		/**
		 * Filter which OrderItems to update
		 */
		where?: OrderItemWhereInput
		/**
		 * Limit how many OrderItems to update.
		 */
		limit?: number
	}

	/**
	 * OrderItem updateManyAndReturn
	 */
	export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * The data used to update OrderItems.
		 */
		data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
		/**
		 * Filter which OrderItems to update
		 */
		where?: OrderItemWhereInput
		/**
		 * Limit how many OrderItems to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * OrderItem upsert
	 */
	export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * The filter to search for the OrderItem to update in case it exists.
		 */
		where: OrderItemWhereUniqueInput
		/**
		 * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
		 */
		create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
		/**
		 * In case the OrderItem was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
	}

	/**
	 * OrderItem delete
	 */
	export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
		/**
		 * Filter which OrderItem to delete.
		 */
		where: OrderItemWhereUniqueInput
	}

	/**
	 * OrderItem deleteMany
	 */
	export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which OrderItems to delete
		 */
		where?: OrderItemWhereInput
		/**
		 * Limit how many OrderItems to delete.
		 */
		limit?: number
	}

	/**
	 * OrderItem.order
	 */
	export type OrderItem$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Order
		 */
		select?: OrderSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Order
		 */
		omit?: OrderOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderInclude<ExtArgs> | null
		where?: OrderWhereInput
	}

	/**
	 * OrderItem without action
	 */
	export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the OrderItem
		 */
		select?: OrderItemSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the OrderItem
		 */
		omit?: OrderItemOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: OrderItemInclude<ExtArgs> | null
	}

	/**
	 * Model ProductComment
	 */

	export type AggregateProductComment = {
		_count: ProductCommentCountAggregateOutputType | null
		_avg: ProductCommentAvgAggregateOutputType | null
		_sum: ProductCommentSumAggregateOutputType | null
		_min: ProductCommentMinAggregateOutputType | null
		_max: ProductCommentMaxAggregateOutputType | null
	}

	export type ProductCommentAvgAggregateOutputType = {
		rating: number | null
	}

	export type ProductCommentSumAggregateOutputType = {
		rating: number | null
	}

	export type ProductCommentMinAggregateOutputType = {
		id: string | null
		comment: string | null
		rating: number | null
		parentId: string | null
		productId: string | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type ProductCommentMaxAggregateOutputType = {
		id: string | null
		comment: string | null
		rating: number | null
		parentId: string | null
		productId: string | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type ProductCommentCountAggregateOutputType = {
		id: number
		comment: number
		rating: number
		parentId: number
		productId: number
		accountId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type ProductCommentAvgAggregateInputType = {
		rating?: true
	}

	export type ProductCommentSumAggregateInputType = {
		rating?: true
	}

	export type ProductCommentMinAggregateInputType = {
		id?: true
		comment?: true
		rating?: true
		parentId?: true
		productId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type ProductCommentMaxAggregateInputType = {
		id?: true
		comment?: true
		rating?: true
		parentId?: true
		productId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type ProductCommentCountAggregateInputType = {
		id?: true
		comment?: true
		rating?: true
		parentId?: true
		productId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type ProductCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which ProductComment to aggregate.
		 */
		where?: ProductCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductComments to fetch.
		 */
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: ProductCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductComments.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned ProductComments
		 **/
		_count?: true | ProductCommentCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: ProductCommentAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: ProductCommentSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ProductCommentMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ProductCommentMaxAggregateInputType
	}

	export type GetProductCommentAggregateType<T extends ProductCommentAggregateArgs> = {
		[P in keyof T & keyof AggregateProductComment]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateProductComment[P]>
			: GetScalarType<T[P], AggregateProductComment[P]>
	}

	export type ProductCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: ProductCommentWhereInput
		orderBy?: ProductCommentOrderByWithAggregationInput | ProductCommentOrderByWithAggregationInput[]
		by: ProductCommentScalarFieldEnum[] | ProductCommentScalarFieldEnum
		having?: ProductCommentScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ProductCommentCountAggregateInputType | true
		_avg?: ProductCommentAvgAggregateInputType
		_sum?: ProductCommentSumAggregateInputType
		_min?: ProductCommentMinAggregateInputType
		_max?: ProductCommentMaxAggregateInputType
	}

	export type ProductCommentGroupByOutputType = {
		id: string
		comment: string | null
		rating: number | null
		parentId: string | null
		productId: string
		accountId: string
		createdAt: Date
		updatedAt: Date
		_count: ProductCommentCountAggregateOutputType | null
		_avg: ProductCommentAvgAggregateOutputType | null
		_sum: ProductCommentSumAggregateOutputType | null
		_min: ProductCommentMinAggregateOutputType | null
		_max: ProductCommentMaxAggregateOutputType | null
	}

	type GetProductCommentGroupByPayload<T extends ProductCommentGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<ProductCommentGroupByOutputType, T['by']> & {
				[P in keyof T & keyof ProductCommentGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], ProductCommentGroupByOutputType[P]>
					: GetScalarType<T[P], ProductCommentGroupByOutputType[P]>
			}
		>
	>

	export type ProductCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			comment?: boolean
			rating?: boolean
			parentId?: boolean
			productId?: boolean
			accountId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			parent?: boolean | ProductComment$parentArgs<ExtArgs>
			replies?: boolean | ProductComment$repliesArgs<ExtArgs>
			product?: boolean | ProductDefaultArgs<ExtArgs>
			account?: boolean | AccountDefaultArgs<ExtArgs>
			_count?: boolean | ProductCommentCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['productComment']
	>

	export type ProductCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				comment?: boolean
				rating?: boolean
				parentId?: boolean
				productId?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				parent?: boolean | ProductComment$parentArgs<ExtArgs>
				product?: boolean | ProductDefaultArgs<ExtArgs>
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['productComment']
		>

	export type ProductCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				comment?: boolean
				rating?: boolean
				parentId?: boolean
				productId?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				parent?: boolean | ProductComment$parentArgs<ExtArgs>
				product?: boolean | ProductDefaultArgs<ExtArgs>
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['productComment']
		>

	export type ProductCommentSelectScalar = {
		id?: boolean
		comment?: boolean
		rating?: boolean
		parentId?: boolean
		productId?: boolean
		accountId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type ProductCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'comment' | 'rating' | 'parentId' | 'productId' | 'accountId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['productComment']
	>
	export type ProductCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		parent?: boolean | ProductComment$parentArgs<ExtArgs>
		replies?: boolean | ProductComment$repliesArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
		_count?: boolean | ProductCommentCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type ProductCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		parent?: boolean | ProductComment$parentArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type ProductCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		parent?: boolean | ProductComment$parentArgs<ExtArgs>
		product?: boolean | ProductDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $ProductCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'ProductComment'
		objects: {
			parent: Prisma.$ProductCommentPayload<ExtArgs> | null
			replies: Prisma.$ProductCommentPayload<ExtArgs>[]
			product: Prisma.$ProductPayload<ExtArgs>
			account: Prisma.$AccountPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				comment: string | null
				rating: number | null
				parentId: string | null
				productId: string
				accountId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['productComment']
		>
		composites: {}
	}

	type ProductCommentGetPayload<S extends boolean | null | undefined | ProductCommentDefaultArgs> = $Result.GetResult<
		Prisma.$ProductCommentPayload,
		S
	>

	type ProductCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		ProductCommentFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: ProductCommentCountAggregateInputType | true
	}

	export interface ProductCommentDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductComment']; meta: { name: 'ProductComment' } }
		/**
		 * Find zero or one ProductComment that matches the filter.
		 * @param {ProductCommentFindUniqueArgs} args - Arguments to find a ProductComment
		 * @example
		 * // Get one ProductComment
		 * const productComment = await prisma.productComment.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends ProductCommentFindUniqueArgs>(
			args: SelectSubset<T, ProductCommentFindUniqueArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one ProductComment that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {ProductCommentFindUniqueOrThrowArgs} args - Arguments to find a ProductComment
		 * @example
		 * // Get one ProductComment
		 * const productComment = await prisma.productComment.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends ProductCommentFindUniqueOrThrowArgs>(
			args: SelectSubset<T, ProductCommentFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first ProductComment that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentFindFirstArgs} args - Arguments to find a ProductComment
		 * @example
		 * // Get one ProductComment
		 * const productComment = await prisma.productComment.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends ProductCommentFindFirstArgs>(
			args?: SelectSubset<T, ProductCommentFindFirstArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first ProductComment that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentFindFirstOrThrowArgs} args - Arguments to find a ProductComment
		 * @example
		 * // Get one ProductComment
		 * const productComment = await prisma.productComment.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends ProductCommentFindFirstOrThrowArgs>(
			args?: SelectSubset<T, ProductCommentFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more ProductComments that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all ProductComments
		 * const productComments = await prisma.productComment.findMany()
		 *
		 * // Get first 10 ProductComments
		 * const productComments = await prisma.productComment.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const productCommentWithIdOnly = await prisma.productComment.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends ProductCommentFindManyArgs>(
			args?: SelectSubset<T, ProductCommentFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a ProductComment.
		 * @param {ProductCommentCreateArgs} args - Arguments to create a ProductComment.
		 * @example
		 * // Create one ProductComment
		 * const ProductComment = await prisma.productComment.create({
		 *   data: {
		 *     // ... data to create a ProductComment
		 *   }
		 * })
		 *
		 */
		create<T extends ProductCommentCreateArgs>(
			args: SelectSubset<T, ProductCommentCreateArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many ProductComments.
		 * @param {ProductCommentCreateManyArgs} args - Arguments to create many ProductComments.
		 * @example
		 * // Create many ProductComments
		 * const productComment = await prisma.productComment.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends ProductCommentCreateManyArgs>(
			args?: SelectSubset<T, ProductCommentCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many ProductComments and returns the data saved in the database.
		 * @param {ProductCommentCreateManyAndReturnArgs} args - Arguments to create many ProductComments.
		 * @example
		 * // Create many ProductComments
		 * const productComment = await prisma.productComment.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many ProductComments and only return the `id`
		 * const productCommentWithIdOnly = await prisma.productComment.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends ProductCommentCreateManyAndReturnArgs>(
			args?: SelectSubset<T, ProductCommentCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a ProductComment.
		 * @param {ProductCommentDeleteArgs} args - Arguments to delete one ProductComment.
		 * @example
		 * // Delete one ProductComment
		 * const ProductComment = await prisma.productComment.delete({
		 *   where: {
		 *     // ... filter to delete one ProductComment
		 *   }
		 * })
		 *
		 */
		delete<T extends ProductCommentDeleteArgs>(
			args: SelectSubset<T, ProductCommentDeleteArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one ProductComment.
		 * @param {ProductCommentUpdateArgs} args - Arguments to update one ProductComment.
		 * @example
		 * // Update one ProductComment
		 * const productComment = await prisma.productComment.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends ProductCommentUpdateArgs>(
			args: SelectSubset<T, ProductCommentUpdateArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more ProductComments.
		 * @param {ProductCommentDeleteManyArgs} args - Arguments to filter ProductComments to delete.
		 * @example
		 * // Delete a few ProductComments
		 * const { count } = await prisma.productComment.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends ProductCommentDeleteManyArgs>(
			args?: SelectSubset<T, ProductCommentDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ProductComments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many ProductComments
		 * const productComment = await prisma.productComment.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends ProductCommentUpdateManyArgs>(
			args: SelectSubset<T, ProductCommentUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ProductComments and returns the data updated in the database.
		 * @param {ProductCommentUpdateManyAndReturnArgs} args - Arguments to update many ProductComments.
		 * @example
		 * // Update many ProductComments
		 * const productComment = await prisma.productComment.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more ProductComments and only return the `id`
		 * const productCommentWithIdOnly = await prisma.productComment.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends ProductCommentUpdateManyAndReturnArgs>(
			args: SelectSubset<T, ProductCommentUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one ProductComment.
		 * @param {ProductCommentUpsertArgs} args - Arguments to update or create a ProductComment.
		 * @example
		 * // Update or create a ProductComment
		 * const productComment = await prisma.productComment.upsert({
		 *   create: {
		 *     // ... data to create a ProductComment
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the ProductComment we want to update
		 *   }
		 * })
		 */
		upsert<T extends ProductCommentUpsertArgs>(
			args: SelectSubset<T, ProductCommentUpsertArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of ProductComments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentCountArgs} args - Arguments to filter ProductComments to count.
		 * @example
		 * // Count the number of ProductComments
		 * const count = await prisma.productComment.count({
		 *   where: {
		 *     // ... the filter for the ProductComments we want to count
		 *   }
		 * })
		 **/
		count<T extends ProductCommentCountArgs>(
			args?: Subset<T, ProductCommentCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ProductCommentCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a ProductComment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ProductCommentAggregateArgs>(
			args: Subset<T, ProductCommentAggregateArgs>
		): Prisma.PrismaPromise<GetProductCommentAggregateType<T>>

		/**
		 * Group by ProductComment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProductCommentGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ProductCommentGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ProductCommentGroupByArgs['orderBy'] }
				: { orderBy?: ProductCommentGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, ProductCommentGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetProductCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the ProductComment model
		 */
		readonly fields: ProductCommentFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for ProductComment.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__ProductCommentClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		parent<T extends ProductComment$parentArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductComment$parentArgs<ExtArgs>>
		): Prisma__ProductCommentClient<
			$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		replies<T extends ProductComment$repliesArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductComment$repliesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		product<T extends ProductDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, ProductDefaultArgs<ExtArgs>>
		): Prisma__ProductClient<
			$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the ProductComment model
	 */
	interface ProductCommentFieldRefs {
		readonly id: FieldRef<'ProductComment', 'String'>
		readonly comment: FieldRef<'ProductComment', 'String'>
		readonly rating: FieldRef<'ProductComment', 'Int'>
		readonly parentId: FieldRef<'ProductComment', 'String'>
		readonly productId: FieldRef<'ProductComment', 'String'>
		readonly accountId: FieldRef<'ProductComment', 'String'>
		readonly createdAt: FieldRef<'ProductComment', 'DateTime'>
		readonly updatedAt: FieldRef<'ProductComment', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * ProductComment findUnique
	 */
	export type ProductCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * Filter, which ProductComment to fetch.
		 */
		where: ProductCommentWhereUniqueInput
	}

	/**
	 * ProductComment findUniqueOrThrow
	 */
	export type ProductCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * Filter, which ProductComment to fetch.
		 */
		where: ProductCommentWhereUniqueInput
	}

	/**
	 * ProductComment findFirst
	 */
	export type ProductCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * Filter, which ProductComment to fetch.
		 */
		where?: ProductCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductComments to fetch.
		 */
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ProductComments.
		 */
		cursor?: ProductCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductComments.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ProductComments.
		 */
		distinct?: ProductCommentScalarFieldEnum | ProductCommentScalarFieldEnum[]
	}

	/**
	 * ProductComment findFirstOrThrow
	 */
	export type ProductCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * Filter, which ProductComment to fetch.
		 */
		where?: ProductCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductComments to fetch.
		 */
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ProductComments.
		 */
		cursor?: ProductCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductComments.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ProductComments.
		 */
		distinct?: ProductCommentScalarFieldEnum | ProductCommentScalarFieldEnum[]
	}

	/**
	 * ProductComment findMany
	 */
	export type ProductCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * Filter, which ProductComments to fetch.
		 */
		where?: ProductCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ProductComments to fetch.
		 */
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing ProductComments.
		 */
		cursor?: ProductCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ProductComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ProductComments.
		 */
		skip?: number
		distinct?: ProductCommentScalarFieldEnum | ProductCommentScalarFieldEnum[]
	}

	/**
	 * ProductComment create
	 */
	export type ProductCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * The data needed to create a ProductComment.
		 */
		data: XOR<ProductCommentCreateInput, ProductCommentUncheckedCreateInput>
	}

	/**
	 * ProductComment createMany
	 */
	export type ProductCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many ProductComments.
		 */
		data: ProductCommentCreateManyInput | ProductCommentCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * ProductComment createManyAndReturn
	 */
	export type ProductCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * The data used to create many ProductComments.
		 */
		data: ProductCommentCreateManyInput | ProductCommentCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * ProductComment update
	 */
	export type ProductCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * The data needed to update a ProductComment.
		 */
		data: XOR<ProductCommentUpdateInput, ProductCommentUncheckedUpdateInput>
		/**
		 * Choose, which ProductComment to update.
		 */
		where: ProductCommentWhereUniqueInput
	}

	/**
	 * ProductComment updateMany
	 */
	export type ProductCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update ProductComments.
		 */
		data: XOR<ProductCommentUpdateManyMutationInput, ProductCommentUncheckedUpdateManyInput>
		/**
		 * Filter which ProductComments to update
		 */
		where?: ProductCommentWhereInput
		/**
		 * Limit how many ProductComments to update.
		 */
		limit?: number
	}

	/**
	 * ProductComment updateManyAndReturn
	 */
	export type ProductCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * The data used to update ProductComments.
		 */
		data: XOR<ProductCommentUpdateManyMutationInput, ProductCommentUncheckedUpdateManyInput>
		/**
		 * Filter which ProductComments to update
		 */
		where?: ProductCommentWhereInput
		/**
		 * Limit how many ProductComments to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * ProductComment upsert
	 */
	export type ProductCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * The filter to search for the ProductComment to update in case it exists.
		 */
		where: ProductCommentWhereUniqueInput
		/**
		 * In case the ProductComment found by the `where` argument doesn't exist, create a new ProductComment with this data.
		 */
		create: XOR<ProductCommentCreateInput, ProductCommentUncheckedCreateInput>
		/**
		 * In case the ProductComment was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<ProductCommentUpdateInput, ProductCommentUncheckedUpdateInput>
	}

	/**
	 * ProductComment delete
	 */
	export type ProductCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		/**
		 * Filter which ProductComment to delete.
		 */
		where: ProductCommentWhereUniqueInput
	}

	/**
	 * ProductComment deleteMany
	 */
	export type ProductCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which ProductComments to delete
		 */
		where?: ProductCommentWhereInput
		/**
		 * Limit how many ProductComments to delete.
		 */
		limit?: number
	}

	/**
	 * ProductComment.parent
	 */
	export type ProductComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		where?: ProductCommentWhereInput
	}

	/**
	 * ProductComment.replies
	 */
	export type ProductComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
		where?: ProductCommentWhereInput
		orderBy?: ProductCommentOrderByWithRelationInput | ProductCommentOrderByWithRelationInput[]
		cursor?: ProductCommentWhereUniqueInput
		take?: number
		skip?: number
		distinct?: ProductCommentScalarFieldEnum | ProductCommentScalarFieldEnum[]
	}

	/**
	 * ProductComment without action
	 */
	export type ProductCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the ProductComment
		 */
		select?: ProductCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the ProductComment
		 */
		omit?: ProductCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: ProductCommentInclude<ExtArgs> | null
	}

	/**
	 * Model Post
	 */

	export type AggregatePost = {
		_count: PostCountAggregateOutputType | null
		_min: PostMinAggregateOutputType | null
		_max: PostMaxAggregateOutputType | null
	}

	export type PostMinAggregateOutputType = {
		id: string | null
		title: string | null
		description: string | null
		imageUrl: string | null
		published: boolean | null
		authorId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type PostMaxAggregateOutputType = {
		id: string | null
		title: string | null
		description: string | null
		imageUrl: string | null
		published: boolean | null
		authorId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type PostCountAggregateOutputType = {
		id: number
		title: number
		description: number
		imageUrl: number
		published: number
		authorId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type PostMinAggregateInputType = {
		id?: true
		title?: true
		description?: true
		imageUrl?: true
		published?: true
		authorId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type PostMaxAggregateInputType = {
		id?: true
		title?: true
		description?: true
		imageUrl?: true
		published?: true
		authorId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type PostCountAggregateInputType = {
		id?: true
		title?: true
		description?: true
		imageUrl?: true
		published?: true
		authorId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Post to aggregate.
		 */
		where?: PostWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Posts to fetch.
		 */
		orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: PostWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Posts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Posts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Posts
		 **/
		_count?: true | PostCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: PostMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: PostMaxAggregateInputType
	}

	export type GetPostAggregateType<T extends PostAggregateArgs> = {
		[P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregatePost[P]>
			: GetScalarType<T[P], AggregatePost[P]>
	}

	export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostWhereInput
		orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
		by: PostScalarFieldEnum[] | PostScalarFieldEnum
		having?: PostScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: PostCountAggregateInputType | true
		_min?: PostMinAggregateInputType
		_max?: PostMaxAggregateInputType
	}

	export type PostGroupByOutputType = {
		id: string
		title: string
		description: string | null
		imageUrl: string | null
		published: boolean
		authorId: string
		createdAt: Date
		updatedAt: Date
		_count: PostCountAggregateOutputType | null
		_min: PostMinAggregateOutputType | null
		_max: PostMaxAggregateOutputType | null
	}

	type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<PostGroupByOutputType, T['by']> & {
				[P in keyof T & keyof PostGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], PostGroupByOutputType[P]>
					: GetScalarType<T[P], PostGroupByOutputType[P]>
			}
		>
	>

	export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			title?: boolean
			description?: boolean
			imageUrl?: boolean
			published?: boolean
			authorId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			author?: boolean | AccountDefaultArgs<ExtArgs>
			comments?: boolean | Post$commentsArgs<ExtArgs>
			likes?: boolean | Post$likesArgs<ExtArgs>
			_count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['post']
	>

	export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				description?: boolean
				imageUrl?: boolean
				published?: boolean
				authorId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				author?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['post']
		>

	export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				description?: boolean
				imageUrl?: boolean
				published?: boolean
				authorId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				author?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['post']
		>

	export type PostSelectScalar = {
		id?: boolean
		title?: boolean
		description?: boolean
		imageUrl?: boolean
		published?: boolean
		authorId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'title' | 'description' | 'imageUrl' | 'published' | 'authorId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['post']
	>
	export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		author?: boolean | AccountDefaultArgs<ExtArgs>
		comments?: boolean | Post$commentsArgs<ExtArgs>
		likes?: boolean | Post$likesArgs<ExtArgs>
		_count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		author?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		author?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Post'
		objects: {
			author: Prisma.$AccountPayload<ExtArgs>
			comments: Prisma.$PostCommentPayload<ExtArgs>[]
			likes: Prisma.$PostLikePayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				title: string
				description: string | null
				imageUrl: string | null
				published: boolean
				authorId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['post']
		>
		composites: {}
	}

	type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

	type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		PostFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: PostCountAggregateInputType | true
	}

	export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post']; meta: { name: 'Post' } }
		/**
		 * Find zero or one Post that matches the filter.
		 * @param {PostFindUniqueArgs} args - Arguments to find a Post
		 * @example
		 * // Get one Post
		 * const post = await prisma.post.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends PostFindUniqueArgs>(
			args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Post that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
		 * @example
		 * // Get one Post
		 * const post = await prisma.post.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
			args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Post that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostFindFirstArgs} args - Arguments to find a Post
		 * @example
		 * // Get one Post
		 * const post = await prisma.post.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends PostFindFirstArgs>(
			args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Post that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
		 * @example
		 * // Get one Post
		 * const post = await prisma.post.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
			args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Posts that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Posts
		 * const posts = await prisma.post.findMany()
		 *
		 * // Get first 10 Posts
		 * const posts = await prisma.post.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends PostFindManyArgs>(
			args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Post.
		 * @param {PostCreateArgs} args - Arguments to create a Post.
		 * @example
		 * // Create one Post
		 * const Post = await prisma.post.create({
		 *   data: {
		 *     // ... data to create a Post
		 *   }
		 * })
		 *
		 */
		create<T extends PostCreateArgs>(
			args: SelectSubset<T, PostCreateArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Posts.
		 * @param {PostCreateManyArgs} args - Arguments to create many Posts.
		 * @example
		 * // Create many Posts
		 * const post = await prisma.post.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends PostCreateManyArgs>(
			args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Posts and returns the data saved in the database.
		 * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
		 * @example
		 * // Create many Posts
		 * const post = await prisma.post.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Posts and only return the `id`
		 * const postWithIdOnly = await prisma.post.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends PostCreateManyAndReturnArgs>(
			args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Post.
		 * @param {PostDeleteArgs} args - Arguments to delete one Post.
		 * @example
		 * // Delete one Post
		 * const Post = await prisma.post.delete({
		 *   where: {
		 *     // ... filter to delete one Post
		 *   }
		 * })
		 *
		 */
		delete<T extends PostDeleteArgs>(
			args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Post.
		 * @param {PostUpdateArgs} args - Arguments to update one Post.
		 * @example
		 * // Update one Post
		 * const post = await prisma.post.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends PostUpdateArgs>(
			args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Posts.
		 * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
		 * @example
		 * // Delete a few Posts
		 * const { count } = await prisma.post.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends PostDeleteManyArgs>(
			args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Posts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Posts
		 * const post = await prisma.post.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends PostUpdateManyArgs>(
			args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Posts and returns the data updated in the database.
		 * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
		 * @example
		 * // Update many Posts
		 * const post = await prisma.post.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Posts and only return the `id`
		 * const postWithIdOnly = await prisma.post.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(
			args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Post.
		 * @param {PostUpsertArgs} args - Arguments to update or create a Post.
		 * @example
		 * // Update or create a Post
		 * const post = await prisma.post.upsert({
		 *   create: {
		 *     // ... data to create a Post
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Post we want to update
		 *   }
		 * })
		 */
		upsert<T extends PostUpsertArgs>(
			args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Posts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCountArgs} args - Arguments to filter Posts to count.
		 * @example
		 * // Count the number of Posts
		 * const count = await prisma.post.count({
		 *   where: {
		 *     // ... the filter for the Posts we want to count
		 *   }
		 * })
		 **/
		count<T extends PostCountArgs>(
			args?: Subset<T, PostCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], PostCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Post.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

		/**
		 * Group by Post.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends PostGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: PostGroupByArgs['orderBy'] }
				: { orderBy?: PostGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Post model
		 */
		readonly fields: PostFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Post.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__PostClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		author<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		comments<T extends Post$commentsArgs<ExtArgs> = {}>(
			args?: Subset<T, Post$commentsArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		likes<T extends Post$likesArgs<ExtArgs> = {}>(
			args?: Subset<T, Post$likesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Post model
	 */
	interface PostFieldRefs {
		readonly id: FieldRef<'Post', 'String'>
		readonly title: FieldRef<'Post', 'String'>
		readonly description: FieldRef<'Post', 'String'>
		readonly imageUrl: FieldRef<'Post', 'String'>
		readonly published: FieldRef<'Post', 'Boolean'>
		readonly authorId: FieldRef<'Post', 'String'>
		readonly createdAt: FieldRef<'Post', 'DateTime'>
		readonly updatedAt: FieldRef<'Post', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Post findUnique
	 */
	export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * Filter, which Post to fetch.
		 */
		where: PostWhereUniqueInput
	}

	/**
	 * Post findUniqueOrThrow
	 */
	export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * Filter, which Post to fetch.
		 */
		where: PostWhereUniqueInput
	}

	/**
	 * Post findFirst
	 */
	export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * Filter, which Post to fetch.
		 */
		where?: PostWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Posts to fetch.
		 */
		orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Posts.
		 */
		cursor?: PostWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Posts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Posts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Posts.
		 */
		distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
	}

	/**
	 * Post findFirstOrThrow
	 */
	export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * Filter, which Post to fetch.
		 */
		where?: PostWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Posts to fetch.
		 */
		orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Posts.
		 */
		cursor?: PostWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Posts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Posts.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Posts.
		 */
		distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
	}

	/**
	 * Post findMany
	 */
	export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * Filter, which Posts to fetch.
		 */
		where?: PostWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Posts to fetch.
		 */
		orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Posts.
		 */
		cursor?: PostWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Posts from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Posts.
		 */
		skip?: number
		distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
	}

	/**
	 * Post create
	 */
	export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * The data needed to create a Post.
		 */
		data: XOR<PostCreateInput, PostUncheckedCreateInput>
	}

	/**
	 * Post createMany
	 */
	export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Posts.
		 */
		data: PostCreateManyInput | PostCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Post createManyAndReturn
	 */
	export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * The data used to create many Posts.
		 */
		data: PostCreateManyInput | PostCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Post update
	 */
	export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * The data needed to update a Post.
		 */
		data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
		/**
		 * Choose, which Post to update.
		 */
		where: PostWhereUniqueInput
	}

	/**
	 * Post updateMany
	 */
	export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Posts.
		 */
		data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
		/**
		 * Filter which Posts to update
		 */
		where?: PostWhereInput
		/**
		 * Limit how many Posts to update.
		 */
		limit?: number
	}

	/**
	 * Post updateManyAndReturn
	 */
	export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * The data used to update Posts.
		 */
		data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
		/**
		 * Filter which Posts to update
		 */
		where?: PostWhereInput
		/**
		 * Limit how many Posts to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Post upsert
	 */
	export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * The filter to search for the Post to update in case it exists.
		 */
		where: PostWhereUniqueInput
		/**
		 * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
		 */
		create: XOR<PostCreateInput, PostUncheckedCreateInput>
		/**
		 * In case the Post was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
	}

	/**
	 * Post delete
	 */
	export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
		/**
		 * Filter which Post to delete.
		 */
		where: PostWhereUniqueInput
	}

	/**
	 * Post deleteMany
	 */
	export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Posts to delete
		 */
		where?: PostWhereInput
		/**
		 * Limit how many Posts to delete.
		 */
		limit?: number
	}

	/**
	 * Post.comments
	 */
	export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		where?: PostCommentWhereInput
		orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
		cursor?: PostCommentWhereUniqueInput
		take?: number
		skip?: number
		distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
	}

	/**
	 * Post.likes
	 */
	export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		where?: PostLikeWhereInput
		orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
		cursor?: PostLikeWhereUniqueInput
		take?: number
		skip?: number
		distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
	}

	/**
	 * Post without action
	 */
	export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Post
		 */
		select?: PostSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Post
		 */
		omit?: PostOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostInclude<ExtArgs> | null
	}

	/**
	 * Model PostComment
	 */

	export type AggregatePostComment = {
		_count: PostCommentCountAggregateOutputType | null
		_min: PostCommentMinAggregateOutputType | null
		_max: PostCommentMaxAggregateOutputType | null
	}

	export type PostCommentMinAggregateOutputType = {
		id: string | null
		comment: string | null
		authorId: string | null
		postId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type PostCommentMaxAggregateOutputType = {
		id: string | null
		comment: string | null
		authorId: string | null
		postId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type PostCommentCountAggregateOutputType = {
		id: number
		comment: number
		authorId: number
		postId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type PostCommentMinAggregateInputType = {
		id?: true
		comment?: true
		authorId?: true
		postId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type PostCommentMaxAggregateInputType = {
		id?: true
		comment?: true
		authorId?: true
		postId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type PostCommentCountAggregateInputType = {
		id?: true
		comment?: true
		authorId?: true
		postId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type PostCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which PostComment to aggregate.
		 */
		where?: PostCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostComments to fetch.
		 */
		orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: PostCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostComments.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned PostComments
		 **/
		_count?: true | PostCommentCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: PostCommentMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: PostCommentMaxAggregateInputType
	}

	export type GetPostCommentAggregateType<T extends PostCommentAggregateArgs> = {
		[P in keyof T & keyof AggregatePostComment]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregatePostComment[P]>
			: GetScalarType<T[P], AggregatePostComment[P]>
	}

	export type PostCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostCommentWhereInput
		orderBy?: PostCommentOrderByWithAggregationInput | PostCommentOrderByWithAggregationInput[]
		by: PostCommentScalarFieldEnum[] | PostCommentScalarFieldEnum
		having?: PostCommentScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: PostCommentCountAggregateInputType | true
		_min?: PostCommentMinAggregateInputType
		_max?: PostCommentMaxAggregateInputType
	}

	export type PostCommentGroupByOutputType = {
		id: string
		comment: string
		authorId: string
		postId: string
		createdAt: Date
		updatedAt: Date
		_count: PostCommentCountAggregateOutputType | null
		_min: PostCommentMinAggregateOutputType | null
		_max: PostCommentMaxAggregateOutputType | null
	}

	type GetPostCommentGroupByPayload<T extends PostCommentGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<PostCommentGroupByOutputType, T['by']> & {
				[P in keyof T & keyof PostCommentGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], PostCommentGroupByOutputType[P]>
					: GetScalarType<T[P], PostCommentGroupByOutputType[P]>
			}
		>
	>

	export type PostCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			comment?: boolean
			authorId?: boolean
			postId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			author?: boolean | AccountDefaultArgs<ExtArgs>
			post?: boolean | PostDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['postComment']
	>

	export type PostCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				comment?: boolean
				authorId?: boolean
				postId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				author?: boolean | AccountDefaultArgs<ExtArgs>
				post?: boolean | PostDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['postComment']
		>

	export type PostCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				comment?: boolean
				authorId?: boolean
				postId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				author?: boolean | AccountDefaultArgs<ExtArgs>
				post?: boolean | PostDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['postComment']
		>

	export type PostCommentSelectScalar = {
		id?: boolean
		comment?: boolean
		authorId?: boolean
		postId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type PostCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'comment' | 'authorId' | 'postId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['postComment']
	>
	export type PostCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		author?: boolean | AccountDefaultArgs<ExtArgs>
		post?: boolean | PostDefaultArgs<ExtArgs>
	}
	export type PostCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		author?: boolean | AccountDefaultArgs<ExtArgs>
		post?: boolean | PostDefaultArgs<ExtArgs>
	}
	export type PostCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		author?: boolean | AccountDefaultArgs<ExtArgs>
		post?: boolean | PostDefaultArgs<ExtArgs>
	}

	export type $PostCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'PostComment'
		objects: {
			author: Prisma.$AccountPayload<ExtArgs>
			post: Prisma.$PostPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				comment: string
				authorId: string
				postId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['postComment']
		>
		composites: {}
	}

	type PostCommentGetPayload<S extends boolean | null | undefined | PostCommentDefaultArgs> = $Result.GetResult<
		Prisma.$PostCommentPayload,
		S
	>

	type PostCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		PostCommentFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: PostCommentCountAggregateInputType | true
	}

	export interface PostCommentDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostComment']; meta: { name: 'PostComment' } }
		/**
		 * Find zero or one PostComment that matches the filter.
		 * @param {PostCommentFindUniqueArgs} args - Arguments to find a PostComment
		 * @example
		 * // Get one PostComment
		 * const postComment = await prisma.postComment.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends PostCommentFindUniqueArgs>(
			args: SelectSubset<T, PostCommentFindUniqueArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one PostComment that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {PostCommentFindUniqueOrThrowArgs} args - Arguments to find a PostComment
		 * @example
		 * // Get one PostComment
		 * const postComment = await prisma.postComment.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends PostCommentFindUniqueOrThrowArgs>(
			args: SelectSubset<T, PostCommentFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first PostComment that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentFindFirstArgs} args - Arguments to find a PostComment
		 * @example
		 * // Get one PostComment
		 * const postComment = await prisma.postComment.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends PostCommentFindFirstArgs>(
			args?: SelectSubset<T, PostCommentFindFirstArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first PostComment that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentFindFirstOrThrowArgs} args - Arguments to find a PostComment
		 * @example
		 * // Get one PostComment
		 * const postComment = await prisma.postComment.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends PostCommentFindFirstOrThrowArgs>(
			args?: SelectSubset<T, PostCommentFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more PostComments that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all PostComments
		 * const postComments = await prisma.postComment.findMany()
		 *
		 * // Get first 10 PostComments
		 * const postComments = await prisma.postComment.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const postCommentWithIdOnly = await prisma.postComment.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends PostCommentFindManyArgs>(
			args?: SelectSubset<T, PostCommentFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a PostComment.
		 * @param {PostCommentCreateArgs} args - Arguments to create a PostComment.
		 * @example
		 * // Create one PostComment
		 * const PostComment = await prisma.postComment.create({
		 *   data: {
		 *     // ... data to create a PostComment
		 *   }
		 * })
		 *
		 */
		create<T extends PostCommentCreateArgs>(
			args: SelectSubset<T, PostCommentCreateArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many PostComments.
		 * @param {PostCommentCreateManyArgs} args - Arguments to create many PostComments.
		 * @example
		 * // Create many PostComments
		 * const postComment = await prisma.postComment.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends PostCommentCreateManyArgs>(
			args?: SelectSubset<T, PostCommentCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many PostComments and returns the data saved in the database.
		 * @param {PostCommentCreateManyAndReturnArgs} args - Arguments to create many PostComments.
		 * @example
		 * // Create many PostComments
		 * const postComment = await prisma.postComment.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many PostComments and only return the `id`
		 * const postCommentWithIdOnly = await prisma.postComment.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends PostCommentCreateManyAndReturnArgs>(
			args?: SelectSubset<T, PostCommentCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a PostComment.
		 * @param {PostCommentDeleteArgs} args - Arguments to delete one PostComment.
		 * @example
		 * // Delete one PostComment
		 * const PostComment = await prisma.postComment.delete({
		 *   where: {
		 *     // ... filter to delete one PostComment
		 *   }
		 * })
		 *
		 */
		delete<T extends PostCommentDeleteArgs>(
			args: SelectSubset<T, PostCommentDeleteArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one PostComment.
		 * @param {PostCommentUpdateArgs} args - Arguments to update one PostComment.
		 * @example
		 * // Update one PostComment
		 * const postComment = await prisma.postComment.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends PostCommentUpdateArgs>(
			args: SelectSubset<T, PostCommentUpdateArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more PostComments.
		 * @param {PostCommentDeleteManyArgs} args - Arguments to filter PostComments to delete.
		 * @example
		 * // Delete a few PostComments
		 * const { count } = await prisma.postComment.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends PostCommentDeleteManyArgs>(
			args?: SelectSubset<T, PostCommentDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more PostComments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many PostComments
		 * const postComment = await prisma.postComment.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends PostCommentUpdateManyArgs>(
			args: SelectSubset<T, PostCommentUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more PostComments and returns the data updated in the database.
		 * @param {PostCommentUpdateManyAndReturnArgs} args - Arguments to update many PostComments.
		 * @example
		 * // Update many PostComments
		 * const postComment = await prisma.postComment.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more PostComments and only return the `id`
		 * const postCommentWithIdOnly = await prisma.postComment.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends PostCommentUpdateManyAndReturnArgs>(
			args: SelectSubset<T, PostCommentUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one PostComment.
		 * @param {PostCommentUpsertArgs} args - Arguments to update or create a PostComment.
		 * @example
		 * // Update or create a PostComment
		 * const postComment = await prisma.postComment.upsert({
		 *   create: {
		 *     // ... data to create a PostComment
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the PostComment we want to update
		 *   }
		 * })
		 */
		upsert<T extends PostCommentUpsertArgs>(
			args: SelectSubset<T, PostCommentUpsertArgs<ExtArgs>>
		): Prisma__PostCommentClient<
			$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of PostComments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentCountArgs} args - Arguments to filter PostComments to count.
		 * @example
		 * // Count the number of PostComments
		 * const count = await prisma.postComment.count({
		 *   where: {
		 *     // ... the filter for the PostComments we want to count
		 *   }
		 * })
		 **/
		count<T extends PostCommentCountArgs>(
			args?: Subset<T, PostCommentCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], PostCommentCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a PostComment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends PostCommentAggregateArgs>(
			args: Subset<T, PostCommentAggregateArgs>
		): Prisma.PrismaPromise<GetPostCommentAggregateType<T>>

		/**
		 * Group by PostComment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostCommentGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends PostCommentGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: PostCommentGroupByArgs['orderBy'] }
				: { orderBy?: PostCommentGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, PostCommentGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetPostCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the PostComment model
		 */
		readonly fields: PostCommentFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for PostComment.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__PostCommentClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		author<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		post<T extends PostDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, PostDefaultArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the PostComment model
	 */
	interface PostCommentFieldRefs {
		readonly id: FieldRef<'PostComment', 'String'>
		readonly comment: FieldRef<'PostComment', 'String'>
		readonly authorId: FieldRef<'PostComment', 'String'>
		readonly postId: FieldRef<'PostComment', 'String'>
		readonly createdAt: FieldRef<'PostComment', 'DateTime'>
		readonly updatedAt: FieldRef<'PostComment', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * PostComment findUnique
	 */
	export type PostCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * Filter, which PostComment to fetch.
		 */
		where: PostCommentWhereUniqueInput
	}

	/**
	 * PostComment findUniqueOrThrow
	 */
	export type PostCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * Filter, which PostComment to fetch.
		 */
		where: PostCommentWhereUniqueInput
	}

	/**
	 * PostComment findFirst
	 */
	export type PostCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * Filter, which PostComment to fetch.
		 */
		where?: PostCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostComments to fetch.
		 */
		orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for PostComments.
		 */
		cursor?: PostCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostComments.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of PostComments.
		 */
		distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
	}

	/**
	 * PostComment findFirstOrThrow
	 */
	export type PostCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * Filter, which PostComment to fetch.
		 */
		where?: PostCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostComments to fetch.
		 */
		orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for PostComments.
		 */
		cursor?: PostCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostComments.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of PostComments.
		 */
		distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
	}

	/**
	 * PostComment findMany
	 */
	export type PostCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * Filter, which PostComments to fetch.
		 */
		where?: PostCommentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostComments to fetch.
		 */
		orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing PostComments.
		 */
		cursor?: PostCommentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostComments from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostComments.
		 */
		skip?: number
		distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
	}

	/**
	 * PostComment create
	 */
	export type PostCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * The data needed to create a PostComment.
		 */
		data: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
	}

	/**
	 * PostComment createMany
	 */
	export type PostCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many PostComments.
		 */
		data: PostCommentCreateManyInput | PostCommentCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * PostComment createManyAndReturn
	 */
	export type PostCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * The data used to create many PostComments.
		 */
		data: PostCommentCreateManyInput | PostCommentCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * PostComment update
	 */
	export type PostCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * The data needed to update a PostComment.
		 */
		data: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
		/**
		 * Choose, which PostComment to update.
		 */
		where: PostCommentWhereUniqueInput
	}

	/**
	 * PostComment updateMany
	 */
	export type PostCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update PostComments.
		 */
		data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyInput>
		/**
		 * Filter which PostComments to update
		 */
		where?: PostCommentWhereInput
		/**
		 * Limit how many PostComments to update.
		 */
		limit?: number
	}

	/**
	 * PostComment updateManyAndReturn
	 */
	export type PostCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * The data used to update PostComments.
		 */
		data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyInput>
		/**
		 * Filter which PostComments to update
		 */
		where?: PostCommentWhereInput
		/**
		 * Limit how many PostComments to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * PostComment upsert
	 */
	export type PostCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * The filter to search for the PostComment to update in case it exists.
		 */
		where: PostCommentWhereUniqueInput
		/**
		 * In case the PostComment found by the `where` argument doesn't exist, create a new PostComment with this data.
		 */
		create: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
		/**
		 * In case the PostComment was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
	}

	/**
	 * PostComment delete
	 */
	export type PostCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
		/**
		 * Filter which PostComment to delete.
		 */
		where: PostCommentWhereUniqueInput
	}

	/**
	 * PostComment deleteMany
	 */
	export type PostCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which PostComments to delete
		 */
		where?: PostCommentWhereInput
		/**
		 * Limit how many PostComments to delete.
		 */
		limit?: number
	}

	/**
	 * PostComment without action
	 */
	export type PostCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostComment
		 */
		select?: PostCommentSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostComment
		 */
		omit?: PostCommentOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostCommentInclude<ExtArgs> | null
	}

	/**
	 * Model PostLike
	 */

	export type AggregatePostLike = {
		_count: PostLikeCountAggregateOutputType | null
		_min: PostLikeMinAggregateOutputType | null
		_max: PostLikeMaxAggregateOutputType | null
	}

	export type PostLikeMinAggregateOutputType = {
		id: string | null
		postId: string | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type PostLikeMaxAggregateOutputType = {
		id: string | null
		postId: string | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type PostLikeCountAggregateOutputType = {
		id: number
		postId: number
		accountId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type PostLikeMinAggregateInputType = {
		id?: true
		postId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type PostLikeMaxAggregateInputType = {
		id?: true
		postId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type PostLikeCountAggregateInputType = {
		id?: true
		postId?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type PostLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which PostLike to aggregate.
		 */
		where?: PostLikeWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostLikes to fetch.
		 */
		orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: PostLikeWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostLikes from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostLikes.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned PostLikes
		 **/
		_count?: true | PostLikeCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: PostLikeMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: PostLikeMaxAggregateInputType
	}

	export type GetPostLikeAggregateType<T extends PostLikeAggregateArgs> = {
		[P in keyof T & keyof AggregatePostLike]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregatePostLike[P]>
			: GetScalarType<T[P], AggregatePostLike[P]>
	}

	export type PostLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: PostLikeWhereInput
		orderBy?: PostLikeOrderByWithAggregationInput | PostLikeOrderByWithAggregationInput[]
		by: PostLikeScalarFieldEnum[] | PostLikeScalarFieldEnum
		having?: PostLikeScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: PostLikeCountAggregateInputType | true
		_min?: PostLikeMinAggregateInputType
		_max?: PostLikeMaxAggregateInputType
	}

	export type PostLikeGroupByOutputType = {
		id: string
		postId: string
		accountId: string
		createdAt: Date
		updatedAt: Date
		_count: PostLikeCountAggregateOutputType | null
		_min: PostLikeMinAggregateOutputType | null
		_max: PostLikeMaxAggregateOutputType | null
	}

	type GetPostLikeGroupByPayload<T extends PostLikeGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<PostLikeGroupByOutputType, T['by']> & {
				[P in keyof T & keyof PostLikeGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], PostLikeGroupByOutputType[P]>
					: GetScalarType<T[P], PostLikeGroupByOutputType[P]>
			}
		>
	>

	export type PostLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			postId?: boolean
			accountId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			post?: boolean | PostDefaultArgs<ExtArgs>
			account?: boolean | AccountDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['postLike']
	>

	export type PostLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				postId?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				post?: boolean | PostDefaultArgs<ExtArgs>
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['postLike']
		>

	export type PostLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				postId?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				post?: boolean | PostDefaultArgs<ExtArgs>
				account?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['postLike']
		>

	export type PostLikeSelectScalar = {
		id?: boolean
		postId?: boolean
		accountId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type PostLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'postId' | 'accountId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['postLike']
	>
	export type PostLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		post?: boolean | PostDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type PostLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		post?: boolean | PostDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type PostLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		post?: boolean | PostDefaultArgs<ExtArgs>
		account?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $PostLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'PostLike'
		objects: {
			post: Prisma.$PostPayload<ExtArgs>
			account: Prisma.$AccountPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				postId: string
				accountId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['postLike']
		>
		composites: {}
	}

	type PostLikeGetPayload<S extends boolean | null | undefined | PostLikeDefaultArgs> = $Result.GetResult<
		Prisma.$PostLikePayload,
		S
	>

	type PostLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		PostLikeFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: PostLikeCountAggregateInputType | true
	}

	export interface PostLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostLike']; meta: { name: 'PostLike' } }
		/**
		 * Find zero or one PostLike that matches the filter.
		 * @param {PostLikeFindUniqueArgs} args - Arguments to find a PostLike
		 * @example
		 * // Get one PostLike
		 * const postLike = await prisma.postLike.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends PostLikeFindUniqueArgs>(
			args: SelectSubset<T, PostLikeFindUniqueArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one PostLike that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {PostLikeFindUniqueOrThrowArgs} args - Arguments to find a PostLike
		 * @example
		 * // Get one PostLike
		 * const postLike = await prisma.postLike.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends PostLikeFindUniqueOrThrowArgs>(
			args: SelectSubset<T, PostLikeFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first PostLike that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeFindFirstArgs} args - Arguments to find a PostLike
		 * @example
		 * // Get one PostLike
		 * const postLike = await prisma.postLike.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends PostLikeFindFirstArgs>(
			args?: SelectSubset<T, PostLikeFindFirstArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first PostLike that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeFindFirstOrThrowArgs} args - Arguments to find a PostLike
		 * @example
		 * // Get one PostLike
		 * const postLike = await prisma.postLike.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends PostLikeFindFirstOrThrowArgs>(
			args?: SelectSubset<T, PostLikeFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more PostLikes that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all PostLikes
		 * const postLikes = await prisma.postLike.findMany()
		 *
		 * // Get first 10 PostLikes
		 * const postLikes = await prisma.postLike.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const postLikeWithIdOnly = await prisma.postLike.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends PostLikeFindManyArgs>(
			args?: SelectSubset<T, PostLikeFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a PostLike.
		 * @param {PostLikeCreateArgs} args - Arguments to create a PostLike.
		 * @example
		 * // Create one PostLike
		 * const PostLike = await prisma.postLike.create({
		 *   data: {
		 *     // ... data to create a PostLike
		 *   }
		 * })
		 *
		 */
		create<T extends PostLikeCreateArgs>(
			args: SelectSubset<T, PostLikeCreateArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many PostLikes.
		 * @param {PostLikeCreateManyArgs} args - Arguments to create many PostLikes.
		 * @example
		 * // Create many PostLikes
		 * const postLike = await prisma.postLike.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends PostLikeCreateManyArgs>(
			args?: SelectSubset<T, PostLikeCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many PostLikes and returns the data saved in the database.
		 * @param {PostLikeCreateManyAndReturnArgs} args - Arguments to create many PostLikes.
		 * @example
		 * // Create many PostLikes
		 * const postLike = await prisma.postLike.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many PostLikes and only return the `id`
		 * const postLikeWithIdOnly = await prisma.postLike.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends PostLikeCreateManyAndReturnArgs>(
			args?: SelectSubset<T, PostLikeCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a PostLike.
		 * @param {PostLikeDeleteArgs} args - Arguments to delete one PostLike.
		 * @example
		 * // Delete one PostLike
		 * const PostLike = await prisma.postLike.delete({
		 *   where: {
		 *     // ... filter to delete one PostLike
		 *   }
		 * })
		 *
		 */
		delete<T extends PostLikeDeleteArgs>(
			args: SelectSubset<T, PostLikeDeleteArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one PostLike.
		 * @param {PostLikeUpdateArgs} args - Arguments to update one PostLike.
		 * @example
		 * // Update one PostLike
		 * const postLike = await prisma.postLike.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends PostLikeUpdateArgs>(
			args: SelectSubset<T, PostLikeUpdateArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more PostLikes.
		 * @param {PostLikeDeleteManyArgs} args - Arguments to filter PostLikes to delete.
		 * @example
		 * // Delete a few PostLikes
		 * const { count } = await prisma.postLike.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends PostLikeDeleteManyArgs>(
			args?: SelectSubset<T, PostLikeDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more PostLikes.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many PostLikes
		 * const postLike = await prisma.postLike.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends PostLikeUpdateManyArgs>(
			args: SelectSubset<T, PostLikeUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more PostLikes and returns the data updated in the database.
		 * @param {PostLikeUpdateManyAndReturnArgs} args - Arguments to update many PostLikes.
		 * @example
		 * // Update many PostLikes
		 * const postLike = await prisma.postLike.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more PostLikes and only return the `id`
		 * const postLikeWithIdOnly = await prisma.postLike.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends PostLikeUpdateManyAndReturnArgs>(
			args: SelectSubset<T, PostLikeUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one PostLike.
		 * @param {PostLikeUpsertArgs} args - Arguments to update or create a PostLike.
		 * @example
		 * // Update or create a PostLike
		 * const postLike = await prisma.postLike.upsert({
		 *   create: {
		 *     // ... data to create a PostLike
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the PostLike we want to update
		 *   }
		 * })
		 */
		upsert<T extends PostLikeUpsertArgs>(
			args: SelectSubset<T, PostLikeUpsertArgs<ExtArgs>>
		): Prisma__PostLikeClient<
			$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of PostLikes.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeCountArgs} args - Arguments to filter PostLikes to count.
		 * @example
		 * // Count the number of PostLikes
		 * const count = await prisma.postLike.count({
		 *   where: {
		 *     // ... the filter for the PostLikes we want to count
		 *   }
		 * })
		 **/
		count<T extends PostLikeCountArgs>(
			args?: Subset<T, PostLikeCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], PostLikeCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a PostLike.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends PostLikeAggregateArgs>(
			args: Subset<T, PostLikeAggregateArgs>
		): Prisma.PrismaPromise<GetPostLikeAggregateType<T>>

		/**
		 * Group by PostLike.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {PostLikeGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends PostLikeGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: PostLikeGroupByArgs['orderBy'] }
				: { orderBy?: PostLikeGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, PostLikeGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetPostLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the PostLike model
		 */
		readonly fields: PostLikeFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for PostLike.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__PostLikeClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		post<T extends PostDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, PostDefaultArgs<ExtArgs>>
		): Prisma__PostClient<
			$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the PostLike model
	 */
	interface PostLikeFieldRefs {
		readonly id: FieldRef<'PostLike', 'String'>
		readonly postId: FieldRef<'PostLike', 'String'>
		readonly accountId: FieldRef<'PostLike', 'String'>
		readonly createdAt: FieldRef<'PostLike', 'DateTime'>
		readonly updatedAt: FieldRef<'PostLike', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * PostLike findUnique
	 */
	export type PostLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * Filter, which PostLike to fetch.
		 */
		where: PostLikeWhereUniqueInput
	}

	/**
	 * PostLike findUniqueOrThrow
	 */
	export type PostLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * Filter, which PostLike to fetch.
		 */
		where: PostLikeWhereUniqueInput
	}

	/**
	 * PostLike findFirst
	 */
	export type PostLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * Filter, which PostLike to fetch.
		 */
		where?: PostLikeWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostLikes to fetch.
		 */
		orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for PostLikes.
		 */
		cursor?: PostLikeWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostLikes from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostLikes.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of PostLikes.
		 */
		distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
	}

	/**
	 * PostLike findFirstOrThrow
	 */
	export type PostLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * Filter, which PostLike to fetch.
		 */
		where?: PostLikeWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostLikes to fetch.
		 */
		orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for PostLikes.
		 */
		cursor?: PostLikeWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostLikes from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostLikes.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of PostLikes.
		 */
		distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
	}

	/**
	 * PostLike findMany
	 */
	export type PostLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * Filter, which PostLikes to fetch.
		 */
		where?: PostLikeWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of PostLikes to fetch.
		 */
		orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing PostLikes.
		 */
		cursor?: PostLikeWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` PostLikes from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` PostLikes.
		 */
		skip?: number
		distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
	}

	/**
	 * PostLike create
	 */
	export type PostLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * The data needed to create a PostLike.
		 */
		data: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
	}

	/**
	 * PostLike createMany
	 */
	export type PostLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many PostLikes.
		 */
		data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * PostLike createManyAndReturn
	 */
	export type PostLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * The data used to create many PostLikes.
		 */
		data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * PostLike update
	 */
	export type PostLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * The data needed to update a PostLike.
		 */
		data: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
		/**
		 * Choose, which PostLike to update.
		 */
		where: PostLikeWhereUniqueInput
	}

	/**
	 * PostLike updateMany
	 */
	export type PostLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update PostLikes.
		 */
		data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
		/**
		 * Filter which PostLikes to update
		 */
		where?: PostLikeWhereInput
		/**
		 * Limit how many PostLikes to update.
		 */
		limit?: number
	}

	/**
	 * PostLike updateManyAndReturn
	 */
	export type PostLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * The data used to update PostLikes.
		 */
		data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
		/**
		 * Filter which PostLikes to update
		 */
		where?: PostLikeWhereInput
		/**
		 * Limit how many PostLikes to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * PostLike upsert
	 */
	export type PostLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * The filter to search for the PostLike to update in case it exists.
		 */
		where: PostLikeWhereUniqueInput
		/**
		 * In case the PostLike found by the `where` argument doesn't exist, create a new PostLike with this data.
		 */
		create: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
		/**
		 * In case the PostLike was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
	}

	/**
	 * PostLike delete
	 */
	export type PostLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
		/**
		 * Filter which PostLike to delete.
		 */
		where: PostLikeWhereUniqueInput
	}

	/**
	 * PostLike deleteMany
	 */
	export type PostLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which PostLikes to delete
		 */
		where?: PostLikeWhereInput
		/**
		 * Limit how many PostLikes to delete.
		 */
		limit?: number
	}

	/**
	 * PostLike without action
	 */
	export type PostLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the PostLike
		 */
		select?: PostLikeSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the PostLike
		 */
		omit?: PostLikeOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: PostLikeInclude<ExtArgs> | null
	}

	/**
	 * Model Token
	 */

	export type AggregateToken = {
		_count: TokenCountAggregateOutputType | null
		_min: TokenMinAggregateOutputType | null
		_max: TokenMaxAggregateOutputType | null
	}

	export type TokenMinAggregateOutputType = {
		id: string | null
		token: string | null
		type: $Enums.TokenTypes | null
		accountId: string | null
		expiresIn: Date | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type TokenMaxAggregateOutputType = {
		id: string | null
		token: string | null
		type: $Enums.TokenTypes | null
		accountId: string | null
		expiresIn: Date | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type TokenCountAggregateOutputType = {
		id: number
		token: number
		type: number
		accountId: number
		expiresIn: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type TokenMinAggregateInputType = {
		id?: true
		token?: true
		type?: true
		accountId?: true
		expiresIn?: true
		createdAt?: true
		updatedAt?: true
	}

	export type TokenMaxAggregateInputType = {
		id?: true
		token?: true
		type?: true
		accountId?: true
		expiresIn?: true
		createdAt?: true
		updatedAt?: true
	}

	export type TokenCountAggregateInputType = {
		id?: true
		token?: true
		type?: true
		accountId?: true
		expiresIn?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Token to aggregate.
		 */
		where?: TokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Tokens to fetch.
		 */
		orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: TokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Tokens from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Tokens.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Tokens
		 **/
		_count?: true | TokenCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: TokenMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: TokenMaxAggregateInputType
	}

	export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
		[P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateToken[P]>
			: GetScalarType<T[P], AggregateToken[P]>
	}

	export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: TokenWhereInput
		orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
		by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
		having?: TokenScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: TokenCountAggregateInputType | true
		_min?: TokenMinAggregateInputType
		_max?: TokenMaxAggregateInputType
	}

	export type TokenGroupByOutputType = {
		id: string
		token: string
		type: $Enums.TokenTypes
		accountId: string
		expiresIn: Date
		createdAt: Date
		updatedAt: Date
		_count: TokenCountAggregateOutputType | null
		_min: TokenMinAggregateOutputType | null
		_max: TokenMaxAggregateOutputType | null
	}

	type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<TokenGroupByOutputType, T['by']> & {
				[P in keyof T & keyof TokenGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], TokenGroupByOutputType[P]>
					: GetScalarType<T[P], TokenGroupByOutputType[P]>
			}
		>
	>

	export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			token?: boolean
			type?: boolean
			accountId?: boolean
			expiresIn?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			account?: boolean | Token$accountArgs<ExtArgs>
		},
		ExtArgs['result']['token']
	>

	export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				token?: boolean
				type?: boolean
				accountId?: boolean
				expiresIn?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | Token$accountArgs<ExtArgs>
			},
			ExtArgs['result']['token']
		>

	export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				token?: boolean
				type?: boolean
				accountId?: boolean
				expiresIn?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | Token$accountArgs<ExtArgs>
			},
			ExtArgs['result']['token']
		>

	export type TokenSelectScalar = {
		id?: boolean
		token?: boolean
		type?: boolean
		accountId?: boolean
		expiresIn?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'token' | 'type' | 'accountId' | 'expiresIn' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['token']
	>
	export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Token$accountArgs<ExtArgs>
	}
	export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Token$accountArgs<ExtArgs>
	}
	export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Token$accountArgs<ExtArgs>
	}

	export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Token'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs> | null
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				token: string
				type: $Enums.TokenTypes
				accountId: string
				expiresIn: Date
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['token']
		>
		composites: {}
	}

	type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

	type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		TokenFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: TokenCountAggregateInputType | true
	}

	export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token']; meta: { name: 'Token' } }
		/**
		 * Find zero or one Token that matches the filter.
		 * @param {TokenFindUniqueArgs} args - Arguments to find a Token
		 * @example
		 * // Get one Token
		 * const token = await prisma.token.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends TokenFindUniqueArgs>(
			args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Token that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
		 * @example
		 * // Get one Token
		 * const token = await prisma.token.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(
			args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Token that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenFindFirstArgs} args - Arguments to find a Token
		 * @example
		 * // Get one Token
		 * const token = await prisma.token.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends TokenFindFirstArgs>(
			args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Token that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
		 * @example
		 * // Get one Token
		 * const token = await prisma.token.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(
			args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Tokens that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Tokens
		 * const tokens = await prisma.token.findMany()
		 *
		 * // Get first 10 Tokens
		 * const tokens = await prisma.token.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends TokenFindManyArgs>(
			args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Token.
		 * @param {TokenCreateArgs} args - Arguments to create a Token.
		 * @example
		 * // Create one Token
		 * const Token = await prisma.token.create({
		 *   data: {
		 *     // ... data to create a Token
		 *   }
		 * })
		 *
		 */
		create<T extends TokenCreateArgs>(
			args: SelectSubset<T, TokenCreateArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Tokens.
		 * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
		 * @example
		 * // Create many Tokens
		 * const token = await prisma.token.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends TokenCreateManyArgs>(
			args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Tokens and returns the data saved in the database.
		 * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
		 * @example
		 * // Create many Tokens
		 * const token = await prisma.token.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Tokens and only return the `id`
		 * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(
			args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Token.
		 * @param {TokenDeleteArgs} args - Arguments to delete one Token.
		 * @example
		 * // Delete one Token
		 * const Token = await prisma.token.delete({
		 *   where: {
		 *     // ... filter to delete one Token
		 *   }
		 * })
		 *
		 */
		delete<T extends TokenDeleteArgs>(
			args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Token.
		 * @param {TokenUpdateArgs} args - Arguments to update one Token.
		 * @example
		 * // Update one Token
		 * const token = await prisma.token.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends TokenUpdateArgs>(
			args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Tokens.
		 * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
		 * @example
		 * // Delete a few Tokens
		 * const { count } = await prisma.token.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends TokenDeleteManyArgs>(
			args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Tokens.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Tokens
		 * const token = await prisma.token.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends TokenUpdateManyArgs>(
			args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Tokens and returns the data updated in the database.
		 * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
		 * @example
		 * // Update many Tokens
		 * const token = await prisma.token.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Tokens and only return the `id`
		 * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(
			args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Token.
		 * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
		 * @example
		 * // Update or create a Token
		 * const token = await prisma.token.upsert({
		 *   create: {
		 *     // ... data to create a Token
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Token we want to update
		 *   }
		 * })
		 */
		upsert<T extends TokenUpsertArgs>(
			args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>
		): Prisma__TokenClient<
			$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Tokens.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
		 * @example
		 * // Count the number of Tokens
		 * const count = await prisma.token.count({
		 *   where: {
		 *     // ... the filter for the Tokens we want to count
		 *   }
		 * })
		 **/
		count<T extends TokenCountArgs>(
			args?: Subset<T, TokenCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], TokenCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Token.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

		/**
		 * Group by Token.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {TokenGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends TokenGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: TokenGroupByArgs['orderBy'] }
				: { orderBy?: TokenGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Token model
		 */
		readonly fields: TokenFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Token.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__TokenClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends Token$accountArgs<ExtArgs> = {}>(
			args?: Subset<T, Token$accountArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Token model
	 */
	interface TokenFieldRefs {
		readonly id: FieldRef<'Token', 'String'>
		readonly token: FieldRef<'Token', 'String'>
		readonly type: FieldRef<'Token', 'TokenTypes'>
		readonly accountId: FieldRef<'Token', 'String'>
		readonly expiresIn: FieldRef<'Token', 'DateTime'>
		readonly createdAt: FieldRef<'Token', 'DateTime'>
		readonly updatedAt: FieldRef<'Token', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Token findUnique
	 */
	export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * Filter, which Token to fetch.
		 */
		where: TokenWhereUniqueInput
	}

	/**
	 * Token findUniqueOrThrow
	 */
	export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * Filter, which Token to fetch.
		 */
		where: TokenWhereUniqueInput
	}

	/**
	 * Token findFirst
	 */
	export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * Filter, which Token to fetch.
		 */
		where?: TokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Tokens to fetch.
		 */
		orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Tokens.
		 */
		cursor?: TokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Tokens from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Tokens.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Tokens.
		 */
		distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
	}

	/**
	 * Token findFirstOrThrow
	 */
	export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * Filter, which Token to fetch.
		 */
		where?: TokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Tokens to fetch.
		 */
		orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Tokens.
		 */
		cursor?: TokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Tokens from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Tokens.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Tokens.
		 */
		distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
	}

	/**
	 * Token findMany
	 */
	export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * Filter, which Tokens to fetch.
		 */
		where?: TokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Tokens to fetch.
		 */
		orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Tokens.
		 */
		cursor?: TokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Tokens from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Tokens.
		 */
		skip?: number
		distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
	}

	/**
	 * Token create
	 */
	export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * The data needed to create a Token.
		 */
		data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
	}

	/**
	 * Token createMany
	 */
	export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Tokens.
		 */
		data: TokenCreateManyInput | TokenCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Token createManyAndReturn
	 */
	export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * The data used to create many Tokens.
		 */
		data: TokenCreateManyInput | TokenCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Token update
	 */
	export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * The data needed to update a Token.
		 */
		data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
		/**
		 * Choose, which Token to update.
		 */
		where: TokenWhereUniqueInput
	}

	/**
	 * Token updateMany
	 */
	export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Tokens.
		 */
		data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
		/**
		 * Filter which Tokens to update
		 */
		where?: TokenWhereInput
		/**
		 * Limit how many Tokens to update.
		 */
		limit?: number
	}

	/**
	 * Token updateManyAndReturn
	 */
	export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * The data used to update Tokens.
		 */
		data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
		/**
		 * Filter which Tokens to update
		 */
		where?: TokenWhereInput
		/**
		 * Limit how many Tokens to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Token upsert
	 */
	export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * The filter to search for the Token to update in case it exists.
		 */
		where: TokenWhereUniqueInput
		/**
		 * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
		 */
		create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
		/**
		 * In case the Token was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
	}

	/**
	 * Token delete
	 */
	export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
		/**
		 * Filter which Token to delete.
		 */
		where: TokenWhereUniqueInput
	}

	/**
	 * Token deleteMany
	 */
	export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Tokens to delete
		 */
		where?: TokenWhereInput
		/**
		 * Limit how many Tokens to delete.
		 */
		limit?: number
	}

	/**
	 * Token.account
	 */
	export type Token$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		where?: AccountWhereInput
	}

	/**
	 * Token without action
	 */
	export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Token
		 */
		select?: TokenSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Token
		 */
		omit?: TokenOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: TokenInclude<ExtArgs> | null
	}

	/**
	 * Model Notification
	 */

	export type AggregateNotification = {
		_count: NotificationCountAggregateOutputType | null
		_min: NotificationMinAggregateOutputType | null
		_max: NotificationMaxAggregateOutputType | null
	}

	export type NotificationMinAggregateOutputType = {
		id: string | null
		title: string | null
		message: string | null
		link: string | null
		type: $Enums.NotificationType | null
		isRead: boolean | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type NotificationMaxAggregateOutputType = {
		id: string | null
		title: string | null
		message: string | null
		link: string | null
		type: $Enums.NotificationType | null
		isRead: boolean | null
		accountId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type NotificationCountAggregateOutputType = {
		id: number
		title: number
		message: number
		link: number
		type: number
		isRead: number
		accountId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type NotificationMinAggregateInputType = {
		id?: true
		title?: true
		message?: true
		link?: true
		type?: true
		isRead?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type NotificationMaxAggregateInputType = {
		id?: true
		title?: true
		message?: true
		link?: true
		type?: true
		isRead?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type NotificationCountAggregateInputType = {
		id?: true
		title?: true
		message?: true
		link?: true
		type?: true
		isRead?: true
		accountId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Notification to aggregate.
		 */
		where?: NotificationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Notifications to fetch.
		 */
		orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: NotificationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Notifications from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Notifications.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Notifications
		 **/
		_count?: true | NotificationCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: NotificationMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: NotificationMaxAggregateInputType
	}

	export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
		[P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateNotification[P]>
			: GetScalarType<T[P], AggregateNotification[P]>
	}

	export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: NotificationWhereInput
		orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
		by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
		having?: NotificationScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: NotificationCountAggregateInputType | true
		_min?: NotificationMinAggregateInputType
		_max?: NotificationMaxAggregateInputType
	}

	export type NotificationGroupByOutputType = {
		id: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead: boolean
		accountId: string
		createdAt: Date
		updatedAt: Date
		_count: NotificationCountAggregateOutputType | null
		_min: NotificationMinAggregateOutputType | null
		_max: NotificationMaxAggregateOutputType | null
	}

	type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<NotificationGroupByOutputType, T['by']> & {
				[P in keyof T & keyof NotificationGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], NotificationGroupByOutputType[P]>
					: GetScalarType<T[P], NotificationGroupByOutputType[P]>
			}
		>
	>

	export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			title?: boolean
			message?: boolean
			link?: boolean
			type?: boolean
			isRead?: boolean
			accountId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			account?: boolean | Notification$accountArgs<ExtArgs>
		},
		ExtArgs['result']['notification']
	>

	export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				message?: boolean
				link?: boolean
				type?: boolean
				isRead?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | Notification$accountArgs<ExtArgs>
			},
			ExtArgs['result']['notification']
		>

	export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				title?: boolean
				message?: boolean
				link?: boolean
				type?: boolean
				isRead?: boolean
				accountId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | Notification$accountArgs<ExtArgs>
			},
			ExtArgs['result']['notification']
		>

	export type NotificationSelectScalar = {
		id?: boolean
		title?: boolean
		message?: boolean
		link?: boolean
		type?: boolean
		isRead?: boolean
		accountId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'title' | 'message' | 'link' | 'type' | 'isRead' | 'accountId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['notification']
	>
	export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Notification$accountArgs<ExtArgs>
	}
	export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Notification$accountArgs<ExtArgs>
	}
	export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | Notification$accountArgs<ExtArgs>
	}

	export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'Notification'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs> | null
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				title: string
				message: string
				link: string
				type: $Enums.NotificationType
				isRead: boolean
				accountId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['notification']
		>
		composites: {}
	}

	type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<
		Prisma.$NotificationPayload,
		S
	>

	type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		NotificationFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: NotificationCountAggregateInputType | true
	}

	export interface NotificationDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification']; meta: { name: 'Notification' } }
		/**
		 * Find zero or one Notification that matches the filter.
		 * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
		 * @example
		 * // Get one Notification
		 * const notification = await prisma.notification.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends NotificationFindUniqueArgs>(
			args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
		 * @example
		 * // Get one Notification
		 * const notification = await prisma.notification.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
			args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Notification that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
		 * @example
		 * // Get one Notification
		 * const notification = await prisma.notification.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends NotificationFindFirstArgs>(
			args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first Notification that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
		 * @example
		 * // Get one Notification
		 * const notification = await prisma.notification.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
			args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more Notifications that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Notifications
		 * const notifications = await prisma.notification.findMany()
		 *
		 * // Get first 10 Notifications
		 * const notifications = await prisma.notification.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends NotificationFindManyArgs>(
			args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a Notification.
		 * @param {NotificationCreateArgs} args - Arguments to create a Notification.
		 * @example
		 * // Create one Notification
		 * const Notification = await prisma.notification.create({
		 *   data: {
		 *     // ... data to create a Notification
		 *   }
		 * })
		 *
		 */
		create<T extends NotificationCreateArgs>(
			args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many Notifications.
		 * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
		 * @example
		 * // Create many Notifications
		 * const notification = await prisma.notification.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends NotificationCreateManyArgs>(
			args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many Notifications and returns the data saved in the database.
		 * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
		 * @example
		 * // Create many Notifications
		 * const notification = await prisma.notification.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many Notifications and only return the `id`
		 * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
			args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a Notification.
		 * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
		 * @example
		 * // Delete one Notification
		 * const Notification = await prisma.notification.delete({
		 *   where: {
		 *     // ... filter to delete one Notification
		 *   }
		 * })
		 *
		 */
		delete<T extends NotificationDeleteArgs>(
			args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one Notification.
		 * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
		 * @example
		 * // Update one Notification
		 * const notification = await prisma.notification.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends NotificationUpdateArgs>(
			args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more Notifications.
		 * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
		 * @example
		 * // Delete a few Notifications
		 * const { count } = await prisma.notification.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends NotificationDeleteManyArgs>(
			args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Notifications.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Notifications
		 * const notification = await prisma.notification.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends NotificationUpdateManyArgs>(
			args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Notifications and returns the data updated in the database.
		 * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
		 * @example
		 * // Update many Notifications
		 * const notification = await prisma.notification.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more Notifications and only return the `id`
		 * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
			args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one Notification.
		 * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
		 * @example
		 * // Update or create a Notification
		 * const notification = await prisma.notification.upsert({
		 *   create: {
		 *     // ... data to create a Notification
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Notification we want to update
		 *   }
		 * })
		 */
		upsert<T extends NotificationUpsertArgs>(
			args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
		): Prisma__NotificationClient<
			$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of Notifications.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
		 * @example
		 * // Count the number of Notifications
		 * const count = await prisma.notification.count({
		 *   where: {
		 *     // ... the filter for the Notifications we want to count
		 *   }
		 * })
		 **/
		count<T extends NotificationCountArgs>(
			args?: Subset<T, NotificationCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], NotificationCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a Notification.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends NotificationAggregateArgs>(
			args: Subset<T, NotificationAggregateArgs>
		): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

		/**
		 * Group by Notification.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {NotificationGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends NotificationGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: NotificationGroupByArgs['orderBy'] }
				: { orderBy?: NotificationGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the Notification model
		 */
		readonly fields: NotificationFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Notification.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__NotificationClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends Notification$accountArgs<ExtArgs> = {}>(
			args?: Subset<T, Notification$accountArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the Notification model
	 */
	interface NotificationFieldRefs {
		readonly id: FieldRef<'Notification', 'String'>
		readonly title: FieldRef<'Notification', 'String'>
		readonly message: FieldRef<'Notification', 'String'>
		readonly link: FieldRef<'Notification', 'String'>
		readonly type: FieldRef<'Notification', 'NotificationType'>
		readonly isRead: FieldRef<'Notification', 'Boolean'>
		readonly accountId: FieldRef<'Notification', 'String'>
		readonly createdAt: FieldRef<'Notification', 'DateTime'>
		readonly updatedAt: FieldRef<'Notification', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * Notification findUnique
	 */
	export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * Filter, which Notification to fetch.
		 */
		where: NotificationWhereUniqueInput
	}

	/**
	 * Notification findUniqueOrThrow
	 */
	export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * Filter, which Notification to fetch.
		 */
		where: NotificationWhereUniqueInput
	}

	/**
	 * Notification findFirst
	 */
	export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * Filter, which Notification to fetch.
		 */
		where?: NotificationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Notifications to fetch.
		 */
		orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Notifications.
		 */
		cursor?: NotificationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Notifications from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Notifications.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Notifications.
		 */
		distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
	}

	/**
	 * Notification findFirstOrThrow
	 */
	export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * Filter, which Notification to fetch.
		 */
		where?: NotificationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Notifications to fetch.
		 */
		orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Notifications.
		 */
		cursor?: NotificationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Notifications from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Notifications.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Notifications.
		 */
		distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
	}

	/**
	 * Notification findMany
	 */
	export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * Filter, which Notifications to fetch.
		 */
		where?: NotificationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Notifications to fetch.
		 */
		orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Notifications.
		 */
		cursor?: NotificationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Notifications from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Notifications.
		 */
		skip?: number
		distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
	}

	/**
	 * Notification create
	 */
	export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * The data needed to create a Notification.
		 */
		data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
	}

	/**
	 * Notification createMany
	 */
	export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many Notifications.
		 */
		data: NotificationCreateManyInput | NotificationCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * Notification createManyAndReturn
	 */
	export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * The data used to create many Notifications.
		 */
		data: NotificationCreateManyInput | NotificationCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Notification update
	 */
	export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * The data needed to update a Notification.
		 */
		data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
		/**
		 * Choose, which Notification to update.
		 */
		where: NotificationWhereUniqueInput
	}

	/**
	 * Notification updateMany
	 */
	export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update Notifications.
		 */
		data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
		/**
		 * Filter which Notifications to update
		 */
		where?: NotificationWhereInput
		/**
		 * Limit how many Notifications to update.
		 */
		limit?: number
	}

	/**
	 * Notification updateManyAndReturn
	 */
	export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * The data used to update Notifications.
		 */
		data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
		/**
		 * Filter which Notifications to update
		 */
		where?: NotificationWhereInput
		/**
		 * Limit how many Notifications to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * Notification upsert
	 */
	export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * The filter to search for the Notification to update in case it exists.
		 */
		where: NotificationWhereUniqueInput
		/**
		 * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
		 */
		create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
		/**
		 * In case the Notification was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
	}

	/**
	 * Notification delete
	 */
	export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
		/**
		 * Filter which Notification to delete.
		 */
		where: NotificationWhereUniqueInput
	}

	/**
	 * Notification deleteMany
	 */
	export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which Notifications to delete
		 */
		where?: NotificationWhereInput
		/**
		 * Limit how many Notifications to delete.
		 */
		limit?: number
	}

	/**
	 * Notification.account
	 */
	export type Notification$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Account
		 */
		select?: AccountSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Account
		 */
		omit?: AccountOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountInclude<ExtArgs> | null
		where?: AccountWhereInput
	}

	/**
	 * Notification without action
	 */
	export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the Notification
		 */
		select?: NotificationSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the Notification
		 */
		omit?: NotificationOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: NotificationInclude<ExtArgs> | null
	}

	/**
	 * Model SupportMessage
	 */

	export type AggregateSupportMessage = {
		_count: SupportMessageCountAggregateOutputType | null
		_min: SupportMessageMinAggregateOutputType | null
		_max: SupportMessageMaxAggregateOutputType | null
	}

	export type SupportMessageMinAggregateOutputType = {
		id: string | null
		message: string | null
		senderId: string | null
		receiverId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type SupportMessageMaxAggregateOutputType = {
		id: string | null
		message: string | null
		senderId: string | null
		receiverId: string | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type SupportMessageCountAggregateOutputType = {
		id: number
		message: number
		senderId: number
		receiverId: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type SupportMessageMinAggregateInputType = {
		id?: true
		message?: true
		senderId?: true
		receiverId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type SupportMessageMaxAggregateInputType = {
		id?: true
		message?: true
		senderId?: true
		receiverId?: true
		createdAt?: true
		updatedAt?: true
	}

	export type SupportMessageCountAggregateInputType = {
		id?: true
		message?: true
		senderId?: true
		receiverId?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type SupportMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which SupportMessage to aggregate.
		 */
		where?: SupportMessageWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of SupportMessages to fetch.
		 */
		orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: SupportMessageWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` SupportMessages from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` SupportMessages.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned SupportMessages
		 **/
		_count?: true | SupportMessageCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: SupportMessageMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: SupportMessageMaxAggregateInputType
	}

	export type GetSupportMessageAggregateType<T extends SupportMessageAggregateArgs> = {
		[P in keyof T & keyof AggregateSupportMessage]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateSupportMessage[P]>
			: GetScalarType<T[P], AggregateSupportMessage[P]>
	}

	export type SupportMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: SupportMessageWhereInput
		orderBy?: SupportMessageOrderByWithAggregationInput | SupportMessageOrderByWithAggregationInput[]
		by: SupportMessageScalarFieldEnum[] | SupportMessageScalarFieldEnum
		having?: SupportMessageScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: SupportMessageCountAggregateInputType | true
		_min?: SupportMessageMinAggregateInputType
		_max?: SupportMessageMaxAggregateInputType
	}

	export type SupportMessageGroupByOutputType = {
		id: string
		message: string
		senderId: string
		receiverId: string
		createdAt: Date
		updatedAt: Date
		_count: SupportMessageCountAggregateOutputType | null
		_min: SupportMessageMinAggregateOutputType | null
		_max: SupportMessageMaxAggregateOutputType | null
	}

	type GetSupportMessageGroupByPayload<T extends SupportMessageGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<SupportMessageGroupByOutputType, T['by']> & {
				[P in keyof T & keyof SupportMessageGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
					: GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
			}
		>
	>

	export type SupportMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			message?: boolean
			senderId?: boolean
			receiverId?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			sender?: boolean | AccountDefaultArgs<ExtArgs>
			receiver?: boolean | AccountDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['supportMessage']
	>

	export type SupportMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				message?: boolean
				senderId?: boolean
				receiverId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				sender?: boolean | AccountDefaultArgs<ExtArgs>
				receiver?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['supportMessage']
		>

	export type SupportMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				message?: boolean
				senderId?: boolean
				receiverId?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				sender?: boolean | AccountDefaultArgs<ExtArgs>
				receiver?: boolean | AccountDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['supportMessage']
		>

	export type SupportMessageSelectScalar = {
		id?: boolean
		message?: boolean
		senderId?: boolean
		receiverId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type SupportMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'message' | 'senderId' | 'receiverId' | 'createdAt' | 'updatedAt',
		ExtArgs['result']['supportMessage']
	>
	export type SupportMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		sender?: boolean | AccountDefaultArgs<ExtArgs>
		receiver?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type SupportMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		sender?: boolean | AccountDefaultArgs<ExtArgs>
		receiver?: boolean | AccountDefaultArgs<ExtArgs>
	}
	export type SupportMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		sender?: boolean | AccountDefaultArgs<ExtArgs>
		receiver?: boolean | AccountDefaultArgs<ExtArgs>
	}

	export type $SupportMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'SupportMessage'
		objects: {
			sender: Prisma.$AccountPayload<ExtArgs>
			receiver: Prisma.$AccountPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				message: string
				senderId: string
				receiverId: string
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['supportMessage']
		>
		composites: {}
	}

	type SupportMessageGetPayload<S extends boolean | null | undefined | SupportMessageDefaultArgs> = $Result.GetResult<
		Prisma.$SupportMessagePayload,
		S
	>

	type SupportMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		SupportMessageFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: SupportMessageCountAggregateInputType | true
	}

	export interface SupportMessageDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportMessage']; meta: { name: 'SupportMessage' } }
		/**
		 * Find zero or one SupportMessage that matches the filter.
		 * @param {SupportMessageFindUniqueArgs} args - Arguments to find a SupportMessage
		 * @example
		 * // Get one SupportMessage
		 * const supportMessage = await prisma.supportMessage.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends SupportMessageFindUniqueArgs>(
			args: SelectSubset<T, SupportMessageFindUniqueArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one SupportMessage that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {SupportMessageFindUniqueOrThrowArgs} args - Arguments to find a SupportMessage
		 * @example
		 * // Get one SupportMessage
		 * const supportMessage = await prisma.supportMessage.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends SupportMessageFindUniqueOrThrowArgs>(
			args: SelectSubset<T, SupportMessageFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first SupportMessage that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageFindFirstArgs} args - Arguments to find a SupportMessage
		 * @example
		 * // Get one SupportMessage
		 * const supportMessage = await prisma.supportMessage.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends SupportMessageFindFirstArgs>(
			args?: SelectSubset<T, SupportMessageFindFirstArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first SupportMessage that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageFindFirstOrThrowArgs} args - Arguments to find a SupportMessage
		 * @example
		 * // Get one SupportMessage
		 * const supportMessage = await prisma.supportMessage.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends SupportMessageFindFirstOrThrowArgs>(
			args?: SelectSubset<T, SupportMessageFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more SupportMessages that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all SupportMessages
		 * const supportMessages = await prisma.supportMessage.findMany()
		 *
		 * // Get first 10 SupportMessages
		 * const supportMessages = await prisma.supportMessage.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const supportMessageWithIdOnly = await prisma.supportMessage.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends SupportMessageFindManyArgs>(
			args?: SelectSubset<T, SupportMessageFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a SupportMessage.
		 * @param {SupportMessageCreateArgs} args - Arguments to create a SupportMessage.
		 * @example
		 * // Create one SupportMessage
		 * const SupportMessage = await prisma.supportMessage.create({
		 *   data: {
		 *     // ... data to create a SupportMessage
		 *   }
		 * })
		 *
		 */
		create<T extends SupportMessageCreateArgs>(
			args: SelectSubset<T, SupportMessageCreateArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many SupportMessages.
		 * @param {SupportMessageCreateManyArgs} args - Arguments to create many SupportMessages.
		 * @example
		 * // Create many SupportMessages
		 * const supportMessage = await prisma.supportMessage.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends SupportMessageCreateManyArgs>(
			args?: SelectSubset<T, SupportMessageCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many SupportMessages and returns the data saved in the database.
		 * @param {SupportMessageCreateManyAndReturnArgs} args - Arguments to create many SupportMessages.
		 * @example
		 * // Create many SupportMessages
		 * const supportMessage = await prisma.supportMessage.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many SupportMessages and only return the `id`
		 * const supportMessageWithIdOnly = await prisma.supportMessage.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends SupportMessageCreateManyAndReturnArgs>(
			args?: SelectSubset<T, SupportMessageCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a SupportMessage.
		 * @param {SupportMessageDeleteArgs} args - Arguments to delete one SupportMessage.
		 * @example
		 * // Delete one SupportMessage
		 * const SupportMessage = await prisma.supportMessage.delete({
		 *   where: {
		 *     // ... filter to delete one SupportMessage
		 *   }
		 * })
		 *
		 */
		delete<T extends SupportMessageDeleteArgs>(
			args: SelectSubset<T, SupportMessageDeleteArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one SupportMessage.
		 * @param {SupportMessageUpdateArgs} args - Arguments to update one SupportMessage.
		 * @example
		 * // Update one SupportMessage
		 * const supportMessage = await prisma.supportMessage.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends SupportMessageUpdateArgs>(
			args: SelectSubset<T, SupportMessageUpdateArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more SupportMessages.
		 * @param {SupportMessageDeleteManyArgs} args - Arguments to filter SupportMessages to delete.
		 * @example
		 * // Delete a few SupportMessages
		 * const { count } = await prisma.supportMessage.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends SupportMessageDeleteManyArgs>(
			args?: SelectSubset<T, SupportMessageDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more SupportMessages.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many SupportMessages
		 * const supportMessage = await prisma.supportMessage.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends SupportMessageUpdateManyArgs>(
			args: SelectSubset<T, SupportMessageUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more SupportMessages and returns the data updated in the database.
		 * @param {SupportMessageUpdateManyAndReturnArgs} args - Arguments to update many SupportMessages.
		 * @example
		 * // Update many SupportMessages
		 * const supportMessage = await prisma.supportMessage.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more SupportMessages and only return the `id`
		 * const supportMessageWithIdOnly = await prisma.supportMessage.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends SupportMessageUpdateManyAndReturnArgs>(
			args: SelectSubset<T, SupportMessageUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one SupportMessage.
		 * @param {SupportMessageUpsertArgs} args - Arguments to update or create a SupportMessage.
		 * @example
		 * // Update or create a SupportMessage
		 * const supportMessage = await prisma.supportMessage.upsert({
		 *   create: {
		 *     // ... data to create a SupportMessage
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the SupportMessage we want to update
		 *   }
		 * })
		 */
		upsert<T extends SupportMessageUpsertArgs>(
			args: SelectSubset<T, SupportMessageUpsertArgs<ExtArgs>>
		): Prisma__SupportMessageClient<
			$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of SupportMessages.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageCountArgs} args - Arguments to filter SupportMessages to count.
		 * @example
		 * // Count the number of SupportMessages
		 * const count = await prisma.supportMessage.count({
		 *   where: {
		 *     // ... the filter for the SupportMessages we want to count
		 *   }
		 * })
		 **/
		count<T extends SupportMessageCountArgs>(
			args?: Subset<T, SupportMessageCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], SupportMessageCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a SupportMessage.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends SupportMessageAggregateArgs>(
			args: Subset<T, SupportMessageAggregateArgs>
		): Prisma.PrismaPromise<GetSupportMessageAggregateType<T>>

		/**
		 * Group by SupportMessage.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SupportMessageGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends SupportMessageGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: SupportMessageGroupByArgs['orderBy'] }
				: { orderBy?: SupportMessageGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, SupportMessageGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetSupportMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the SupportMessage model
		 */
		readonly fields: SupportMessageFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for SupportMessage.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__SupportMessageClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		sender<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		receiver<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the SupportMessage model
	 */
	interface SupportMessageFieldRefs {
		readonly id: FieldRef<'SupportMessage', 'String'>
		readonly message: FieldRef<'SupportMessage', 'String'>
		readonly senderId: FieldRef<'SupportMessage', 'String'>
		readonly receiverId: FieldRef<'SupportMessage', 'String'>
		readonly createdAt: FieldRef<'SupportMessage', 'DateTime'>
		readonly updatedAt: FieldRef<'SupportMessage', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * SupportMessage findUnique
	 */
	export type SupportMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * Filter, which SupportMessage to fetch.
		 */
		where: SupportMessageWhereUniqueInput
	}

	/**
	 * SupportMessage findUniqueOrThrow
	 */
	export type SupportMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * Filter, which SupportMessage to fetch.
		 */
		where: SupportMessageWhereUniqueInput
	}

	/**
	 * SupportMessage findFirst
	 */
	export type SupportMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * Filter, which SupportMessage to fetch.
		 */
		where?: SupportMessageWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of SupportMessages to fetch.
		 */
		orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for SupportMessages.
		 */
		cursor?: SupportMessageWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` SupportMessages from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` SupportMessages.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of SupportMessages.
		 */
		distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
	}

	/**
	 * SupportMessage findFirstOrThrow
	 */
	export type SupportMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * Filter, which SupportMessage to fetch.
		 */
		where?: SupportMessageWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of SupportMessages to fetch.
		 */
		orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for SupportMessages.
		 */
		cursor?: SupportMessageWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` SupportMessages from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` SupportMessages.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of SupportMessages.
		 */
		distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
	}

	/**
	 * SupportMessage findMany
	 */
	export type SupportMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * Filter, which SupportMessages to fetch.
		 */
		where?: SupportMessageWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of SupportMessages to fetch.
		 */
		orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing SupportMessages.
		 */
		cursor?: SupportMessageWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` SupportMessages from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` SupportMessages.
		 */
		skip?: number
		distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
	}

	/**
	 * SupportMessage create
	 */
	export type SupportMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * The data needed to create a SupportMessage.
		 */
		data: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
	}

	/**
	 * SupportMessage createMany
	 */
	export type SupportMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many SupportMessages.
		 */
		data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * SupportMessage createManyAndReturn
	 */
	export type SupportMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * The data used to create many SupportMessages.
		 */
		data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * SupportMessage update
	 */
	export type SupportMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * The data needed to update a SupportMessage.
		 */
		data: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
		/**
		 * Choose, which SupportMessage to update.
		 */
		where: SupportMessageWhereUniqueInput
	}

	/**
	 * SupportMessage updateMany
	 */
	export type SupportMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update SupportMessages.
		 */
		data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
		/**
		 * Filter which SupportMessages to update
		 */
		where?: SupportMessageWhereInput
		/**
		 * Limit how many SupportMessages to update.
		 */
		limit?: number
	}

	/**
	 * SupportMessage updateManyAndReturn
	 */
	export type SupportMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * The data used to update SupportMessages.
		 */
		data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
		/**
		 * Filter which SupportMessages to update
		 */
		where?: SupportMessageWhereInput
		/**
		 * Limit how many SupportMessages to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * SupportMessage upsert
	 */
	export type SupportMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * The filter to search for the SupportMessage to update in case it exists.
		 */
		where: SupportMessageWhereUniqueInput
		/**
		 * In case the SupportMessage found by the `where` argument doesn't exist, create a new SupportMessage with this data.
		 */
		create: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
		/**
		 * In case the SupportMessage was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
	}

	/**
	 * SupportMessage delete
	 */
	export type SupportMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
		/**
		 * Filter which SupportMessage to delete.
		 */
		where: SupportMessageWhereUniqueInput
	}

	/**
	 * SupportMessage deleteMany
	 */
	export type SupportMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which SupportMessages to delete
		 */
		where?: SupportMessageWhereInput
		/**
		 * Limit how many SupportMessages to delete.
		 */
		limit?: number
	}

	/**
	 * SupportMessage without action
	 */
	export type SupportMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the SupportMessage
		 */
		select?: SupportMessageSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the SupportMessage
		 */
		omit?: SupportMessageOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: SupportMessageInclude<ExtArgs> | null
	}

	/**
	 * Model LoyaltyLevel
	 */

	export type AggregateLoyaltyLevel = {
		_count: LoyaltyLevelCountAggregateOutputType | null
		_avg: LoyaltyLevelAvgAggregateOutputType | null
		_sum: LoyaltyLevelSumAggregateOutputType | null
		_min: LoyaltyLevelMinAggregateOutputType | null
		_max: LoyaltyLevelMaxAggregateOutputType | null
	}

	export type LoyaltyLevelAvgAggregateOutputType = {
		minPoints: number | null
		bonusPercentage: number | null
	}

	export type LoyaltyLevelSumAggregateOutputType = {
		minPoints: number | null
		bonusPercentage: number | null
	}

	export type LoyaltyLevelMinAggregateOutputType = {
		id: string | null
		name: string | null
		minPoints: number | null
		bonusPercentage: number | null
		hasPriorityDelivery: boolean | null
		hasPersonalManager: boolean | null
		hasExclusiveAccess: boolean | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type LoyaltyLevelMaxAggregateOutputType = {
		id: string | null
		name: string | null
		minPoints: number | null
		bonusPercentage: number | null
		hasPriorityDelivery: boolean | null
		hasPersonalManager: boolean | null
		hasExclusiveAccess: boolean | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type LoyaltyLevelCountAggregateOutputType = {
		id: number
		name: number
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery: number
		hasPersonalManager: number
		hasExclusiveAccess: number
		additionalBenefits: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type LoyaltyLevelAvgAggregateInputType = {
		minPoints?: true
		bonusPercentage?: true
	}

	export type LoyaltyLevelSumAggregateInputType = {
		minPoints?: true
		bonusPercentage?: true
	}

	export type LoyaltyLevelMinAggregateInputType = {
		id?: true
		name?: true
		minPoints?: true
		bonusPercentage?: true
		hasPriorityDelivery?: true
		hasPersonalManager?: true
		hasExclusiveAccess?: true
		createdAt?: true
		updatedAt?: true
	}

	export type LoyaltyLevelMaxAggregateInputType = {
		id?: true
		name?: true
		minPoints?: true
		bonusPercentage?: true
		hasPriorityDelivery?: true
		hasPersonalManager?: true
		hasExclusiveAccess?: true
		createdAt?: true
		updatedAt?: true
	}

	export type LoyaltyLevelCountAggregateInputType = {
		id?: true
		name?: true
		minPoints?: true
		bonusPercentage?: true
		hasPriorityDelivery?: true
		hasPersonalManager?: true
		hasExclusiveAccess?: true
		additionalBenefits?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type LoyaltyLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which LoyaltyLevel to aggregate.
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyLevels to fetch.
		 */
		orderBy?: LoyaltyLevelOrderByWithRelationInput | LoyaltyLevelOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: LoyaltyLevelWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyLevels from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyLevels.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned LoyaltyLevels
		 **/
		_count?: true | LoyaltyLevelCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: LoyaltyLevelAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: LoyaltyLevelSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: LoyaltyLevelMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: LoyaltyLevelMaxAggregateInputType
	}

	export type GetLoyaltyLevelAggregateType<T extends LoyaltyLevelAggregateArgs> = {
		[P in keyof T & keyof AggregateLoyaltyLevel]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateLoyaltyLevel[P]>
			: GetScalarType<T[P], AggregateLoyaltyLevel[P]>
	}

	export type LoyaltyLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: LoyaltyLevelWhereInput
		orderBy?: LoyaltyLevelOrderByWithAggregationInput | LoyaltyLevelOrderByWithAggregationInput[]
		by: LoyaltyLevelScalarFieldEnum[] | LoyaltyLevelScalarFieldEnum
		having?: LoyaltyLevelScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: LoyaltyLevelCountAggregateInputType | true
		_avg?: LoyaltyLevelAvgAggregateInputType
		_sum?: LoyaltyLevelSumAggregateInputType
		_min?: LoyaltyLevelMinAggregateInputType
		_max?: LoyaltyLevelMaxAggregateInputType
	}

	export type LoyaltyLevelGroupByOutputType = {
		id: string
		name: string
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery: boolean
		hasPersonalManager: boolean
		hasExclusiveAccess: boolean
		additionalBenefits: JsonValue | null
		createdAt: Date
		updatedAt: Date
		_count: LoyaltyLevelCountAggregateOutputType | null
		_avg: LoyaltyLevelAvgAggregateOutputType | null
		_sum: LoyaltyLevelSumAggregateOutputType | null
		_min: LoyaltyLevelMinAggregateOutputType | null
		_max: LoyaltyLevelMaxAggregateOutputType | null
	}

	type GetLoyaltyLevelGroupByPayload<T extends LoyaltyLevelGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<LoyaltyLevelGroupByOutputType, T['by']> & {
				[P in keyof T & keyof LoyaltyLevelGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], LoyaltyLevelGroupByOutputType[P]>
					: GetScalarType<T[P], LoyaltyLevelGroupByOutputType[P]>
			}
		>
	>

	export type LoyaltyLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			name?: boolean
			minPoints?: boolean
			bonusPercentage?: boolean
			hasPriorityDelivery?: boolean
			hasPersonalManager?: boolean
			hasExclusiveAccess?: boolean
			additionalBenefits?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			accountLoyalties?: boolean | LoyaltyLevel$accountLoyaltiesArgs<ExtArgs>
			_count?: boolean | LoyaltyLevelCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['loyaltyLevel']
	>

	export type LoyaltyLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				name?: boolean
				minPoints?: boolean
				bonusPercentage?: boolean
				hasPriorityDelivery?: boolean
				hasPersonalManager?: boolean
				hasExclusiveAccess?: boolean
				additionalBenefits?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['loyaltyLevel']
		>

	export type LoyaltyLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				name?: boolean
				minPoints?: boolean
				bonusPercentage?: boolean
				hasPriorityDelivery?: boolean
				hasPersonalManager?: boolean
				hasExclusiveAccess?: boolean
				additionalBenefits?: boolean
				createdAt?: boolean
				updatedAt?: boolean
			},
			ExtArgs['result']['loyaltyLevel']
		>

	export type LoyaltyLevelSelectScalar = {
		id?: boolean
		name?: boolean
		minPoints?: boolean
		bonusPercentage?: boolean
		hasPriorityDelivery?: boolean
		hasPersonalManager?: boolean
		hasExclusiveAccess?: boolean
		additionalBenefits?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type LoyaltyLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		| 'id'
		| 'name'
		| 'minPoints'
		| 'bonusPercentage'
		| 'hasPriorityDelivery'
		| 'hasPersonalManager'
		| 'hasExclusiveAccess'
		| 'additionalBenefits'
		| 'createdAt'
		| 'updatedAt',
		ExtArgs['result']['loyaltyLevel']
	>
	export type LoyaltyLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountLoyalties?: boolean | LoyaltyLevel$accountLoyaltiesArgs<ExtArgs>
		_count?: boolean | LoyaltyLevelCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type LoyaltyLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
	export type LoyaltyLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

	export type $LoyaltyLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'LoyaltyLevel'
		objects: {
			accountLoyalties: Prisma.$AccountLoyaltyPayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				name: string
				minPoints: number
				bonusPercentage: number
				hasPriorityDelivery: boolean
				hasPersonalManager: boolean
				hasExclusiveAccess: boolean
				additionalBenefits: Prisma.JsonValue | null
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['loyaltyLevel']
		>
		composites: {}
	}

	type LoyaltyLevelGetPayload<S extends boolean | null | undefined | LoyaltyLevelDefaultArgs> = $Result.GetResult<
		Prisma.$LoyaltyLevelPayload,
		S
	>

	type LoyaltyLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		LoyaltyLevelFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: LoyaltyLevelCountAggregateInputType | true
	}

	export interface LoyaltyLevelDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyLevel']; meta: { name: 'LoyaltyLevel' } }
		/**
		 * Find zero or one LoyaltyLevel that matches the filter.
		 * @param {LoyaltyLevelFindUniqueArgs} args - Arguments to find a LoyaltyLevel
		 * @example
		 * // Get one LoyaltyLevel
		 * const loyaltyLevel = await prisma.loyaltyLevel.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends LoyaltyLevelFindUniqueArgs>(
			args: SelectSubset<T, LoyaltyLevelFindUniqueArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one LoyaltyLevel that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {LoyaltyLevelFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyLevel
		 * @example
		 * // Get one LoyaltyLevel
		 * const loyaltyLevel = await prisma.loyaltyLevel.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends LoyaltyLevelFindUniqueOrThrowArgs>(
			args: SelectSubset<T, LoyaltyLevelFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first LoyaltyLevel that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelFindFirstArgs} args - Arguments to find a LoyaltyLevel
		 * @example
		 * // Get one LoyaltyLevel
		 * const loyaltyLevel = await prisma.loyaltyLevel.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends LoyaltyLevelFindFirstArgs>(
			args?: SelectSubset<T, LoyaltyLevelFindFirstArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first LoyaltyLevel that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelFindFirstOrThrowArgs} args - Arguments to find a LoyaltyLevel
		 * @example
		 * // Get one LoyaltyLevel
		 * const loyaltyLevel = await prisma.loyaltyLevel.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends LoyaltyLevelFindFirstOrThrowArgs>(
			args?: SelectSubset<T, LoyaltyLevelFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more LoyaltyLevels that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all LoyaltyLevels
		 * const loyaltyLevels = await prisma.loyaltyLevel.findMany()
		 *
		 * // Get first 10 LoyaltyLevels
		 * const loyaltyLevels = await prisma.loyaltyLevel.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const loyaltyLevelWithIdOnly = await prisma.loyaltyLevel.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends LoyaltyLevelFindManyArgs>(
			args?: SelectSubset<T, LoyaltyLevelFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a LoyaltyLevel.
		 * @param {LoyaltyLevelCreateArgs} args - Arguments to create a LoyaltyLevel.
		 * @example
		 * // Create one LoyaltyLevel
		 * const LoyaltyLevel = await prisma.loyaltyLevel.create({
		 *   data: {
		 *     // ... data to create a LoyaltyLevel
		 *   }
		 * })
		 *
		 */
		create<T extends LoyaltyLevelCreateArgs>(
			args: SelectSubset<T, LoyaltyLevelCreateArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many LoyaltyLevels.
		 * @param {LoyaltyLevelCreateManyArgs} args - Arguments to create many LoyaltyLevels.
		 * @example
		 * // Create many LoyaltyLevels
		 * const loyaltyLevel = await prisma.loyaltyLevel.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends LoyaltyLevelCreateManyArgs>(
			args?: SelectSubset<T, LoyaltyLevelCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many LoyaltyLevels and returns the data saved in the database.
		 * @param {LoyaltyLevelCreateManyAndReturnArgs} args - Arguments to create many LoyaltyLevels.
		 * @example
		 * // Create many LoyaltyLevels
		 * const loyaltyLevel = await prisma.loyaltyLevel.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many LoyaltyLevels and only return the `id`
		 * const loyaltyLevelWithIdOnly = await prisma.loyaltyLevel.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends LoyaltyLevelCreateManyAndReturnArgs>(
			args?: SelectSubset<T, LoyaltyLevelCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>>

		/**
		 * Delete a LoyaltyLevel.
		 * @param {LoyaltyLevelDeleteArgs} args - Arguments to delete one LoyaltyLevel.
		 * @example
		 * // Delete one LoyaltyLevel
		 * const LoyaltyLevel = await prisma.loyaltyLevel.delete({
		 *   where: {
		 *     // ... filter to delete one LoyaltyLevel
		 *   }
		 * })
		 *
		 */
		delete<T extends LoyaltyLevelDeleteArgs>(
			args: SelectSubset<T, LoyaltyLevelDeleteArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one LoyaltyLevel.
		 * @param {LoyaltyLevelUpdateArgs} args - Arguments to update one LoyaltyLevel.
		 * @example
		 * // Update one LoyaltyLevel
		 * const loyaltyLevel = await prisma.loyaltyLevel.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends LoyaltyLevelUpdateArgs>(
			args: SelectSubset<T, LoyaltyLevelUpdateArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more LoyaltyLevels.
		 * @param {LoyaltyLevelDeleteManyArgs} args - Arguments to filter LoyaltyLevels to delete.
		 * @example
		 * // Delete a few LoyaltyLevels
		 * const { count } = await prisma.loyaltyLevel.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends LoyaltyLevelDeleteManyArgs>(
			args?: SelectSubset<T, LoyaltyLevelDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more LoyaltyLevels.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many LoyaltyLevels
		 * const loyaltyLevel = await prisma.loyaltyLevel.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends LoyaltyLevelUpdateManyArgs>(
			args: SelectSubset<T, LoyaltyLevelUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more LoyaltyLevels and returns the data updated in the database.
		 * @param {LoyaltyLevelUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyLevels.
		 * @example
		 * // Update many LoyaltyLevels
		 * const loyaltyLevel = await prisma.loyaltyLevel.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more LoyaltyLevels and only return the `id`
		 * const loyaltyLevelWithIdOnly = await prisma.loyaltyLevel.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends LoyaltyLevelUpdateManyAndReturnArgs>(
			args: SelectSubset<T, LoyaltyLevelUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>>

		/**
		 * Create or update one LoyaltyLevel.
		 * @param {LoyaltyLevelUpsertArgs} args - Arguments to update or create a LoyaltyLevel.
		 * @example
		 * // Update or create a LoyaltyLevel
		 * const loyaltyLevel = await prisma.loyaltyLevel.upsert({
		 *   create: {
		 *     // ... data to create a LoyaltyLevel
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the LoyaltyLevel we want to update
		 *   }
		 * })
		 */
		upsert<T extends LoyaltyLevelUpsertArgs>(
			args: SelectSubset<T, LoyaltyLevelUpsertArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of LoyaltyLevels.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelCountArgs} args - Arguments to filter LoyaltyLevels to count.
		 * @example
		 * // Count the number of LoyaltyLevels
		 * const count = await prisma.loyaltyLevel.count({
		 *   where: {
		 *     // ... the filter for the LoyaltyLevels we want to count
		 *   }
		 * })
		 **/
		count<T extends LoyaltyLevelCountArgs>(
			args?: Subset<T, LoyaltyLevelCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], LoyaltyLevelCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a LoyaltyLevel.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends LoyaltyLevelAggregateArgs>(
			args: Subset<T, LoyaltyLevelAggregateArgs>
		): Prisma.PrismaPromise<GetLoyaltyLevelAggregateType<T>>

		/**
		 * Group by LoyaltyLevel.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyLevelGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends LoyaltyLevelGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: LoyaltyLevelGroupByArgs['orderBy'] }
				: { orderBy?: LoyaltyLevelGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, LoyaltyLevelGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetLoyaltyLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the LoyaltyLevel model
		 */
		readonly fields: LoyaltyLevelFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for LoyaltyLevel.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__LoyaltyLevelClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		accountLoyalties<T extends LoyaltyLevel$accountLoyaltiesArgs<ExtArgs> = {}>(
			args?: Subset<T, LoyaltyLevel$accountLoyaltiesArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the LoyaltyLevel model
	 */
	interface LoyaltyLevelFieldRefs {
		readonly id: FieldRef<'LoyaltyLevel', 'String'>
		readonly name: FieldRef<'LoyaltyLevel', 'String'>
		readonly minPoints: FieldRef<'LoyaltyLevel', 'Int'>
		readonly bonusPercentage: FieldRef<'LoyaltyLevel', 'Float'>
		readonly hasPriorityDelivery: FieldRef<'LoyaltyLevel', 'Boolean'>
		readonly hasPersonalManager: FieldRef<'LoyaltyLevel', 'Boolean'>
		readonly hasExclusiveAccess: FieldRef<'LoyaltyLevel', 'Boolean'>
		readonly additionalBenefits: FieldRef<'LoyaltyLevel', 'Json'>
		readonly createdAt: FieldRef<'LoyaltyLevel', 'DateTime'>
		readonly updatedAt: FieldRef<'LoyaltyLevel', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * LoyaltyLevel findUnique
	 */
	export type LoyaltyLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyLevel to fetch.
		 */
		where: LoyaltyLevelWhereUniqueInput
	}

	/**
	 * LoyaltyLevel findUniqueOrThrow
	 */
	export type LoyaltyLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyLevel to fetch.
		 */
		where: LoyaltyLevelWhereUniqueInput
	}

	/**
	 * LoyaltyLevel findFirst
	 */
	export type LoyaltyLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyLevel to fetch.
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyLevels to fetch.
		 */
		orderBy?: LoyaltyLevelOrderByWithRelationInput | LoyaltyLevelOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for LoyaltyLevels.
		 */
		cursor?: LoyaltyLevelWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyLevels from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyLevels.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of LoyaltyLevels.
		 */
		distinct?: LoyaltyLevelScalarFieldEnum | LoyaltyLevelScalarFieldEnum[]
	}

	/**
	 * LoyaltyLevel findFirstOrThrow
	 */
	export type LoyaltyLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyLevel to fetch.
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyLevels to fetch.
		 */
		orderBy?: LoyaltyLevelOrderByWithRelationInput | LoyaltyLevelOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for LoyaltyLevels.
		 */
		cursor?: LoyaltyLevelWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyLevels from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyLevels.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of LoyaltyLevels.
		 */
		distinct?: LoyaltyLevelScalarFieldEnum | LoyaltyLevelScalarFieldEnum[]
	}

	/**
	 * LoyaltyLevel findMany
	 */
	export type LoyaltyLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyLevels to fetch.
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyLevels to fetch.
		 */
		orderBy?: LoyaltyLevelOrderByWithRelationInput | LoyaltyLevelOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing LoyaltyLevels.
		 */
		cursor?: LoyaltyLevelWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyLevels from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyLevels.
		 */
		skip?: number
		distinct?: LoyaltyLevelScalarFieldEnum | LoyaltyLevelScalarFieldEnum[]
	}

	/**
	 * LoyaltyLevel create
	 */
	export type LoyaltyLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * The data needed to create a LoyaltyLevel.
		 */
		data: XOR<LoyaltyLevelCreateInput, LoyaltyLevelUncheckedCreateInput>
	}

	/**
	 * LoyaltyLevel createMany
	 */
	export type LoyaltyLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many LoyaltyLevels.
		 */
		data: LoyaltyLevelCreateManyInput | LoyaltyLevelCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * LoyaltyLevel createManyAndReturn
	 */
	export type LoyaltyLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * The data used to create many LoyaltyLevels.
		 */
		data: LoyaltyLevelCreateManyInput | LoyaltyLevelCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * LoyaltyLevel update
	 */
	export type LoyaltyLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * The data needed to update a LoyaltyLevel.
		 */
		data: XOR<LoyaltyLevelUpdateInput, LoyaltyLevelUncheckedUpdateInput>
		/**
		 * Choose, which LoyaltyLevel to update.
		 */
		where: LoyaltyLevelWhereUniqueInput
	}

	/**
	 * LoyaltyLevel updateMany
	 */
	export type LoyaltyLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update LoyaltyLevels.
		 */
		data: XOR<LoyaltyLevelUpdateManyMutationInput, LoyaltyLevelUncheckedUpdateManyInput>
		/**
		 * Filter which LoyaltyLevels to update
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * Limit how many LoyaltyLevels to update.
		 */
		limit?: number
	}

	/**
	 * LoyaltyLevel updateManyAndReturn
	 */
	export type LoyaltyLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * The data used to update LoyaltyLevels.
		 */
		data: XOR<LoyaltyLevelUpdateManyMutationInput, LoyaltyLevelUncheckedUpdateManyInput>
		/**
		 * Filter which LoyaltyLevels to update
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * Limit how many LoyaltyLevels to update.
		 */
		limit?: number
	}

	/**
	 * LoyaltyLevel upsert
	 */
	export type LoyaltyLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * The filter to search for the LoyaltyLevel to update in case it exists.
		 */
		where: LoyaltyLevelWhereUniqueInput
		/**
		 * In case the LoyaltyLevel found by the `where` argument doesn't exist, create a new LoyaltyLevel with this data.
		 */
		create: XOR<LoyaltyLevelCreateInput, LoyaltyLevelUncheckedCreateInput>
		/**
		 * In case the LoyaltyLevel was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<LoyaltyLevelUpdateInput, LoyaltyLevelUncheckedUpdateInput>
	}

	/**
	 * LoyaltyLevel delete
	 */
	export type LoyaltyLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
		/**
		 * Filter which LoyaltyLevel to delete.
		 */
		where: LoyaltyLevelWhereUniqueInput
	}

	/**
	 * LoyaltyLevel deleteMany
	 */
	export type LoyaltyLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which LoyaltyLevels to delete
		 */
		where?: LoyaltyLevelWhereInput
		/**
		 * Limit how many LoyaltyLevels to delete.
		 */
		limit?: number
	}

	/**
	 * LoyaltyLevel.accountLoyalties
	 */
	export type LoyaltyLevel$accountLoyaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		where?: AccountLoyaltyWhereInput
		orderBy?: AccountLoyaltyOrderByWithRelationInput | AccountLoyaltyOrderByWithRelationInput[]
		cursor?: AccountLoyaltyWhereUniqueInput
		take?: number
		skip?: number
		distinct?: AccountLoyaltyScalarFieldEnum | AccountLoyaltyScalarFieldEnum[]
	}

	/**
	 * LoyaltyLevel without action
	 */
	export type LoyaltyLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyLevel
		 */
		select?: LoyaltyLevelSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyLevel
		 */
		omit?: LoyaltyLevelOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyLevelInclude<ExtArgs> | null
	}

	/**
	 * Model AccountLoyalty
	 */

	export type AggregateAccountLoyalty = {
		_count: AccountLoyaltyCountAggregateOutputType | null
		_avg: AccountLoyaltyAvgAggregateOutputType | null
		_sum: AccountLoyaltySumAggregateOutputType | null
		_min: AccountLoyaltyMinAggregateOutputType | null
		_max: AccountLoyaltyMaxAggregateOutputType | null
	}

	export type AccountLoyaltyAvgAggregateOutputType = {
		points: number | null
		totalSpent: number | null
		ordersCount: number | null
	}

	export type AccountLoyaltySumAggregateOutputType = {
		points: number | null
		totalSpent: number | null
		ordersCount: number | null
	}

	export type AccountLoyaltyMinAggregateOutputType = {
		id: string | null
		accountId: string | null
		loyaltyLevelId: string | null
		points: number | null
		totalSpent: number | null
		ordersCount: number | null
		lastActivity: Date | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type AccountLoyaltyMaxAggregateOutputType = {
		id: string | null
		accountId: string | null
		loyaltyLevelId: string | null
		points: number | null
		totalSpent: number | null
		ordersCount: number | null
		lastActivity: Date | null
		createdAt: Date | null
		updatedAt: Date | null
	}

	export type AccountLoyaltyCountAggregateOutputType = {
		id: number
		accountId: number
		loyaltyLevelId: number
		points: number
		totalSpent: number
		ordersCount: number
		lastActivity: number
		achievements: number
		createdAt: number
		updatedAt: number
		_all: number
	}

	export type AccountLoyaltyAvgAggregateInputType = {
		points?: true
		totalSpent?: true
		ordersCount?: true
	}

	export type AccountLoyaltySumAggregateInputType = {
		points?: true
		totalSpent?: true
		ordersCount?: true
	}

	export type AccountLoyaltyMinAggregateInputType = {
		id?: true
		accountId?: true
		loyaltyLevelId?: true
		points?: true
		totalSpent?: true
		ordersCount?: true
		lastActivity?: true
		createdAt?: true
		updatedAt?: true
	}

	export type AccountLoyaltyMaxAggregateInputType = {
		id?: true
		accountId?: true
		loyaltyLevelId?: true
		points?: true
		totalSpent?: true
		ordersCount?: true
		lastActivity?: true
		createdAt?: true
		updatedAt?: true
	}

	export type AccountLoyaltyCountAggregateInputType = {
		id?: true
		accountId?: true
		loyaltyLevelId?: true
		points?: true
		totalSpent?: true
		ordersCount?: true
		lastActivity?: true
		achievements?: true
		createdAt?: true
		updatedAt?: true
		_all?: true
	}

	export type AccountLoyaltyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which AccountLoyalty to aggregate.
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountLoyalties to fetch.
		 */
		orderBy?: AccountLoyaltyOrderByWithRelationInput | AccountLoyaltyOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: AccountLoyaltyWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountLoyalties from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountLoyalties.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned AccountLoyalties
		 **/
		_count?: true | AccountLoyaltyCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: AccountLoyaltyAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: AccountLoyaltySumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: AccountLoyaltyMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: AccountLoyaltyMaxAggregateInputType
	}

	export type GetAccountLoyaltyAggregateType<T extends AccountLoyaltyAggregateArgs> = {
		[P in keyof T & keyof AggregateAccountLoyalty]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateAccountLoyalty[P]>
			: GetScalarType<T[P], AggregateAccountLoyalty[P]>
	}

	export type AccountLoyaltyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: AccountLoyaltyWhereInput
		orderBy?: AccountLoyaltyOrderByWithAggregationInput | AccountLoyaltyOrderByWithAggregationInput[]
		by: AccountLoyaltyScalarFieldEnum[] | AccountLoyaltyScalarFieldEnum
		having?: AccountLoyaltyScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: AccountLoyaltyCountAggregateInputType | true
		_avg?: AccountLoyaltyAvgAggregateInputType
		_sum?: AccountLoyaltySumAggregateInputType
		_min?: AccountLoyaltyMinAggregateInputType
		_max?: AccountLoyaltyMaxAggregateInputType
	}

	export type AccountLoyaltyGroupByOutputType = {
		id: string
		accountId: string
		loyaltyLevelId: string
		points: number
		totalSpent: number
		ordersCount: number
		lastActivity: Date
		achievements: JsonValue | null
		createdAt: Date
		updatedAt: Date
		_count: AccountLoyaltyCountAggregateOutputType | null
		_avg: AccountLoyaltyAvgAggregateOutputType | null
		_sum: AccountLoyaltySumAggregateOutputType | null
		_min: AccountLoyaltyMinAggregateOutputType | null
		_max: AccountLoyaltyMaxAggregateOutputType | null
	}

	type GetAccountLoyaltyGroupByPayload<T extends AccountLoyaltyGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<AccountLoyaltyGroupByOutputType, T['by']> & {
				[P in keyof T & keyof AccountLoyaltyGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], AccountLoyaltyGroupByOutputType[P]>
					: GetScalarType<T[P], AccountLoyaltyGroupByOutputType[P]>
			}
		>
	>

	export type AccountLoyaltySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
		{
			id?: boolean
			accountId?: boolean
			loyaltyLevelId?: boolean
			points?: boolean
			totalSpent?: boolean
			ordersCount?: boolean
			lastActivity?: boolean
			achievements?: boolean
			createdAt?: boolean
			updatedAt?: boolean
			account?: boolean | AccountDefaultArgs<ExtArgs>
			loyaltyLevel?: boolean | LoyaltyLevelDefaultArgs<ExtArgs>
			transactions?: boolean | AccountLoyalty$transactionsArgs<ExtArgs>
			_count?: boolean | AccountLoyaltyCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['accountLoyalty']
	>

	export type AccountLoyaltySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				loyaltyLevelId?: boolean
				points?: boolean
				totalSpent?: boolean
				ordersCount?: boolean
				lastActivity?: boolean
				achievements?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
				loyaltyLevel?: boolean | LoyaltyLevelDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['accountLoyalty']
		>

	export type AccountLoyaltySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountId?: boolean
				loyaltyLevelId?: boolean
				points?: boolean
				totalSpent?: boolean
				ordersCount?: boolean
				lastActivity?: boolean
				achievements?: boolean
				createdAt?: boolean
				updatedAt?: boolean
				account?: boolean | AccountDefaultArgs<ExtArgs>
				loyaltyLevel?: boolean | LoyaltyLevelDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['accountLoyalty']
		>

	export type AccountLoyaltySelectScalar = {
		id?: boolean
		accountId?: boolean
		loyaltyLevelId?: boolean
		points?: boolean
		totalSpent?: boolean
		ordersCount?: boolean
		lastActivity?: boolean
		achievements?: boolean
		createdAt?: boolean
		updatedAt?: boolean
	}

	export type AccountLoyaltyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		| 'id'
		| 'accountId'
		| 'loyaltyLevelId'
		| 'points'
		| 'totalSpent'
		| 'ordersCount'
		| 'lastActivity'
		| 'achievements'
		| 'createdAt'
		| 'updatedAt',
		ExtArgs['result']['accountLoyalty']
	>
	export type AccountLoyaltyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		loyaltyLevel?: boolean | LoyaltyLevelDefaultArgs<ExtArgs>
		transactions?: boolean | AccountLoyalty$transactionsArgs<ExtArgs>
		_count?: boolean | AccountLoyaltyCountOutputTypeDefaultArgs<ExtArgs>
	}
	export type AccountLoyaltyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		loyaltyLevel?: boolean | LoyaltyLevelDefaultArgs<ExtArgs>
	}
	export type AccountLoyaltyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		account?: boolean | AccountDefaultArgs<ExtArgs>
		loyaltyLevel?: boolean | LoyaltyLevelDefaultArgs<ExtArgs>
	}

	export type $AccountLoyaltyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'AccountLoyalty'
		objects: {
			account: Prisma.$AccountPayload<ExtArgs>
			loyaltyLevel: Prisma.$LoyaltyLevelPayload<ExtArgs>
			transactions: Prisma.$LoyaltyTransactionPayload<ExtArgs>[]
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				accountId: string
				loyaltyLevelId: string
				points: number
				totalSpent: number
				ordersCount: number
				lastActivity: Date
				achievements: Prisma.JsonValue | null
				createdAt: Date
				updatedAt: Date
			},
			ExtArgs['result']['accountLoyalty']
		>
		composites: {}
	}

	type AccountLoyaltyGetPayload<S extends boolean | null | undefined | AccountLoyaltyDefaultArgs> = $Result.GetResult<
		Prisma.$AccountLoyaltyPayload,
		S
	>

	type AccountLoyaltyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		AccountLoyaltyFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: AccountLoyaltyCountAggregateInputType | true
	}

	export interface AccountLoyaltyDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountLoyalty']; meta: { name: 'AccountLoyalty' } }
		/**
		 * Find zero or one AccountLoyalty that matches the filter.
		 * @param {AccountLoyaltyFindUniqueArgs} args - Arguments to find a AccountLoyalty
		 * @example
		 * // Get one AccountLoyalty
		 * const accountLoyalty = await prisma.accountLoyalty.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends AccountLoyaltyFindUniqueArgs>(
			args: SelectSubset<T, AccountLoyaltyFindUniqueArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one AccountLoyalty that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {AccountLoyaltyFindUniqueOrThrowArgs} args - Arguments to find a AccountLoyalty
		 * @example
		 * // Get one AccountLoyalty
		 * const accountLoyalty = await prisma.accountLoyalty.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends AccountLoyaltyFindUniqueOrThrowArgs>(
			args: SelectSubset<T, AccountLoyaltyFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first AccountLoyalty that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyFindFirstArgs} args - Arguments to find a AccountLoyalty
		 * @example
		 * // Get one AccountLoyalty
		 * const accountLoyalty = await prisma.accountLoyalty.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends AccountLoyaltyFindFirstArgs>(
			args?: SelectSubset<T, AccountLoyaltyFindFirstArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first AccountLoyalty that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyFindFirstOrThrowArgs} args - Arguments to find a AccountLoyalty
		 * @example
		 * // Get one AccountLoyalty
		 * const accountLoyalty = await prisma.accountLoyalty.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends AccountLoyaltyFindFirstOrThrowArgs>(
			args?: SelectSubset<T, AccountLoyaltyFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more AccountLoyalties that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all AccountLoyalties
		 * const accountLoyalties = await prisma.accountLoyalty.findMany()
		 *
		 * // Get first 10 AccountLoyalties
		 * const accountLoyalties = await prisma.accountLoyalty.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const accountLoyaltyWithIdOnly = await prisma.accountLoyalty.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends AccountLoyaltyFindManyArgs>(
			args?: SelectSubset<T, AccountLoyaltyFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a AccountLoyalty.
		 * @param {AccountLoyaltyCreateArgs} args - Arguments to create a AccountLoyalty.
		 * @example
		 * // Create one AccountLoyalty
		 * const AccountLoyalty = await prisma.accountLoyalty.create({
		 *   data: {
		 *     // ... data to create a AccountLoyalty
		 *   }
		 * })
		 *
		 */
		create<T extends AccountLoyaltyCreateArgs>(
			args: SelectSubset<T, AccountLoyaltyCreateArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many AccountLoyalties.
		 * @param {AccountLoyaltyCreateManyArgs} args - Arguments to create many AccountLoyalties.
		 * @example
		 * // Create many AccountLoyalties
		 * const accountLoyalty = await prisma.accountLoyalty.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends AccountLoyaltyCreateManyArgs>(
			args?: SelectSubset<T, AccountLoyaltyCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many AccountLoyalties and returns the data saved in the database.
		 * @param {AccountLoyaltyCreateManyAndReturnArgs} args - Arguments to create many AccountLoyalties.
		 * @example
		 * // Create many AccountLoyalties
		 * const accountLoyalty = await prisma.accountLoyalty.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many AccountLoyalties and only return the `id`
		 * const accountLoyaltyWithIdOnly = await prisma.accountLoyalty.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends AccountLoyaltyCreateManyAndReturnArgs>(
			args?: SelectSubset<T, AccountLoyaltyCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a AccountLoyalty.
		 * @param {AccountLoyaltyDeleteArgs} args - Arguments to delete one AccountLoyalty.
		 * @example
		 * // Delete one AccountLoyalty
		 * const AccountLoyalty = await prisma.accountLoyalty.delete({
		 *   where: {
		 *     // ... filter to delete one AccountLoyalty
		 *   }
		 * })
		 *
		 */
		delete<T extends AccountLoyaltyDeleteArgs>(
			args: SelectSubset<T, AccountLoyaltyDeleteArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one AccountLoyalty.
		 * @param {AccountLoyaltyUpdateArgs} args - Arguments to update one AccountLoyalty.
		 * @example
		 * // Update one AccountLoyalty
		 * const accountLoyalty = await prisma.accountLoyalty.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends AccountLoyaltyUpdateArgs>(
			args: SelectSubset<T, AccountLoyaltyUpdateArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more AccountLoyalties.
		 * @param {AccountLoyaltyDeleteManyArgs} args - Arguments to filter AccountLoyalties to delete.
		 * @example
		 * // Delete a few AccountLoyalties
		 * const { count } = await prisma.accountLoyalty.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends AccountLoyaltyDeleteManyArgs>(
			args?: SelectSubset<T, AccountLoyaltyDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more AccountLoyalties.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many AccountLoyalties
		 * const accountLoyalty = await prisma.accountLoyalty.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends AccountLoyaltyUpdateManyArgs>(
			args: SelectSubset<T, AccountLoyaltyUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more AccountLoyalties and returns the data updated in the database.
		 * @param {AccountLoyaltyUpdateManyAndReturnArgs} args - Arguments to update many AccountLoyalties.
		 * @example
		 * // Update many AccountLoyalties
		 * const accountLoyalty = await prisma.accountLoyalty.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more AccountLoyalties and only return the `id`
		 * const accountLoyaltyWithIdOnly = await prisma.accountLoyalty.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends AccountLoyaltyUpdateManyAndReturnArgs>(
			args: SelectSubset<T, AccountLoyaltyUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one AccountLoyalty.
		 * @param {AccountLoyaltyUpsertArgs} args - Arguments to update or create a AccountLoyalty.
		 * @example
		 * // Update or create a AccountLoyalty
		 * const accountLoyalty = await prisma.accountLoyalty.upsert({
		 *   create: {
		 *     // ... data to create a AccountLoyalty
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the AccountLoyalty we want to update
		 *   }
		 * })
		 */
		upsert<T extends AccountLoyaltyUpsertArgs>(
			args: SelectSubset<T, AccountLoyaltyUpsertArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of AccountLoyalties.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyCountArgs} args - Arguments to filter AccountLoyalties to count.
		 * @example
		 * // Count the number of AccountLoyalties
		 * const count = await prisma.accountLoyalty.count({
		 *   where: {
		 *     // ... the filter for the AccountLoyalties we want to count
		 *   }
		 * })
		 **/
		count<T extends AccountLoyaltyCountArgs>(
			args?: Subset<T, AccountLoyaltyCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], AccountLoyaltyCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a AccountLoyalty.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends AccountLoyaltyAggregateArgs>(
			args: Subset<T, AccountLoyaltyAggregateArgs>
		): Prisma.PrismaPromise<GetAccountLoyaltyAggregateType<T>>

		/**
		 * Group by AccountLoyalty.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountLoyaltyGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends AccountLoyaltyGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: AccountLoyaltyGroupByArgs['orderBy'] }
				: { orderBy?: AccountLoyaltyGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, AccountLoyaltyGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetAccountLoyaltyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the AccountLoyalty model
		 */
		readonly fields: AccountLoyaltyFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for AccountLoyalty.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__AccountLoyaltyClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		account<T extends AccountDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountDefaultArgs<ExtArgs>>
		): Prisma__AccountClient<
			$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		loyaltyLevel<T extends LoyaltyLevelDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, LoyaltyLevelDefaultArgs<ExtArgs>>
		): Prisma__LoyaltyLevelClient<
			$Result.GetResult<Prisma.$LoyaltyLevelPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		transactions<T extends AccountLoyalty$transactionsArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountLoyalty$transactionsArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the AccountLoyalty model
	 */
	interface AccountLoyaltyFieldRefs {
		readonly id: FieldRef<'AccountLoyalty', 'String'>
		readonly accountId: FieldRef<'AccountLoyalty', 'String'>
		readonly loyaltyLevelId: FieldRef<'AccountLoyalty', 'String'>
		readonly points: FieldRef<'AccountLoyalty', 'Int'>
		readonly totalSpent: FieldRef<'AccountLoyalty', 'Float'>
		readonly ordersCount: FieldRef<'AccountLoyalty', 'Int'>
		readonly lastActivity: FieldRef<'AccountLoyalty', 'DateTime'>
		readonly achievements: FieldRef<'AccountLoyalty', 'Json'>
		readonly createdAt: FieldRef<'AccountLoyalty', 'DateTime'>
		readonly updatedAt: FieldRef<'AccountLoyalty', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * AccountLoyalty findUnique
	 */
	export type AccountLoyaltyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * Filter, which AccountLoyalty to fetch.
		 */
		where: AccountLoyaltyWhereUniqueInput
	}

	/**
	 * AccountLoyalty findUniqueOrThrow
	 */
	export type AccountLoyaltyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * Filter, which AccountLoyalty to fetch.
		 */
		where: AccountLoyaltyWhereUniqueInput
	}

	/**
	 * AccountLoyalty findFirst
	 */
	export type AccountLoyaltyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * Filter, which AccountLoyalty to fetch.
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountLoyalties to fetch.
		 */
		orderBy?: AccountLoyaltyOrderByWithRelationInput | AccountLoyaltyOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for AccountLoyalties.
		 */
		cursor?: AccountLoyaltyWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountLoyalties from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountLoyalties.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of AccountLoyalties.
		 */
		distinct?: AccountLoyaltyScalarFieldEnum | AccountLoyaltyScalarFieldEnum[]
	}

	/**
	 * AccountLoyalty findFirstOrThrow
	 */
	export type AccountLoyaltyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * Filter, which AccountLoyalty to fetch.
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountLoyalties to fetch.
		 */
		orderBy?: AccountLoyaltyOrderByWithRelationInput | AccountLoyaltyOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for AccountLoyalties.
		 */
		cursor?: AccountLoyaltyWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountLoyalties from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountLoyalties.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of AccountLoyalties.
		 */
		distinct?: AccountLoyaltyScalarFieldEnum | AccountLoyaltyScalarFieldEnum[]
	}

	/**
	 * AccountLoyalty findMany
	 */
	export type AccountLoyaltyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * Filter, which AccountLoyalties to fetch.
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of AccountLoyalties to fetch.
		 */
		orderBy?: AccountLoyaltyOrderByWithRelationInput | AccountLoyaltyOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing AccountLoyalties.
		 */
		cursor?: AccountLoyaltyWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` AccountLoyalties from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` AccountLoyalties.
		 */
		skip?: number
		distinct?: AccountLoyaltyScalarFieldEnum | AccountLoyaltyScalarFieldEnum[]
	}

	/**
	 * AccountLoyalty create
	 */
	export type AccountLoyaltyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * The data needed to create a AccountLoyalty.
		 */
		data: XOR<AccountLoyaltyCreateInput, AccountLoyaltyUncheckedCreateInput>
	}

	/**
	 * AccountLoyalty createMany
	 */
	export type AccountLoyaltyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many AccountLoyalties.
		 */
		data: AccountLoyaltyCreateManyInput | AccountLoyaltyCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * AccountLoyalty createManyAndReturn
	 */
	export type AccountLoyaltyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * The data used to create many AccountLoyalties.
		 */
		data: AccountLoyaltyCreateManyInput | AccountLoyaltyCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * AccountLoyalty update
	 */
	export type AccountLoyaltyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * The data needed to update a AccountLoyalty.
		 */
		data: XOR<AccountLoyaltyUpdateInput, AccountLoyaltyUncheckedUpdateInput>
		/**
		 * Choose, which AccountLoyalty to update.
		 */
		where: AccountLoyaltyWhereUniqueInput
	}

	/**
	 * AccountLoyalty updateMany
	 */
	export type AccountLoyaltyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update AccountLoyalties.
		 */
		data: XOR<AccountLoyaltyUpdateManyMutationInput, AccountLoyaltyUncheckedUpdateManyInput>
		/**
		 * Filter which AccountLoyalties to update
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * Limit how many AccountLoyalties to update.
		 */
		limit?: number
	}

	/**
	 * AccountLoyalty updateManyAndReturn
	 */
	export type AccountLoyaltyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * The data used to update AccountLoyalties.
		 */
		data: XOR<AccountLoyaltyUpdateManyMutationInput, AccountLoyaltyUncheckedUpdateManyInput>
		/**
		 * Filter which AccountLoyalties to update
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * Limit how many AccountLoyalties to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * AccountLoyalty upsert
	 */
	export type AccountLoyaltyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * The filter to search for the AccountLoyalty to update in case it exists.
		 */
		where: AccountLoyaltyWhereUniqueInput
		/**
		 * In case the AccountLoyalty found by the `where` argument doesn't exist, create a new AccountLoyalty with this data.
		 */
		create: XOR<AccountLoyaltyCreateInput, AccountLoyaltyUncheckedCreateInput>
		/**
		 * In case the AccountLoyalty was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<AccountLoyaltyUpdateInput, AccountLoyaltyUncheckedUpdateInput>
	}

	/**
	 * AccountLoyalty delete
	 */
	export type AccountLoyaltyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
		/**
		 * Filter which AccountLoyalty to delete.
		 */
		where: AccountLoyaltyWhereUniqueInput
	}

	/**
	 * AccountLoyalty deleteMany
	 */
	export type AccountLoyaltyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which AccountLoyalties to delete
		 */
		where?: AccountLoyaltyWhereInput
		/**
		 * Limit how many AccountLoyalties to delete.
		 */
		limit?: number
	}

	/**
	 * AccountLoyalty.transactions
	 */
	export type AccountLoyalty$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		where?: LoyaltyTransactionWhereInput
		orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
		cursor?: LoyaltyTransactionWhereUniqueInput
		take?: number
		skip?: number
		distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
	}

	/**
	 * AccountLoyalty without action
	 */
	export type AccountLoyaltyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the AccountLoyalty
		 */
		select?: AccountLoyaltySelect<ExtArgs> | null
		/**
		 * Omit specific fields from the AccountLoyalty
		 */
		omit?: AccountLoyaltyOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: AccountLoyaltyInclude<ExtArgs> | null
	}

	/**
	 * Model LoyaltyTransaction
	 */

	export type AggregateLoyaltyTransaction = {
		_count: LoyaltyTransactionCountAggregateOutputType | null
		_avg: LoyaltyTransactionAvgAggregateOutputType | null
		_sum: LoyaltyTransactionSumAggregateOutputType | null
		_min: LoyaltyTransactionMinAggregateOutputType | null
		_max: LoyaltyTransactionMaxAggregateOutputType | null
	}

	export type LoyaltyTransactionAvgAggregateOutputType = {
		points: number | null
	}

	export type LoyaltyTransactionSumAggregateOutputType = {
		points: number | null
	}

	export type LoyaltyTransactionMinAggregateOutputType = {
		id: string | null
		accountLoyaltyId: string | null
		points: number | null
		type: $Enums.LoyaltyTransactionType | null
		orderId: string | null
		description: string | null
		createdAt: Date | null
	}

	export type LoyaltyTransactionMaxAggregateOutputType = {
		id: string | null
		accountLoyaltyId: string | null
		points: number | null
		type: $Enums.LoyaltyTransactionType | null
		orderId: string | null
		description: string | null
		createdAt: Date | null
	}

	export type LoyaltyTransactionCountAggregateOutputType = {
		id: number
		accountLoyaltyId: number
		points: number
		type: number
		orderId: number
		description: number
		metadata: number
		createdAt: number
		_all: number
	}

	export type LoyaltyTransactionAvgAggregateInputType = {
		points?: true
	}

	export type LoyaltyTransactionSumAggregateInputType = {
		points?: true
	}

	export type LoyaltyTransactionMinAggregateInputType = {
		id?: true
		accountLoyaltyId?: true
		points?: true
		type?: true
		orderId?: true
		description?: true
		createdAt?: true
	}

	export type LoyaltyTransactionMaxAggregateInputType = {
		id?: true
		accountLoyaltyId?: true
		points?: true
		type?: true
		orderId?: true
		description?: true
		createdAt?: true
	}

	export type LoyaltyTransactionCountAggregateInputType = {
		id?: true
		accountLoyaltyId?: true
		points?: true
		type?: true
		orderId?: true
		description?: true
		metadata?: true
		createdAt?: true
		_all?: true
	}

	export type LoyaltyTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which LoyaltyTransaction to aggregate.
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyTransactions to fetch.
		 */
		orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 */
		cursor?: LoyaltyTransactionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyTransactions from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyTransactions.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned LoyaltyTransactions
		 **/
		_count?: true | LoyaltyTransactionCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: LoyaltyTransactionAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: LoyaltyTransactionSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: LoyaltyTransactionMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: LoyaltyTransactionMaxAggregateInputType
	}

	export type GetLoyaltyTransactionAggregateType<T extends LoyaltyTransactionAggregateArgs> = {
		[P in keyof T & keyof AggregateLoyaltyTransaction]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
			: GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
	}

	export type LoyaltyTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		where?: LoyaltyTransactionWhereInput
		orderBy?: LoyaltyTransactionOrderByWithAggregationInput | LoyaltyTransactionOrderByWithAggregationInput[]
		by: LoyaltyTransactionScalarFieldEnum[] | LoyaltyTransactionScalarFieldEnum
		having?: LoyaltyTransactionScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: LoyaltyTransactionCountAggregateInputType | true
		_avg?: LoyaltyTransactionAvgAggregateInputType
		_sum?: LoyaltyTransactionSumAggregateInputType
		_min?: LoyaltyTransactionMinAggregateInputType
		_max?: LoyaltyTransactionMaxAggregateInputType
	}

	export type LoyaltyTransactionGroupByOutputType = {
		id: string
		accountLoyaltyId: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId: string | null
		description: string | null
		metadata: JsonValue | null
		createdAt: Date
		_count: LoyaltyTransactionCountAggregateOutputType | null
		_avg: LoyaltyTransactionAvgAggregateOutputType | null
		_sum: LoyaltyTransactionSumAggregateOutputType | null
		_min: LoyaltyTransactionMinAggregateOutputType | null
		_max: LoyaltyTransactionMaxAggregateOutputType | null
	}

	type GetLoyaltyTransactionGroupByPayload<T extends LoyaltyTransactionGroupByArgs> = Prisma.PrismaPromise<
		Array<
			PickEnumerable<LoyaltyTransactionGroupByOutputType, T['by']> & {
				[P in keyof T & keyof LoyaltyTransactionGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
					: GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
			}
		>
	>

	export type LoyaltyTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountLoyaltyId?: boolean
				points?: boolean
				type?: boolean
				orderId?: boolean
				description?: boolean
				metadata?: boolean
				createdAt?: boolean
				accountLoyalty?: boolean | AccountLoyaltyDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['loyaltyTransaction']
		>

	export type LoyaltyTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountLoyaltyId?: boolean
				points?: boolean
				type?: boolean
				orderId?: boolean
				description?: boolean
				metadata?: boolean
				createdAt?: boolean
				accountLoyalty?: boolean | AccountLoyaltyDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['loyaltyTransaction']
		>

	export type LoyaltyTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
		$Extensions.GetSelect<
			{
				id?: boolean
				accountLoyaltyId?: boolean
				points?: boolean
				type?: boolean
				orderId?: boolean
				description?: boolean
				metadata?: boolean
				createdAt?: boolean
				accountLoyalty?: boolean | AccountLoyaltyDefaultArgs<ExtArgs>
			},
			ExtArgs['result']['loyaltyTransaction']
		>

	export type LoyaltyTransactionSelectScalar = {
		id?: boolean
		accountLoyaltyId?: boolean
		points?: boolean
		type?: boolean
		orderId?: boolean
		description?: boolean
		metadata?: boolean
		createdAt?: boolean
	}

	export type LoyaltyTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
		'id' | 'accountLoyaltyId' | 'points' | 'type' | 'orderId' | 'description' | 'metadata' | 'createdAt',
		ExtArgs['result']['loyaltyTransaction']
	>
	export type LoyaltyTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountLoyalty?: boolean | AccountLoyaltyDefaultArgs<ExtArgs>
	}
	export type LoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountLoyalty?: boolean | AccountLoyaltyDefaultArgs<ExtArgs>
	}
	export type LoyaltyTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		accountLoyalty?: boolean | AccountLoyaltyDefaultArgs<ExtArgs>
	}

	export type $LoyaltyTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		name: 'LoyaltyTransaction'
		objects: {
			accountLoyalty: Prisma.$AccountLoyaltyPayload<ExtArgs>
		}
		scalars: $Extensions.GetPayloadResult<
			{
				id: string
				accountLoyaltyId: string
				points: number
				type: $Enums.LoyaltyTransactionType
				orderId: string | null
				description: string | null
				metadata: Prisma.JsonValue | null
				createdAt: Date
			},
			ExtArgs['result']['loyaltyTransaction']
		>
		composites: {}
	}

	type LoyaltyTransactionGetPayload<S extends boolean | null | undefined | LoyaltyTransactionDefaultArgs> = $Result.GetResult<
		Prisma.$LoyaltyTransactionPayload,
		S
	>

	type LoyaltyTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
		LoyaltyTransactionFindManyArgs,
		'select' | 'include' | 'distinct' | 'omit'
	> & {
		select?: LoyaltyTransactionCountAggregateInputType | true
	}

	export interface LoyaltyTransactionDelegate<
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> {
		[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyTransaction']; meta: { name: 'LoyaltyTransaction' } }
		/**
		 * Find zero or one LoyaltyTransaction that matches the filter.
		 * @param {LoyaltyTransactionFindUniqueArgs} args - Arguments to find a LoyaltyTransaction
		 * @example
		 * // Get one LoyaltyTransaction
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUnique<T extends LoyaltyTransactionFindUniqueArgs>(
			args: SelectSubset<T, LoyaltyTransactionFindUniqueArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find one LoyaltyTransaction that matches the filter or throw an error with `error.code='P2025'`
		 * if no matches were found.
		 * @param {LoyaltyTransactionFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyTransaction
		 * @example
		 * // Get one LoyaltyTransaction
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.findUniqueOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findUniqueOrThrow<T extends LoyaltyTransactionFindUniqueOrThrowArgs>(
			args: SelectSubset<T, LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first LoyaltyTransaction that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionFindFirstArgs} args - Arguments to find a LoyaltyTransaction
		 * @example
		 * // Get one LoyaltyTransaction
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirst<T extends LoyaltyTransactionFindFirstArgs>(
			args?: SelectSubset<T, LoyaltyTransactionFindFirstArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
			null,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find the first LoyaltyTransaction that matches the filter or
		 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionFindFirstOrThrowArgs} args - Arguments to find a LoyaltyTransaction
		 * @example
		 * // Get one LoyaltyTransaction
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirstOrThrow({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 */
		findFirstOrThrow<T extends LoyaltyTransactionFindFirstOrThrowArgs>(
			args?: SelectSubset<T, LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Find zero or more LoyaltyTransactions that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all LoyaltyTransactions
		 * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
		 *
		 * // Get first 10 LoyaltyTransactions
		 * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.findMany({ select: { id: true } })
		 *
		 */
		findMany<T extends LoyaltyTransactionFindManyArgs>(
			args?: SelectSubset<T, LoyaltyTransactionFindManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

		/**
		 * Create a LoyaltyTransaction.
		 * @param {LoyaltyTransactionCreateArgs} args - Arguments to create a LoyaltyTransaction.
		 * @example
		 * // Create one LoyaltyTransaction
		 * const LoyaltyTransaction = await prisma.loyaltyTransaction.create({
		 *   data: {
		 *     // ... data to create a LoyaltyTransaction
		 *   }
		 * })
		 *
		 */
		create<T extends LoyaltyTransactionCreateArgs>(
			args: SelectSubset<T, LoyaltyTransactionCreateArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Create many LoyaltyTransactions.
		 * @param {LoyaltyTransactionCreateManyArgs} args - Arguments to create many LoyaltyTransactions.
		 * @example
		 * // Create many LoyaltyTransactions
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.createMany({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 */
		createMany<T extends LoyaltyTransactionCreateManyArgs>(
			args?: SelectSubset<T, LoyaltyTransactionCreateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Create many LoyaltyTransactions and returns the data saved in the database.
		 * @param {LoyaltyTransactionCreateManyAndReturnArgs} args - Arguments to create many LoyaltyTransactions.
		 * @example
		 * // Create many LoyaltyTransactions
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.createManyAndReturn({
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Create many LoyaltyTransactions and only return the `id`
		 * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.createManyAndReturn({
		 *   select: { id: true },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		createManyAndReturn<T extends LoyaltyTransactionCreateManyAndReturnArgs>(
			args?: SelectSubset<T, LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Delete a LoyaltyTransaction.
		 * @param {LoyaltyTransactionDeleteArgs} args - Arguments to delete one LoyaltyTransaction.
		 * @example
		 * // Delete one LoyaltyTransaction
		 * const LoyaltyTransaction = await prisma.loyaltyTransaction.delete({
		 *   where: {
		 *     // ... filter to delete one LoyaltyTransaction
		 *   }
		 * })
		 *
		 */
		delete<T extends LoyaltyTransactionDeleteArgs>(
			args: SelectSubset<T, LoyaltyTransactionDeleteArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Update one LoyaltyTransaction.
		 * @param {LoyaltyTransactionUpdateArgs} args - Arguments to update one LoyaltyTransaction.
		 * @example
		 * // Update one LoyaltyTransaction
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		update<T extends LoyaltyTransactionUpdateArgs>(
			args: SelectSubset<T, LoyaltyTransactionUpdateArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Delete zero or more LoyaltyTransactions.
		 * @param {LoyaltyTransactionDeleteManyArgs} args - Arguments to filter LoyaltyTransactions to delete.
		 * @example
		 * // Delete a few LoyaltyTransactions
		 * const { count } = await prisma.loyaltyTransaction.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 */
		deleteMany<T extends LoyaltyTransactionDeleteManyArgs>(
			args?: SelectSubset<T, LoyaltyTransactionDeleteManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more LoyaltyTransactions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many LoyaltyTransactions
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 */
		updateMany<T extends LoyaltyTransactionUpdateManyArgs>(
			args: SelectSubset<T, LoyaltyTransactionUpdateManyArgs<ExtArgs>>
		): Prisma.PrismaPromise<BatchPayload>

		/**
		 * Update zero or more LoyaltyTransactions and returns the data updated in the database.
		 * @param {LoyaltyTransactionUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyTransactions.
		 * @example
		 * // Update many LoyaltyTransactions
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.updateManyAndReturn({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 *
		 * // Update zero or more LoyaltyTransactions and only return the `id`
		 * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.updateManyAndReturn({
		 *   select: { id: true },
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: [
		 *     // ... provide data here
		 *   ]
		 * })
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 *
		 */
		updateManyAndReturn<T extends LoyaltyTransactionUpdateManyAndReturnArgs>(
			args: SelectSubset<T, LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs>>
		): Prisma.PrismaPromise<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
		>

		/**
		 * Create or update one LoyaltyTransaction.
		 * @param {LoyaltyTransactionUpsertArgs} args - Arguments to update or create a LoyaltyTransaction.
		 * @example
		 * // Update or create a LoyaltyTransaction
		 * const loyaltyTransaction = await prisma.loyaltyTransaction.upsert({
		 *   create: {
		 *     // ... data to create a LoyaltyTransaction
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the LoyaltyTransaction we want to update
		 *   }
		 * })
		 */
		upsert<T extends LoyaltyTransactionUpsertArgs>(
			args: SelectSubset<T, LoyaltyTransactionUpsertArgs<ExtArgs>>
		): Prisma__LoyaltyTransactionClient<
			$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
			never,
			ExtArgs,
			GlobalOmitOptions
		>

		/**
		 * Count the number of LoyaltyTransactions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionCountArgs} args - Arguments to filter LoyaltyTransactions to count.
		 * @example
		 * // Count the number of LoyaltyTransactions
		 * const count = await prisma.loyaltyTransaction.count({
		 *   where: {
		 *     // ... the filter for the LoyaltyTransactions we want to count
		 *   }
		 * })
		 **/
		count<T extends LoyaltyTransactionCountArgs>(
			args?: Subset<T, LoyaltyTransactionCountArgs>
		): Prisma.PrismaPromise<
			T extends $Utils.Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], LoyaltyTransactionCountAggregateOutputType>
				: number
		>

		/**
		 * Allows you to perform aggregations operations on a LoyaltyTransaction.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends LoyaltyTransactionAggregateArgs>(
			args: Subset<T, LoyaltyTransactionAggregateArgs>
		): Prisma.PrismaPromise<GetLoyaltyTransactionAggregateType<T>>

		/**
		 * Group by LoyaltyTransaction.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {LoyaltyTransactionGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends LoyaltyTransactionGroupByArgs,
			HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: LoyaltyTransactionGroupByArgs['orderBy'] }
				: { orderBy?: LoyaltyTransactionGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends MaybeTupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
							[P in HavingFields]: P extends ByFields
								? never
								: P extends string
									? `Error: Field "${P}" used in "having" needs to be provided in "by".`
									: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
						}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
											[P in OrderFields]: P extends ByFields
												? never
												: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
										}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
		>(
			args: SubsetIntersection<T, LoyaltyTransactionGroupByArgs, OrderByArg> & InputErrors
		): {} extends InputErrors ? GetLoyaltyTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
		/**
		 * Fields of the LoyaltyTransaction model
		 */
		readonly fields: LoyaltyTransactionFieldRefs
	}

	/**
	 * The delegate class that acts as a "Promise-like" for LoyaltyTransaction.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export interface Prisma__LoyaltyTransactionClient<
		T,
		Null = never,
		ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
		GlobalOmitOptions = {}
	> extends Prisma.PrismaPromise<T> {
		readonly [Symbol.toStringTag]: 'PrismaPromise'
		accountLoyalty<T extends AccountLoyaltyDefaultArgs<ExtArgs> = {}>(
			args?: Subset<T, AccountLoyaltyDefaultArgs<ExtArgs>>
		): Prisma__AccountLoyaltyClient<
			$Result.GetResult<Prisma.$AccountLoyaltyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
			Null,
			ExtArgs,
			GlobalOmitOptions
		>
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(
			onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
			onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
		): $Utils.JsPromise<TResult1 | TResult2>
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(
			onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
		): $Utils.JsPromise<T | TResult>
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
	}

	/**
	 * Fields of the LoyaltyTransaction model
	 */
	interface LoyaltyTransactionFieldRefs {
		readonly id: FieldRef<'LoyaltyTransaction', 'String'>
		readonly accountLoyaltyId: FieldRef<'LoyaltyTransaction', 'String'>
		readonly points: FieldRef<'LoyaltyTransaction', 'Int'>
		readonly type: FieldRef<'LoyaltyTransaction', 'LoyaltyTransactionType'>
		readonly orderId: FieldRef<'LoyaltyTransaction', 'String'>
		readonly description: FieldRef<'LoyaltyTransaction', 'String'>
		readonly metadata: FieldRef<'LoyaltyTransaction', 'Json'>
		readonly createdAt: FieldRef<'LoyaltyTransaction', 'DateTime'>
	}

	// Custom InputTypes
	/**
	 * LoyaltyTransaction findUnique
	 */
	export type LoyaltyTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyTransaction to fetch.
		 */
		where: LoyaltyTransactionWhereUniqueInput
	}

	/**
	 * LoyaltyTransaction findUniqueOrThrow
	 */
	export type LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyTransaction to fetch.
		 */
		where: LoyaltyTransactionWhereUniqueInput
	}

	/**
	 * LoyaltyTransaction findFirst
	 */
	export type LoyaltyTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyTransaction to fetch.
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyTransactions to fetch.
		 */
		orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for LoyaltyTransactions.
		 */
		cursor?: LoyaltyTransactionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyTransactions from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyTransactions.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of LoyaltyTransactions.
		 */
		distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
	}

	/**
	 * LoyaltyTransaction findFirstOrThrow
	 */
	export type LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyTransaction to fetch.
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyTransactions to fetch.
		 */
		orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for LoyaltyTransactions.
		 */
		cursor?: LoyaltyTransactionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyTransactions from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyTransactions.
		 */
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of LoyaltyTransactions.
		 */
		distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
	}

	/**
	 * LoyaltyTransaction findMany
	 */
	export type LoyaltyTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * Filter, which LoyaltyTransactions to fetch.
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of LoyaltyTransactions to fetch.
		 */
		orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing LoyaltyTransactions.
		 */
		cursor?: LoyaltyTransactionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` LoyaltyTransactions from the position of the cursor.
		 */
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` LoyaltyTransactions.
		 */
		skip?: number
		distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
	}

	/**
	 * LoyaltyTransaction create
	 */
	export type LoyaltyTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * The data needed to create a LoyaltyTransaction.
		 */
		data: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
	}

	/**
	 * LoyaltyTransaction createMany
	 */
	export type LoyaltyTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to create many LoyaltyTransactions.
		 */
		data: LoyaltyTransactionCreateManyInput | LoyaltyTransactionCreateManyInput[]
		skipDuplicates?: boolean
	}

	/**
	 * LoyaltyTransaction createManyAndReturn
	 */
	export type LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelectCreateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * The data used to create many LoyaltyTransactions.
		 */
		data: LoyaltyTransactionCreateManyInput | LoyaltyTransactionCreateManyInput[]
		skipDuplicates?: boolean
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs> | null
	}

	/**
	 * LoyaltyTransaction update
	 */
	export type LoyaltyTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * The data needed to update a LoyaltyTransaction.
		 */
		data: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
		/**
		 * Choose, which LoyaltyTransaction to update.
		 */
		where: LoyaltyTransactionWhereUniqueInput
	}

	/**
	 * LoyaltyTransaction updateMany
	 */
	export type LoyaltyTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * The data used to update LoyaltyTransactions.
		 */
		data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
		/**
		 * Filter which LoyaltyTransactions to update
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * Limit how many LoyaltyTransactions to update.
		 */
		limit?: number
	}

	/**
	 * LoyaltyTransaction updateManyAndReturn
	 */
	export type LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelectUpdateManyAndReturn<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * The data used to update LoyaltyTransactions.
		 */
		data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
		/**
		 * Filter which LoyaltyTransactions to update
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * Limit how many LoyaltyTransactions to update.
		 */
		limit?: number
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
	}

	/**
	 * LoyaltyTransaction upsert
	 */
	export type LoyaltyTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * The filter to search for the LoyaltyTransaction to update in case it exists.
		 */
		where: LoyaltyTransactionWhereUniqueInput
		/**
		 * In case the LoyaltyTransaction found by the `where` argument doesn't exist, create a new LoyaltyTransaction with this data.
		 */
		create: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
		/**
		 * In case the LoyaltyTransaction was found with the provided `where` argument, update it with this data.
		 */
		update: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
	}

	/**
	 * LoyaltyTransaction delete
	 */
	export type LoyaltyTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
		/**
		 * Filter which LoyaltyTransaction to delete.
		 */
		where: LoyaltyTransactionWhereUniqueInput
	}

	/**
	 * LoyaltyTransaction deleteMany
	 */
	export type LoyaltyTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Filter which LoyaltyTransactions to delete
		 */
		where?: LoyaltyTransactionWhereInput
		/**
		 * Limit how many LoyaltyTransactions to delete.
		 */
		limit?: number
	}

	/**
	 * LoyaltyTransaction without action
	 */
	export type LoyaltyTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
		/**
		 * Select specific fields to fetch from the LoyaltyTransaction
		 */
		select?: LoyaltyTransactionSelect<ExtArgs> | null
		/**
		 * Omit specific fields from the LoyaltyTransaction
		 */
		omit?: LoyaltyTransactionOmit<ExtArgs> | null
		/**
		 * Choose, which related nodes to fetch as well
		 */
		include?: LoyaltyTransactionInclude<ExtArgs> | null
	}

	/**
	 * Enums
	 */

	export const TransactionIsolationLevel: {
		ReadUncommitted: 'ReadUncommitted'
		ReadCommitted: 'ReadCommitted'
		RepeatableRead: 'RepeatableRead'
		Serializable: 'Serializable'
	}

	export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]

	export const RoleScalarFieldEnum: {
		id: 'id'
		name: 'name'
	}

	export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]

	export const AccountRoleScalarFieldEnum: {
		id: 'id'
		accountId: 'accountId'
		roleId: 'roleId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type AccountRoleScalarFieldEnum = (typeof AccountRoleScalarFieldEnum)[keyof typeof AccountRoleScalarFieldEnum]

	export const CartScalarFieldEnum: {
		id: 'id'
		accountId: 'accountId'
		productId: 'productId'
		quantity: 'quantity'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]

	export const CategoryScalarFieldEnum: {
		id: 'id'
		title: 'title'
		imageUrl: 'imageUrl'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]

	export const IngredientScalarFieldEnum: {
		id: 'id'
		title: 'title'
		imageUrl: 'imageUrl'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]

	export const ProductIngredientsScalarFieldEnum: {
		id: 'id'
		productId: 'productId'
		ingredientId: 'ingredientId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type ProductIngredientsScalarFieldEnum =
		(typeof ProductIngredientsScalarFieldEnum)[keyof typeof ProductIngredientsScalarFieldEnum]

	export const ProductScalarFieldEnum: {
		id: 'id'
		title: 'title'
		description: 'description'
		weight: 'weight'
		imageUrl: 'imageUrl'
		price: 'price'
		onSale: 'onSale'
		categoryId: 'categoryId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]

	export const FavoriteScalarFieldEnum: {
		id: 'id'
		productId: 'productId'
		accountId: 'accountId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]

	export const AccountSettingsScalarFieldEnum: {
		id: 'id'
		accountId: 'accountId'
		telegramId: 'telegramId'
		isVerifiedEmail: 'isVerifiedEmail'
		isTwoFactorEmailEnabled: 'isTwoFactorEmailEnabled'
		isTwoFactorTotpEnabled: 'isTwoFactorTotpEnabled'
		totpSecret: 'totpSecret'
		siteNotification: 'siteNotification'
		telegramNotification: 'telegramNotification'
	}

	export type AccountSettingsScalarFieldEnum =
		(typeof AccountSettingsScalarFieldEnum)[keyof typeof AccountSettingsScalarFieldEnum]

	export const AccountScalarFieldEnum: {
		id: 'id'
		email: 'email'
		password: 'password'
		userName: 'userName'
		picture: 'picture'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]

	export const DeliveryAddressScalarFieldEnum: {
		id: 'id'
		accountId: 'accountId'
		city: 'city'
		street: 'street'
		house: 'house'
		flat: 'flat'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type DeliveryAddressScalarFieldEnum =
		(typeof DeliveryAddressScalarFieldEnum)[keyof typeof DeliveryAddressScalarFieldEnum]

	export const OrderScalarFieldEnum: {
		id: 'id'
		status: 'status'
		firstName: 'firstName'
		lastName: 'lastName'
		phone: 'phone'
		email: 'email'
		deliveryAddressId: 'deliveryAddressId'
		deliveryAddress: 'deliveryAddress'
		deliveryType: 'deliveryType'
		paymentMethod: 'paymentMethod'
		paymentStatus: 'paymentStatus'
		comment: 'comment'
		total: 'total'
		accountId: 'accountId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]

	export const OrderItemScalarFieldEnum: {
		id: 'id'
		orderId: 'orderId'
		quantity: 'quantity'
		price: 'price'
		productTitle: 'productTitle'
		productDescription: 'productDescription'
		productImageUrl: 'productImageUrl'
		productId: 'productId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]

	export const ProductCommentScalarFieldEnum: {
		id: 'id'
		comment: 'comment'
		rating: 'rating'
		parentId: 'parentId'
		productId: 'productId'
		accountId: 'accountId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type ProductCommentScalarFieldEnum = (typeof ProductCommentScalarFieldEnum)[keyof typeof ProductCommentScalarFieldEnum]

	export const PostScalarFieldEnum: {
		id: 'id'
		title: 'title'
		description: 'description'
		imageUrl: 'imageUrl'
		published: 'published'
		authorId: 'authorId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]

	export const PostCommentScalarFieldEnum: {
		id: 'id'
		comment: 'comment'
		authorId: 'authorId'
		postId: 'postId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type PostCommentScalarFieldEnum = (typeof PostCommentScalarFieldEnum)[keyof typeof PostCommentScalarFieldEnum]

	export const PostLikeScalarFieldEnum: {
		id: 'id'
		postId: 'postId'
		accountId: 'accountId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type PostLikeScalarFieldEnum = (typeof PostLikeScalarFieldEnum)[keyof typeof PostLikeScalarFieldEnum]

	export const TokenScalarFieldEnum: {
		id: 'id'
		token: 'token'
		type: 'type'
		accountId: 'accountId'
		expiresIn: 'expiresIn'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]

	export const NotificationScalarFieldEnum: {
		id: 'id'
		title: 'title'
		message: 'message'
		link: 'link'
		type: 'type'
		isRead: 'isRead'
		accountId: 'accountId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]

	export const SupportMessageScalarFieldEnum: {
		id: 'id'
		message: 'message'
		senderId: 'senderId'
		receiverId: 'receiverId'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type SupportMessageScalarFieldEnum = (typeof SupportMessageScalarFieldEnum)[keyof typeof SupportMessageScalarFieldEnum]

	export const LoyaltyLevelScalarFieldEnum: {
		id: 'id'
		name: 'name'
		minPoints: 'minPoints'
		bonusPercentage: 'bonusPercentage'
		hasPriorityDelivery: 'hasPriorityDelivery'
		hasPersonalManager: 'hasPersonalManager'
		hasExclusiveAccess: 'hasExclusiveAccess'
		additionalBenefits: 'additionalBenefits'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type LoyaltyLevelScalarFieldEnum = (typeof LoyaltyLevelScalarFieldEnum)[keyof typeof LoyaltyLevelScalarFieldEnum]

	export const AccountLoyaltyScalarFieldEnum: {
		id: 'id'
		accountId: 'accountId'
		loyaltyLevelId: 'loyaltyLevelId'
		points: 'points'
		totalSpent: 'totalSpent'
		ordersCount: 'ordersCount'
		lastActivity: 'lastActivity'
		achievements: 'achievements'
		createdAt: 'createdAt'
		updatedAt: 'updatedAt'
	}

	export type AccountLoyaltyScalarFieldEnum = (typeof AccountLoyaltyScalarFieldEnum)[keyof typeof AccountLoyaltyScalarFieldEnum]

	export const LoyaltyTransactionScalarFieldEnum: {
		id: 'id'
		accountLoyaltyId: 'accountLoyaltyId'
		points: 'points'
		type: 'type'
		orderId: 'orderId'
		description: 'description'
		metadata: 'metadata'
		createdAt: 'createdAt'
	}

	export type LoyaltyTransactionScalarFieldEnum =
		(typeof LoyaltyTransactionScalarFieldEnum)[keyof typeof LoyaltyTransactionScalarFieldEnum]

	export const SortOrder: {
		asc: 'asc'
		desc: 'desc'
	}

	export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]

	export const NullableJsonNullValueInput: {
		DbNull: typeof DbNull
		JsonNull: typeof JsonNull
	}

	export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]

	export const QueryMode: {
		default: 'default'
		insensitive: 'insensitive'
	}

	export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]

	export const NullsOrder: {
		first: 'first'
		last: 'last'
	}

	export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]

	export const JsonNullValueFilter: {
		DbNull: typeof DbNull
		JsonNull: typeof JsonNull
		AnyNull: typeof AnyNull
	}

	export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]

	/**
	 * Field references
	 */

	/**
	 * Reference to a field of type 'String'
	 */
	export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>

	/**
	 * Reference to a field of type 'String[]'
	 */
	export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>

	/**
	 * Reference to a field of type 'RoleName'
	 */
	export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>

	/**
	 * Reference to a field of type 'RoleName[]'
	 */
	export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>

	/**
	 * Reference to a field of type 'DateTime'
	 */
	export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>

	/**
	 * Reference to a field of type 'DateTime[]'
	 */
	export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>

	/**
	 * Reference to a field of type 'Int'
	 */
	export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>

	/**
	 * Reference to a field of type 'Int[]'
	 */
	export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>

	/**
	 * Reference to a field of type 'Float'
	 */
	export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>

	/**
	 * Reference to a field of type 'Float[]'
	 */
	export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>

	/**
	 * Reference to a field of type 'Boolean'
	 */
	export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>

	/**
	 * Reference to a field of type 'OrderStatus'
	 */
	export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>

	/**
	 * Reference to a field of type 'OrderStatus[]'
	 */
	export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>

	/**
	 * Reference to a field of type 'Json'
	 */
	export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>

	/**
	 * Reference to a field of type 'QueryMode'
	 */
	export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>

	/**
	 * Reference to a field of type 'DeliveryType'
	 */
	export type EnumDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryType'>

	/**
	 * Reference to a field of type 'DeliveryType[]'
	 */
	export type ListEnumDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryType[]'>

	/**
	 * Reference to a field of type 'PaymentMethod'
	 */
	export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>

	/**
	 * Reference to a field of type 'PaymentMethod[]'
	 */
	export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>

	/**
	 * Reference to a field of type 'PaymentStatus'
	 */
	export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>

	/**
	 * Reference to a field of type 'PaymentStatus[]'
	 */
	export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>

	/**
	 * Reference to a field of type 'TokenTypes'
	 */
	export type EnumTokenTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenTypes'>

	/**
	 * Reference to a field of type 'TokenTypes[]'
	 */
	export type ListEnumTokenTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenTypes[]'>

	/**
	 * Reference to a field of type 'NotificationType'
	 */
	export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>

	/**
	 * Reference to a field of type 'NotificationType[]'
	 */
	export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>

	/**
	 * Reference to a field of type 'LoyaltyTransactionType'
	 */
	export type EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType'>

	/**
	 * Reference to a field of type 'LoyaltyTransactionType[]'
	 */
	export type ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
		$PrismaModel,
		'LoyaltyTransactionType[]'
	>

	/**
	 * Deep Input Types
	 */

	export type RoleWhereInput = {
		AND?: RoleWhereInput | RoleWhereInput[]
		OR?: RoleWhereInput[]
		NOT?: RoleWhereInput | RoleWhereInput[]
		id?: StringFilter<'Role'> | string
		name?: EnumRoleNameFilter<'Role'> | $Enums.RoleName
		accountRoles?: AccountRoleListRelationFilter
	}

	export type RoleOrderByWithRelationInput = {
		id?: SortOrder
		name?: SortOrder
		accountRoles?: AccountRoleOrderByRelationAggregateInput
	}

	export type RoleWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			name?: $Enums.RoleName
			AND?: RoleWhereInput | RoleWhereInput[]
			OR?: RoleWhereInput[]
			NOT?: RoleWhereInput | RoleWhereInput[]
			accountRoles?: AccountRoleListRelationFilter
		},
		'id' | 'name'
	>

	export type RoleOrderByWithAggregationInput = {
		id?: SortOrder
		name?: SortOrder
		_count?: RoleCountOrderByAggregateInput
		_max?: RoleMaxOrderByAggregateInput
		_min?: RoleMinOrderByAggregateInput
	}

	export type RoleScalarWhereWithAggregatesInput = {
		AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
		OR?: RoleScalarWhereWithAggregatesInput[]
		NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Role'> | string
		name?: EnumRoleNameWithAggregatesFilter<'Role'> | $Enums.RoleName
	}

	export type AccountRoleWhereInput = {
		AND?: AccountRoleWhereInput | AccountRoleWhereInput[]
		OR?: AccountRoleWhereInput[]
		NOT?: AccountRoleWhereInput | AccountRoleWhereInput[]
		id?: StringFilter<'AccountRole'> | string
		accountId?: StringFilter<'AccountRole'> | string
		roleId?: StringFilter<'AccountRole'> | string
		createdAt?: DateTimeFilter<'AccountRole'> | Date | string
		updatedAt?: DateTimeFilter<'AccountRole'> | Date | string
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
	}

	export type AccountRoleOrderByWithRelationInput = {
		id?: SortOrder
		accountId?: SortOrder
		roleId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		account?: AccountOrderByWithRelationInput
		role?: RoleOrderByWithRelationInput
	}

	export type AccountRoleWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: AccountRoleWhereInput | AccountRoleWhereInput[]
			OR?: AccountRoleWhereInput[]
			NOT?: AccountRoleWhereInput | AccountRoleWhereInput[]
			accountId?: StringFilter<'AccountRole'> | string
			roleId?: StringFilter<'AccountRole'> | string
			createdAt?: DateTimeFilter<'AccountRole'> | Date | string
			updatedAt?: DateTimeFilter<'AccountRole'> | Date | string
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
			role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
		},
		'id'
	>

	export type AccountRoleOrderByWithAggregationInput = {
		id?: SortOrder
		accountId?: SortOrder
		roleId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: AccountRoleCountOrderByAggregateInput
		_max?: AccountRoleMaxOrderByAggregateInput
		_min?: AccountRoleMinOrderByAggregateInput
	}

	export type AccountRoleScalarWhereWithAggregatesInput = {
		AND?: AccountRoleScalarWhereWithAggregatesInput | AccountRoleScalarWhereWithAggregatesInput[]
		OR?: AccountRoleScalarWhereWithAggregatesInput[]
		NOT?: AccountRoleScalarWhereWithAggregatesInput | AccountRoleScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'AccountRole'> | string
		accountId?: StringWithAggregatesFilter<'AccountRole'> | string
		roleId?: StringWithAggregatesFilter<'AccountRole'> | string
		createdAt?: DateTimeWithAggregatesFilter<'AccountRole'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'AccountRole'> | Date | string
	}

	export type CartWhereInput = {
		AND?: CartWhereInput | CartWhereInput[]
		OR?: CartWhereInput[]
		NOT?: CartWhereInput | CartWhereInput[]
		id?: StringFilter<'Cart'> | string
		accountId?: StringFilter<'Cart'> | string
		productId?: StringFilter<'Cart'> | string
		quantity?: IntFilter<'Cart'> | number
		createdAt?: DateTimeFilter<'Cart'> | Date | string
		updatedAt?: DateTimeFilter<'Cart'> | Date | string
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
	}

	export type CartOrderByWithRelationInput = {
		id?: SortOrder
		accountId?: SortOrder
		productId?: SortOrder
		quantity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		account?: AccountOrderByWithRelationInput
		product?: ProductOrderByWithRelationInput
	}

	export type CartWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: CartWhereInput | CartWhereInput[]
			OR?: CartWhereInput[]
			NOT?: CartWhereInput | CartWhereInput[]
			accountId?: StringFilter<'Cart'> | string
			productId?: StringFilter<'Cart'> | string
			quantity?: IntFilter<'Cart'> | number
			createdAt?: DateTimeFilter<'Cart'> | Date | string
			updatedAt?: DateTimeFilter<'Cart'> | Date | string
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
			product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
		},
		'id'
	>

	export type CartOrderByWithAggregationInput = {
		id?: SortOrder
		accountId?: SortOrder
		productId?: SortOrder
		quantity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: CartCountOrderByAggregateInput
		_avg?: CartAvgOrderByAggregateInput
		_max?: CartMaxOrderByAggregateInput
		_min?: CartMinOrderByAggregateInput
		_sum?: CartSumOrderByAggregateInput
	}

	export type CartScalarWhereWithAggregatesInput = {
		AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
		OR?: CartScalarWhereWithAggregatesInput[]
		NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Cart'> | string
		accountId?: StringWithAggregatesFilter<'Cart'> | string
		productId?: StringWithAggregatesFilter<'Cart'> | string
		quantity?: IntWithAggregatesFilter<'Cart'> | number
		createdAt?: DateTimeWithAggregatesFilter<'Cart'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Cart'> | Date | string
	}

	export type CategoryWhereInput = {
		AND?: CategoryWhereInput | CategoryWhereInput[]
		OR?: CategoryWhereInput[]
		NOT?: CategoryWhereInput | CategoryWhereInput[]
		id?: StringFilter<'Category'> | string
		title?: StringFilter<'Category'> | string
		imageUrl?: StringNullableFilter<'Category'> | string | null
		createdAt?: DateTimeFilter<'Category'> | Date | string
		updatedAt?: DateTimeFilter<'Category'> | Date | string
		products?: ProductListRelationFilter
	}

	export type CategoryOrderByWithRelationInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		products?: ProductOrderByRelationAggregateInput
	}

	export type CategoryWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			title?: string
			AND?: CategoryWhereInput | CategoryWhereInput[]
			OR?: CategoryWhereInput[]
			NOT?: CategoryWhereInput | CategoryWhereInput[]
			imageUrl?: StringNullableFilter<'Category'> | string | null
			createdAt?: DateTimeFilter<'Category'> | Date | string
			updatedAt?: DateTimeFilter<'Category'> | Date | string
			products?: ProductListRelationFilter
		},
		'id' | 'title'
	>

	export type CategoryOrderByWithAggregationInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: CategoryCountOrderByAggregateInput
		_max?: CategoryMaxOrderByAggregateInput
		_min?: CategoryMinOrderByAggregateInput
	}

	export type CategoryScalarWhereWithAggregatesInput = {
		AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
		OR?: CategoryScalarWhereWithAggregatesInput[]
		NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Category'> | string
		title?: StringWithAggregatesFilter<'Category'> | string
		imageUrl?: StringNullableWithAggregatesFilter<'Category'> | string | null
		createdAt?: DateTimeWithAggregatesFilter<'Category'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Category'> | Date | string
	}

	export type IngredientWhereInput = {
		AND?: IngredientWhereInput | IngredientWhereInput[]
		OR?: IngredientWhereInput[]
		NOT?: IngredientWhereInput | IngredientWhereInput[]
		id?: StringFilter<'Ingredient'> | string
		title?: StringFilter<'Ingredient'> | string
		imageUrl?: StringNullableFilter<'Ingredient'> | string | null
		createdAt?: DateTimeFilter<'Ingredient'> | Date | string
		updatedAt?: DateTimeFilter<'Ingredient'> | Date | string
		productIngredients?: ProductIngredientsListRelationFilter
	}

	export type IngredientOrderByWithRelationInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		productIngredients?: ProductIngredientsOrderByRelationAggregateInput
	}

	export type IngredientWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			title?: string
			AND?: IngredientWhereInput | IngredientWhereInput[]
			OR?: IngredientWhereInput[]
			NOT?: IngredientWhereInput | IngredientWhereInput[]
			imageUrl?: StringNullableFilter<'Ingredient'> | string | null
			createdAt?: DateTimeFilter<'Ingredient'> | Date | string
			updatedAt?: DateTimeFilter<'Ingredient'> | Date | string
			productIngredients?: ProductIngredientsListRelationFilter
		},
		'id' | 'title'
	>

	export type IngredientOrderByWithAggregationInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: IngredientCountOrderByAggregateInput
		_max?: IngredientMaxOrderByAggregateInput
		_min?: IngredientMinOrderByAggregateInput
	}

	export type IngredientScalarWhereWithAggregatesInput = {
		AND?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
		OR?: IngredientScalarWhereWithAggregatesInput[]
		NOT?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Ingredient'> | string
		title?: StringWithAggregatesFilter<'Ingredient'> | string
		imageUrl?: StringNullableWithAggregatesFilter<'Ingredient'> | string | null
		createdAt?: DateTimeWithAggregatesFilter<'Ingredient'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Ingredient'> | Date | string
	}

	export type ProductIngredientsWhereInput = {
		AND?: ProductIngredientsWhereInput | ProductIngredientsWhereInput[]
		OR?: ProductIngredientsWhereInput[]
		NOT?: ProductIngredientsWhereInput | ProductIngredientsWhereInput[]
		id?: StringFilter<'ProductIngredients'> | string
		productId?: StringFilter<'ProductIngredients'> | string
		ingredientId?: StringFilter<'ProductIngredients'> | string
		createdAt?: DateTimeFilter<'ProductIngredients'> | Date | string
		updatedAt?: DateTimeFilter<'ProductIngredients'> | Date | string
		product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
		ingredient?: XOR<IngredientScalarRelationFilter, IngredientWhereInput>
	}

	export type ProductIngredientsOrderByWithRelationInput = {
		id?: SortOrder
		productId?: SortOrder
		ingredientId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		product?: ProductOrderByWithRelationInput
		ingredient?: IngredientOrderByWithRelationInput
	}

	export type ProductIngredientsWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: ProductIngredientsWhereInput | ProductIngredientsWhereInput[]
			OR?: ProductIngredientsWhereInput[]
			NOT?: ProductIngredientsWhereInput | ProductIngredientsWhereInput[]
			productId?: StringFilter<'ProductIngredients'> | string
			ingredientId?: StringFilter<'ProductIngredients'> | string
			createdAt?: DateTimeFilter<'ProductIngredients'> | Date | string
			updatedAt?: DateTimeFilter<'ProductIngredients'> | Date | string
			product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
			ingredient?: XOR<IngredientScalarRelationFilter, IngredientWhereInput>
		},
		'id'
	>

	export type ProductIngredientsOrderByWithAggregationInput = {
		id?: SortOrder
		productId?: SortOrder
		ingredientId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: ProductIngredientsCountOrderByAggregateInput
		_max?: ProductIngredientsMaxOrderByAggregateInput
		_min?: ProductIngredientsMinOrderByAggregateInput
	}

	export type ProductIngredientsScalarWhereWithAggregatesInput = {
		AND?: ProductIngredientsScalarWhereWithAggregatesInput | ProductIngredientsScalarWhereWithAggregatesInput[]
		OR?: ProductIngredientsScalarWhereWithAggregatesInput[]
		NOT?: ProductIngredientsScalarWhereWithAggregatesInput | ProductIngredientsScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'ProductIngredients'> | string
		productId?: StringWithAggregatesFilter<'ProductIngredients'> | string
		ingredientId?: StringWithAggregatesFilter<'ProductIngredients'> | string
		createdAt?: DateTimeWithAggregatesFilter<'ProductIngredients'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'ProductIngredients'> | Date | string
	}

	export type ProductWhereInput = {
		AND?: ProductWhereInput | ProductWhereInput[]
		OR?: ProductWhereInput[]
		NOT?: ProductWhereInput | ProductWhereInput[]
		id?: StringFilter<'Product'> | string
		title?: StringFilter<'Product'> | string
		description?: StringNullableFilter<'Product'> | string | null
		weight?: FloatFilter<'Product'> | number
		imageUrl?: StringNullableFilter<'Product'> | string | null
		price?: FloatFilter<'Product'> | number
		onSale?: BoolFilter<'Product'> | boolean
		categoryId?: StringFilter<'Product'> | string
		createdAt?: DateTimeFilter<'Product'> | Date | string
		updatedAt?: DateTimeFilter<'Product'> | Date | string
		category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
		cart?: CartListRelationFilter
		favorite?: FavoriteListRelationFilter
		ingredients?: ProductIngredientsListRelationFilter
		orderItem?: OrderItemListRelationFilter
		comments?: ProductCommentListRelationFilter
	}

	export type ProductOrderByWithRelationInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrderInput | SortOrder
		weight?: SortOrder
		imageUrl?: SortOrderInput | SortOrder
		price?: SortOrder
		onSale?: SortOrder
		categoryId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		category?: CategoryOrderByWithRelationInput
		cart?: CartOrderByRelationAggregateInput
		favorite?: FavoriteOrderByRelationAggregateInput
		ingredients?: ProductIngredientsOrderByRelationAggregateInput
		orderItem?: OrderItemOrderByRelationAggregateInput
		comments?: ProductCommentOrderByRelationAggregateInput
	}

	export type ProductWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: ProductWhereInput | ProductWhereInput[]
			OR?: ProductWhereInput[]
			NOT?: ProductWhereInput | ProductWhereInput[]
			title?: StringFilter<'Product'> | string
			description?: StringNullableFilter<'Product'> | string | null
			weight?: FloatFilter<'Product'> | number
			imageUrl?: StringNullableFilter<'Product'> | string | null
			price?: FloatFilter<'Product'> | number
			onSale?: BoolFilter<'Product'> | boolean
			categoryId?: StringFilter<'Product'> | string
			createdAt?: DateTimeFilter<'Product'> | Date | string
			updatedAt?: DateTimeFilter<'Product'> | Date | string
			category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
			cart?: CartListRelationFilter
			favorite?: FavoriteListRelationFilter
			ingredients?: ProductIngredientsListRelationFilter
			orderItem?: OrderItemListRelationFilter
			comments?: ProductCommentListRelationFilter
		},
		'id'
	>

	export type ProductOrderByWithAggregationInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrderInput | SortOrder
		weight?: SortOrder
		imageUrl?: SortOrderInput | SortOrder
		price?: SortOrder
		onSale?: SortOrder
		categoryId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: ProductCountOrderByAggregateInput
		_avg?: ProductAvgOrderByAggregateInput
		_max?: ProductMaxOrderByAggregateInput
		_min?: ProductMinOrderByAggregateInput
		_sum?: ProductSumOrderByAggregateInput
	}

	export type ProductScalarWhereWithAggregatesInput = {
		AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
		OR?: ProductScalarWhereWithAggregatesInput[]
		NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Product'> | string
		title?: StringWithAggregatesFilter<'Product'> | string
		description?: StringNullableWithAggregatesFilter<'Product'> | string | null
		weight?: FloatWithAggregatesFilter<'Product'> | number
		imageUrl?: StringNullableWithAggregatesFilter<'Product'> | string | null
		price?: FloatWithAggregatesFilter<'Product'> | number
		onSale?: BoolWithAggregatesFilter<'Product'> | boolean
		categoryId?: StringWithAggregatesFilter<'Product'> | string
		createdAt?: DateTimeWithAggregatesFilter<'Product'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Product'> | Date | string
	}

	export type FavoriteWhereInput = {
		AND?: FavoriteWhereInput | FavoriteWhereInput[]
		OR?: FavoriteWhereInput[]
		NOT?: FavoriteWhereInput | FavoriteWhereInput[]
		id?: StringFilter<'Favorite'> | string
		productId?: StringFilter<'Favorite'> | string
		accountId?: StringFilter<'Favorite'> | string
		createdAt?: DateTimeFilter<'Favorite'> | Date | string
		updatedAt?: DateTimeFilter<'Favorite'> | Date | string
		product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
	}

	export type FavoriteOrderByWithRelationInput = {
		id?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		product?: ProductOrderByWithRelationInput
		account?: AccountOrderByWithRelationInput
	}

	export type FavoriteWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			accountId_productId?: FavoriteAccountIdProductIdCompoundUniqueInput
			AND?: FavoriteWhereInput | FavoriteWhereInput[]
			OR?: FavoriteWhereInput[]
			NOT?: FavoriteWhereInput | FavoriteWhereInput[]
			productId?: StringFilter<'Favorite'> | string
			accountId?: StringFilter<'Favorite'> | string
			createdAt?: DateTimeFilter<'Favorite'> | Date | string
			updatedAt?: DateTimeFilter<'Favorite'> | Date | string
			product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		},
		'id' | 'accountId_productId'
	>

	export type FavoriteOrderByWithAggregationInput = {
		id?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: FavoriteCountOrderByAggregateInput
		_max?: FavoriteMaxOrderByAggregateInput
		_min?: FavoriteMinOrderByAggregateInput
	}

	export type FavoriteScalarWhereWithAggregatesInput = {
		AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
		OR?: FavoriteScalarWhereWithAggregatesInput[]
		NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Favorite'> | string
		productId?: StringWithAggregatesFilter<'Favorite'> | string
		accountId?: StringWithAggregatesFilter<'Favorite'> | string
		createdAt?: DateTimeWithAggregatesFilter<'Favorite'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Favorite'> | Date | string
	}

	export type AccountSettingsWhereInput = {
		AND?: AccountSettingsWhereInput | AccountSettingsWhereInput[]
		OR?: AccountSettingsWhereInput[]
		NOT?: AccountSettingsWhereInput | AccountSettingsWhereInput[]
		id?: StringFilter<'AccountSettings'> | string
		accountId?: StringFilter<'AccountSettings'> | string
		telegramId?: StringNullableFilter<'AccountSettings'> | string | null
		isVerifiedEmail?: BoolFilter<'AccountSettings'> | boolean
		isTwoFactorEmailEnabled?: BoolFilter<'AccountSettings'> | boolean
		isTwoFactorTotpEnabled?: BoolFilter<'AccountSettings'> | boolean
		totpSecret?: StringNullableFilter<'AccountSettings'> | string | null
		siteNotification?: BoolFilter<'AccountSettings'> | boolean
		telegramNotification?: BoolFilter<'AccountSettings'> | boolean
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
	}

	export type AccountSettingsOrderByWithRelationInput = {
		id?: SortOrder
		accountId?: SortOrder
		telegramId?: SortOrderInput | SortOrder
		isVerifiedEmail?: SortOrder
		isTwoFactorEmailEnabled?: SortOrder
		isTwoFactorTotpEnabled?: SortOrder
		totpSecret?: SortOrderInput | SortOrder
		siteNotification?: SortOrder
		telegramNotification?: SortOrder
		account?: AccountOrderByWithRelationInput
	}

	export type AccountSettingsWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			accountId?: string
			telegramId?: string
			AND?: AccountSettingsWhereInput | AccountSettingsWhereInput[]
			OR?: AccountSettingsWhereInput[]
			NOT?: AccountSettingsWhereInput | AccountSettingsWhereInput[]
			isVerifiedEmail?: BoolFilter<'AccountSettings'> | boolean
			isTwoFactorEmailEnabled?: BoolFilter<'AccountSettings'> | boolean
			isTwoFactorTotpEnabled?: BoolFilter<'AccountSettings'> | boolean
			totpSecret?: StringNullableFilter<'AccountSettings'> | string | null
			siteNotification?: BoolFilter<'AccountSettings'> | boolean
			telegramNotification?: BoolFilter<'AccountSettings'> | boolean
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		},
		'id' | 'accountId' | 'telegramId'
	>

	export type AccountSettingsOrderByWithAggregationInput = {
		id?: SortOrder
		accountId?: SortOrder
		telegramId?: SortOrderInput | SortOrder
		isVerifiedEmail?: SortOrder
		isTwoFactorEmailEnabled?: SortOrder
		isTwoFactorTotpEnabled?: SortOrder
		totpSecret?: SortOrderInput | SortOrder
		siteNotification?: SortOrder
		telegramNotification?: SortOrder
		_count?: AccountSettingsCountOrderByAggregateInput
		_max?: AccountSettingsMaxOrderByAggregateInput
		_min?: AccountSettingsMinOrderByAggregateInput
	}

	export type AccountSettingsScalarWhereWithAggregatesInput = {
		AND?: AccountSettingsScalarWhereWithAggregatesInput | AccountSettingsScalarWhereWithAggregatesInput[]
		OR?: AccountSettingsScalarWhereWithAggregatesInput[]
		NOT?: AccountSettingsScalarWhereWithAggregatesInput | AccountSettingsScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'AccountSettings'> | string
		accountId?: StringWithAggregatesFilter<'AccountSettings'> | string
		telegramId?: StringNullableWithAggregatesFilter<'AccountSettings'> | string | null
		isVerifiedEmail?: BoolWithAggregatesFilter<'AccountSettings'> | boolean
		isTwoFactorEmailEnabled?: BoolWithAggregatesFilter<'AccountSettings'> | boolean
		isTwoFactorTotpEnabled?: BoolWithAggregatesFilter<'AccountSettings'> | boolean
		totpSecret?: StringNullableWithAggregatesFilter<'AccountSettings'> | string | null
		siteNotification?: BoolWithAggregatesFilter<'AccountSettings'> | boolean
		telegramNotification?: BoolWithAggregatesFilter<'AccountSettings'> | boolean
	}

	export type AccountWhereInput = {
		AND?: AccountWhereInput | AccountWhereInput[]
		OR?: AccountWhereInput[]
		NOT?: AccountWhereInput | AccountWhereInput[]
		id?: StringFilter<'Account'> | string
		email?: StringFilter<'Account'> | string
		password?: StringFilter<'Account'> | string
		userName?: StringFilter<'Account'> | string
		picture?: StringNullableFilter<'Account'> | string | null
		createdAt?: DateTimeFilter<'Account'> | Date | string
		updatedAt?: DateTimeFilter<'Account'> | Date | string
		roles?: AccountRoleListRelationFilter
		cart?: CartListRelationFilter
		favorites?: FavoriteListRelationFilter
		orders?: OrderListRelationFilter
		productComments?: ProductCommentListRelationFilter
		deliveryAdresses?: DeliveryAddressListRelationFilter
		notifications?: NotificationListRelationFilter
		posts?: PostListRelationFilter
		postComments?: PostCommentListRelationFilter
		postLikes?: PostLikeListRelationFilter
		tokens?: TokenListRelationFilter
		accountSettings?: XOR<AccountSettingsNullableScalarRelationFilter, AccountSettingsWhereInput> | null
		accountLoyalty?: XOR<AccountLoyaltyNullableScalarRelationFilter, AccountLoyaltyWhereInput> | null
		sentMessages?: SupportMessageListRelationFilter
		receivedMessages?: SupportMessageListRelationFilter
	}

	export type AccountOrderByWithRelationInput = {
		id?: SortOrder
		email?: SortOrder
		password?: SortOrder
		userName?: SortOrder
		picture?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		roles?: AccountRoleOrderByRelationAggregateInput
		cart?: CartOrderByRelationAggregateInput
		favorites?: FavoriteOrderByRelationAggregateInput
		orders?: OrderOrderByRelationAggregateInput
		productComments?: ProductCommentOrderByRelationAggregateInput
		deliveryAdresses?: DeliveryAddressOrderByRelationAggregateInput
		notifications?: NotificationOrderByRelationAggregateInput
		posts?: PostOrderByRelationAggregateInput
		postComments?: PostCommentOrderByRelationAggregateInput
		postLikes?: PostLikeOrderByRelationAggregateInput
		tokens?: TokenOrderByRelationAggregateInput
		accountSettings?: AccountSettingsOrderByWithRelationInput
		accountLoyalty?: AccountLoyaltyOrderByWithRelationInput
		sentMessages?: SupportMessageOrderByRelationAggregateInput
		receivedMessages?: SupportMessageOrderByRelationAggregateInput
	}

	export type AccountWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			email?: string
			userName?: string
			AND?: AccountWhereInput | AccountWhereInput[]
			OR?: AccountWhereInput[]
			NOT?: AccountWhereInput | AccountWhereInput[]
			password?: StringFilter<'Account'> | string
			picture?: StringNullableFilter<'Account'> | string | null
			createdAt?: DateTimeFilter<'Account'> | Date | string
			updatedAt?: DateTimeFilter<'Account'> | Date | string
			roles?: AccountRoleListRelationFilter
			cart?: CartListRelationFilter
			favorites?: FavoriteListRelationFilter
			orders?: OrderListRelationFilter
			productComments?: ProductCommentListRelationFilter
			deliveryAdresses?: DeliveryAddressListRelationFilter
			notifications?: NotificationListRelationFilter
			posts?: PostListRelationFilter
			postComments?: PostCommentListRelationFilter
			postLikes?: PostLikeListRelationFilter
			tokens?: TokenListRelationFilter
			accountSettings?: XOR<AccountSettingsNullableScalarRelationFilter, AccountSettingsWhereInput> | null
			accountLoyalty?: XOR<AccountLoyaltyNullableScalarRelationFilter, AccountLoyaltyWhereInput> | null
			sentMessages?: SupportMessageListRelationFilter
			receivedMessages?: SupportMessageListRelationFilter
		},
		'id' | 'email' | 'userName'
	>

	export type AccountOrderByWithAggregationInput = {
		id?: SortOrder
		email?: SortOrder
		password?: SortOrder
		userName?: SortOrder
		picture?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: AccountCountOrderByAggregateInput
		_max?: AccountMaxOrderByAggregateInput
		_min?: AccountMinOrderByAggregateInput
	}

	export type AccountScalarWhereWithAggregatesInput = {
		AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
		OR?: AccountScalarWhereWithAggregatesInput[]
		NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Account'> | string
		email?: StringWithAggregatesFilter<'Account'> | string
		password?: StringWithAggregatesFilter<'Account'> | string
		userName?: StringWithAggregatesFilter<'Account'> | string
		picture?: StringNullableWithAggregatesFilter<'Account'> | string | null
		createdAt?: DateTimeWithAggregatesFilter<'Account'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Account'> | Date | string
	}

	export type DeliveryAddressWhereInput = {
		AND?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
		OR?: DeliveryAddressWhereInput[]
		NOT?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
		id?: StringFilter<'DeliveryAddress'> | string
		accountId?: StringFilter<'DeliveryAddress'> | string
		city?: StringFilter<'DeliveryAddress'> | string
		street?: StringFilter<'DeliveryAddress'> | string
		house?: StringFilter<'DeliveryAddress'> | string
		flat?: StringFilter<'DeliveryAddress'> | string
		createdAt?: DateTimeFilter<'DeliveryAddress'> | Date | string
		updatedAt?: DateTimeFilter<'DeliveryAddress'> | Date | string
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
	}

	export type DeliveryAddressOrderByWithRelationInput = {
		id?: SortOrder
		accountId?: SortOrder
		city?: SortOrder
		street?: SortOrder
		house?: SortOrder
		flat?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		account?: AccountOrderByWithRelationInput
	}

	export type DeliveryAddressWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
			OR?: DeliveryAddressWhereInput[]
			NOT?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
			accountId?: StringFilter<'DeliveryAddress'> | string
			city?: StringFilter<'DeliveryAddress'> | string
			street?: StringFilter<'DeliveryAddress'> | string
			house?: StringFilter<'DeliveryAddress'> | string
			flat?: StringFilter<'DeliveryAddress'> | string
			createdAt?: DateTimeFilter<'DeliveryAddress'> | Date | string
			updatedAt?: DateTimeFilter<'DeliveryAddress'> | Date | string
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		},
		'id'
	>

	export type DeliveryAddressOrderByWithAggregationInput = {
		id?: SortOrder
		accountId?: SortOrder
		city?: SortOrder
		street?: SortOrder
		house?: SortOrder
		flat?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: DeliveryAddressCountOrderByAggregateInput
		_max?: DeliveryAddressMaxOrderByAggregateInput
		_min?: DeliveryAddressMinOrderByAggregateInput
	}

	export type DeliveryAddressScalarWhereWithAggregatesInput = {
		AND?: DeliveryAddressScalarWhereWithAggregatesInput | DeliveryAddressScalarWhereWithAggregatesInput[]
		OR?: DeliveryAddressScalarWhereWithAggregatesInput[]
		NOT?: DeliveryAddressScalarWhereWithAggregatesInput | DeliveryAddressScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'DeliveryAddress'> | string
		accountId?: StringWithAggregatesFilter<'DeliveryAddress'> | string
		city?: StringWithAggregatesFilter<'DeliveryAddress'> | string
		street?: StringWithAggregatesFilter<'DeliveryAddress'> | string
		house?: StringWithAggregatesFilter<'DeliveryAddress'> | string
		flat?: StringWithAggregatesFilter<'DeliveryAddress'> | string
		createdAt?: DateTimeWithAggregatesFilter<'DeliveryAddress'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'DeliveryAddress'> | Date | string
	}

	export type OrderWhereInput = {
		AND?: OrderWhereInput | OrderWhereInput[]
		OR?: OrderWhereInput[]
		NOT?: OrderWhereInput | OrderWhereInput[]
		id?: StringFilter<'Order'> | string
		status?: EnumOrderStatusFilter<'Order'> | $Enums.OrderStatus
		firstName?: StringFilter<'Order'> | string
		lastName?: StringFilter<'Order'> | string
		phone?: StringFilter<'Order'> | string
		email?: StringNullableFilter<'Order'> | string | null
		deliveryAddressId?: StringNullableFilter<'Order'> | string | null
		deliveryAddress?: JsonNullableFilter<'Order'>
		deliveryType?: EnumDeliveryTypeFilter<'Order'> | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFilter<'Order'> | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFilter<'Order'> | $Enums.PaymentStatus
		comment?: StringNullableFilter<'Order'> | string | null
		total?: FloatFilter<'Order'> | number
		accountId?: StringNullableFilter<'Order'> | string | null
		createdAt?: DateTimeFilter<'Order'> | Date | string
		updatedAt?: DateTimeFilter<'Order'> | Date | string
		items?: OrderItemListRelationFilter
		account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
	}

	export type OrderOrderByWithRelationInput = {
		id?: SortOrder
		status?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		phone?: SortOrder
		email?: SortOrderInput | SortOrder
		deliveryAddressId?: SortOrderInput | SortOrder
		deliveryAddress?: SortOrderInput | SortOrder
		deliveryType?: SortOrder
		paymentMethod?: SortOrder
		paymentStatus?: SortOrder
		comment?: SortOrderInput | SortOrder
		total?: SortOrder
		accountId?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		items?: OrderItemOrderByRelationAggregateInput
		account?: AccountOrderByWithRelationInput
	}

	export type OrderWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: OrderWhereInput | OrderWhereInput[]
			OR?: OrderWhereInput[]
			NOT?: OrderWhereInput | OrderWhereInput[]
			status?: EnumOrderStatusFilter<'Order'> | $Enums.OrderStatus
			firstName?: StringFilter<'Order'> | string
			lastName?: StringFilter<'Order'> | string
			phone?: StringFilter<'Order'> | string
			email?: StringNullableFilter<'Order'> | string | null
			deliveryAddressId?: StringNullableFilter<'Order'> | string | null
			deliveryAddress?: JsonNullableFilter<'Order'>
			deliveryType?: EnumDeliveryTypeFilter<'Order'> | $Enums.DeliveryType
			paymentMethod?: EnumPaymentMethodFilter<'Order'> | $Enums.PaymentMethod
			paymentStatus?: EnumPaymentStatusFilter<'Order'> | $Enums.PaymentStatus
			comment?: StringNullableFilter<'Order'> | string | null
			total?: FloatFilter<'Order'> | number
			accountId?: StringNullableFilter<'Order'> | string | null
			createdAt?: DateTimeFilter<'Order'> | Date | string
			updatedAt?: DateTimeFilter<'Order'> | Date | string
			items?: OrderItemListRelationFilter
			account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
		},
		'id'
	>

	export type OrderOrderByWithAggregationInput = {
		id?: SortOrder
		status?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		phone?: SortOrder
		email?: SortOrderInput | SortOrder
		deliveryAddressId?: SortOrderInput | SortOrder
		deliveryAddress?: SortOrderInput | SortOrder
		deliveryType?: SortOrder
		paymentMethod?: SortOrder
		paymentStatus?: SortOrder
		comment?: SortOrderInput | SortOrder
		total?: SortOrder
		accountId?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: OrderCountOrderByAggregateInput
		_avg?: OrderAvgOrderByAggregateInput
		_max?: OrderMaxOrderByAggregateInput
		_min?: OrderMinOrderByAggregateInput
		_sum?: OrderSumOrderByAggregateInput
	}

	export type OrderScalarWhereWithAggregatesInput = {
		AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
		OR?: OrderScalarWhereWithAggregatesInput[]
		NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Order'> | string
		status?: EnumOrderStatusWithAggregatesFilter<'Order'> | $Enums.OrderStatus
		firstName?: StringWithAggregatesFilter<'Order'> | string
		lastName?: StringWithAggregatesFilter<'Order'> | string
		phone?: StringWithAggregatesFilter<'Order'> | string
		email?: StringNullableWithAggregatesFilter<'Order'> | string | null
		deliveryAddressId?: StringNullableWithAggregatesFilter<'Order'> | string | null
		deliveryAddress?: JsonNullableWithAggregatesFilter<'Order'>
		deliveryType?: EnumDeliveryTypeWithAggregatesFilter<'Order'> | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodWithAggregatesFilter<'Order'> | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusWithAggregatesFilter<'Order'> | $Enums.PaymentStatus
		comment?: StringNullableWithAggregatesFilter<'Order'> | string | null
		total?: FloatWithAggregatesFilter<'Order'> | number
		accountId?: StringNullableWithAggregatesFilter<'Order'> | string | null
		createdAt?: DateTimeWithAggregatesFilter<'Order'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Order'> | Date | string
	}

	export type OrderItemWhereInput = {
		AND?: OrderItemWhereInput | OrderItemWhereInput[]
		OR?: OrderItemWhereInput[]
		NOT?: OrderItemWhereInput | OrderItemWhereInput[]
		id?: StringFilter<'OrderItem'> | string
		orderId?: StringNullableFilter<'OrderItem'> | string | null
		quantity?: IntFilter<'OrderItem'> | number
		price?: FloatFilter<'OrderItem'> | number
		productTitle?: StringFilter<'OrderItem'> | string
		productDescription?: StringNullableFilter<'OrderItem'> | string | null
		productImageUrl?: StringNullableFilter<'OrderItem'> | string | null
		productId?: StringFilter<'OrderItem'> | string
		createdAt?: DateTimeFilter<'OrderItem'> | Date | string
		updatedAt?: DateTimeFilter<'OrderItem'> | Date | string
		order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
		product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
	}

	export type OrderItemOrderByWithRelationInput = {
		id?: SortOrder
		orderId?: SortOrderInput | SortOrder
		quantity?: SortOrder
		price?: SortOrder
		productTitle?: SortOrder
		productDescription?: SortOrderInput | SortOrder
		productImageUrl?: SortOrderInput | SortOrder
		productId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		order?: OrderOrderByWithRelationInput
		product?: ProductOrderByWithRelationInput
	}

	export type OrderItemWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: OrderItemWhereInput | OrderItemWhereInput[]
			OR?: OrderItemWhereInput[]
			NOT?: OrderItemWhereInput | OrderItemWhereInput[]
			orderId?: StringNullableFilter<'OrderItem'> | string | null
			quantity?: IntFilter<'OrderItem'> | number
			price?: FloatFilter<'OrderItem'> | number
			productTitle?: StringFilter<'OrderItem'> | string
			productDescription?: StringNullableFilter<'OrderItem'> | string | null
			productImageUrl?: StringNullableFilter<'OrderItem'> | string | null
			productId?: StringFilter<'OrderItem'> | string
			createdAt?: DateTimeFilter<'OrderItem'> | Date | string
			updatedAt?: DateTimeFilter<'OrderItem'> | Date | string
			order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
			product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
		},
		'id'
	>

	export type OrderItemOrderByWithAggregationInput = {
		id?: SortOrder
		orderId?: SortOrderInput | SortOrder
		quantity?: SortOrder
		price?: SortOrder
		productTitle?: SortOrder
		productDescription?: SortOrderInput | SortOrder
		productImageUrl?: SortOrderInput | SortOrder
		productId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: OrderItemCountOrderByAggregateInput
		_avg?: OrderItemAvgOrderByAggregateInput
		_max?: OrderItemMaxOrderByAggregateInput
		_min?: OrderItemMinOrderByAggregateInput
		_sum?: OrderItemSumOrderByAggregateInput
	}

	export type OrderItemScalarWhereWithAggregatesInput = {
		AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
		OR?: OrderItemScalarWhereWithAggregatesInput[]
		NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'OrderItem'> | string
		orderId?: StringNullableWithAggregatesFilter<'OrderItem'> | string | null
		quantity?: IntWithAggregatesFilter<'OrderItem'> | number
		price?: FloatWithAggregatesFilter<'OrderItem'> | number
		productTitle?: StringWithAggregatesFilter<'OrderItem'> | string
		productDescription?: StringNullableWithAggregatesFilter<'OrderItem'> | string | null
		productImageUrl?: StringNullableWithAggregatesFilter<'OrderItem'> | string | null
		productId?: StringWithAggregatesFilter<'OrderItem'> | string
		createdAt?: DateTimeWithAggregatesFilter<'OrderItem'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'OrderItem'> | Date | string
	}

	export type ProductCommentWhereInput = {
		AND?: ProductCommentWhereInput | ProductCommentWhereInput[]
		OR?: ProductCommentWhereInput[]
		NOT?: ProductCommentWhereInput | ProductCommentWhereInput[]
		id?: StringFilter<'ProductComment'> | string
		comment?: StringNullableFilter<'ProductComment'> | string | null
		rating?: IntNullableFilter<'ProductComment'> | number | null
		parentId?: StringNullableFilter<'ProductComment'> | string | null
		productId?: StringFilter<'ProductComment'> | string
		accountId?: StringFilter<'ProductComment'> | string
		createdAt?: DateTimeFilter<'ProductComment'> | Date | string
		updatedAt?: DateTimeFilter<'ProductComment'> | Date | string
		parent?: XOR<ProductCommentNullableScalarRelationFilter, ProductCommentWhereInput> | null
		replies?: ProductCommentListRelationFilter
		product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
	}

	export type ProductCommentOrderByWithRelationInput = {
		id?: SortOrder
		comment?: SortOrderInput | SortOrder
		rating?: SortOrderInput | SortOrder
		parentId?: SortOrderInput | SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		parent?: ProductCommentOrderByWithRelationInput
		replies?: ProductCommentOrderByRelationAggregateInput
		product?: ProductOrderByWithRelationInput
		account?: AccountOrderByWithRelationInput
	}

	export type ProductCommentWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: ProductCommentWhereInput | ProductCommentWhereInput[]
			OR?: ProductCommentWhereInput[]
			NOT?: ProductCommentWhereInput | ProductCommentWhereInput[]
			comment?: StringNullableFilter<'ProductComment'> | string | null
			rating?: IntNullableFilter<'ProductComment'> | number | null
			parentId?: StringNullableFilter<'ProductComment'> | string | null
			productId?: StringFilter<'ProductComment'> | string
			accountId?: StringFilter<'ProductComment'> | string
			createdAt?: DateTimeFilter<'ProductComment'> | Date | string
			updatedAt?: DateTimeFilter<'ProductComment'> | Date | string
			parent?: XOR<ProductCommentNullableScalarRelationFilter, ProductCommentWhereInput> | null
			replies?: ProductCommentListRelationFilter
			product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		},
		'id'
	>

	export type ProductCommentOrderByWithAggregationInput = {
		id?: SortOrder
		comment?: SortOrderInput | SortOrder
		rating?: SortOrderInput | SortOrder
		parentId?: SortOrderInput | SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: ProductCommentCountOrderByAggregateInput
		_avg?: ProductCommentAvgOrderByAggregateInput
		_max?: ProductCommentMaxOrderByAggregateInput
		_min?: ProductCommentMinOrderByAggregateInput
		_sum?: ProductCommentSumOrderByAggregateInput
	}

	export type ProductCommentScalarWhereWithAggregatesInput = {
		AND?: ProductCommentScalarWhereWithAggregatesInput | ProductCommentScalarWhereWithAggregatesInput[]
		OR?: ProductCommentScalarWhereWithAggregatesInput[]
		NOT?: ProductCommentScalarWhereWithAggregatesInput | ProductCommentScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'ProductComment'> | string
		comment?: StringNullableWithAggregatesFilter<'ProductComment'> | string | null
		rating?: IntNullableWithAggregatesFilter<'ProductComment'> | number | null
		parentId?: StringNullableWithAggregatesFilter<'ProductComment'> | string | null
		productId?: StringWithAggregatesFilter<'ProductComment'> | string
		accountId?: StringWithAggregatesFilter<'ProductComment'> | string
		createdAt?: DateTimeWithAggregatesFilter<'ProductComment'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'ProductComment'> | Date | string
	}

	export type PostWhereInput = {
		AND?: PostWhereInput | PostWhereInput[]
		OR?: PostWhereInput[]
		NOT?: PostWhereInput | PostWhereInput[]
		id?: StringFilter<'Post'> | string
		title?: StringFilter<'Post'> | string
		description?: StringNullableFilter<'Post'> | string | null
		imageUrl?: StringNullableFilter<'Post'> | string | null
		published?: BoolFilter<'Post'> | boolean
		authorId?: StringFilter<'Post'> | string
		createdAt?: DateTimeFilter<'Post'> | Date | string
		updatedAt?: DateTimeFilter<'Post'> | Date | string
		author?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		comments?: PostCommentListRelationFilter
		likes?: PostLikeListRelationFilter
	}

	export type PostOrderByWithRelationInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrderInput | SortOrder
		imageUrl?: SortOrderInput | SortOrder
		published?: SortOrder
		authorId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		author?: AccountOrderByWithRelationInput
		comments?: PostCommentOrderByRelationAggregateInput
		likes?: PostLikeOrderByRelationAggregateInput
	}

	export type PostWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: PostWhereInput | PostWhereInput[]
			OR?: PostWhereInput[]
			NOT?: PostWhereInput | PostWhereInput[]
			title?: StringFilter<'Post'> | string
			description?: StringNullableFilter<'Post'> | string | null
			imageUrl?: StringNullableFilter<'Post'> | string | null
			published?: BoolFilter<'Post'> | boolean
			authorId?: StringFilter<'Post'> | string
			createdAt?: DateTimeFilter<'Post'> | Date | string
			updatedAt?: DateTimeFilter<'Post'> | Date | string
			author?: XOR<AccountScalarRelationFilter, AccountWhereInput>
			comments?: PostCommentListRelationFilter
			likes?: PostLikeListRelationFilter
		},
		'id'
	>

	export type PostOrderByWithAggregationInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrderInput | SortOrder
		imageUrl?: SortOrderInput | SortOrder
		published?: SortOrder
		authorId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: PostCountOrderByAggregateInput
		_max?: PostMaxOrderByAggregateInput
		_min?: PostMinOrderByAggregateInput
	}

	export type PostScalarWhereWithAggregatesInput = {
		AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
		OR?: PostScalarWhereWithAggregatesInput[]
		NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Post'> | string
		title?: StringWithAggregatesFilter<'Post'> | string
		description?: StringNullableWithAggregatesFilter<'Post'> | string | null
		imageUrl?: StringNullableWithAggregatesFilter<'Post'> | string | null
		published?: BoolWithAggregatesFilter<'Post'> | boolean
		authorId?: StringWithAggregatesFilter<'Post'> | string
		createdAt?: DateTimeWithAggregatesFilter<'Post'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Post'> | Date | string
	}

	export type PostCommentWhereInput = {
		AND?: PostCommentWhereInput | PostCommentWhereInput[]
		OR?: PostCommentWhereInput[]
		NOT?: PostCommentWhereInput | PostCommentWhereInput[]
		id?: StringFilter<'PostComment'> | string
		comment?: StringFilter<'PostComment'> | string
		authorId?: StringFilter<'PostComment'> | string
		postId?: StringFilter<'PostComment'> | string
		createdAt?: DateTimeFilter<'PostComment'> | Date | string
		updatedAt?: DateTimeFilter<'PostComment'> | Date | string
		author?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		post?: XOR<PostScalarRelationFilter, PostWhereInput>
	}

	export type PostCommentOrderByWithRelationInput = {
		id?: SortOrder
		comment?: SortOrder
		authorId?: SortOrder
		postId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		author?: AccountOrderByWithRelationInput
		post?: PostOrderByWithRelationInput
	}

	export type PostCommentWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: PostCommentWhereInput | PostCommentWhereInput[]
			OR?: PostCommentWhereInput[]
			NOT?: PostCommentWhereInput | PostCommentWhereInput[]
			comment?: StringFilter<'PostComment'> | string
			authorId?: StringFilter<'PostComment'> | string
			postId?: StringFilter<'PostComment'> | string
			createdAt?: DateTimeFilter<'PostComment'> | Date | string
			updatedAt?: DateTimeFilter<'PostComment'> | Date | string
			author?: XOR<AccountScalarRelationFilter, AccountWhereInput>
			post?: XOR<PostScalarRelationFilter, PostWhereInput>
		},
		'id'
	>

	export type PostCommentOrderByWithAggregationInput = {
		id?: SortOrder
		comment?: SortOrder
		authorId?: SortOrder
		postId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: PostCommentCountOrderByAggregateInput
		_max?: PostCommentMaxOrderByAggregateInput
		_min?: PostCommentMinOrderByAggregateInput
	}

	export type PostCommentScalarWhereWithAggregatesInput = {
		AND?: PostCommentScalarWhereWithAggregatesInput | PostCommentScalarWhereWithAggregatesInput[]
		OR?: PostCommentScalarWhereWithAggregatesInput[]
		NOT?: PostCommentScalarWhereWithAggregatesInput | PostCommentScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'PostComment'> | string
		comment?: StringWithAggregatesFilter<'PostComment'> | string
		authorId?: StringWithAggregatesFilter<'PostComment'> | string
		postId?: StringWithAggregatesFilter<'PostComment'> | string
		createdAt?: DateTimeWithAggregatesFilter<'PostComment'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'PostComment'> | Date | string
	}

	export type PostLikeWhereInput = {
		AND?: PostLikeWhereInput | PostLikeWhereInput[]
		OR?: PostLikeWhereInput[]
		NOT?: PostLikeWhereInput | PostLikeWhereInput[]
		id?: StringFilter<'PostLike'> | string
		postId?: StringFilter<'PostLike'> | string
		accountId?: StringFilter<'PostLike'> | string
		createdAt?: DateTimeFilter<'PostLike'> | Date | string
		updatedAt?: DateTimeFilter<'PostLike'> | Date | string
		post?: XOR<PostScalarRelationFilter, PostWhereInput>
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
	}

	export type PostLikeOrderByWithRelationInput = {
		id?: SortOrder
		postId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		post?: PostOrderByWithRelationInput
		account?: AccountOrderByWithRelationInput
	}

	export type PostLikeWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			postId_accountId?: PostLikePostIdAccountIdCompoundUniqueInput
			AND?: PostLikeWhereInput | PostLikeWhereInput[]
			OR?: PostLikeWhereInput[]
			NOT?: PostLikeWhereInput | PostLikeWhereInput[]
			postId?: StringFilter<'PostLike'> | string
			accountId?: StringFilter<'PostLike'> | string
			createdAt?: DateTimeFilter<'PostLike'> | Date | string
			updatedAt?: DateTimeFilter<'PostLike'> | Date | string
			post?: XOR<PostScalarRelationFilter, PostWhereInput>
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		},
		'id' | 'postId_accountId'
	>

	export type PostLikeOrderByWithAggregationInput = {
		id?: SortOrder
		postId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: PostLikeCountOrderByAggregateInput
		_max?: PostLikeMaxOrderByAggregateInput
		_min?: PostLikeMinOrderByAggregateInput
	}

	export type PostLikeScalarWhereWithAggregatesInput = {
		AND?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
		OR?: PostLikeScalarWhereWithAggregatesInput[]
		NOT?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'PostLike'> | string
		postId?: StringWithAggregatesFilter<'PostLike'> | string
		accountId?: StringWithAggregatesFilter<'PostLike'> | string
		createdAt?: DateTimeWithAggregatesFilter<'PostLike'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'PostLike'> | Date | string
	}

	export type TokenWhereInput = {
		AND?: TokenWhereInput | TokenWhereInput[]
		OR?: TokenWhereInput[]
		NOT?: TokenWhereInput | TokenWhereInput[]
		id?: StringFilter<'Token'> | string
		token?: StringFilter<'Token'> | string
		type?: EnumTokenTypesFilter<'Token'> | $Enums.TokenTypes
		accountId?: StringFilter<'Token'> | string
		expiresIn?: DateTimeFilter<'Token'> | Date | string
		createdAt?: DateTimeFilter<'Token'> | Date | string
		updatedAt?: DateTimeFilter<'Token'> | Date | string
		account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
	}

	export type TokenOrderByWithRelationInput = {
		id?: SortOrder
		token?: SortOrder
		type?: SortOrder
		accountId?: SortOrder
		expiresIn?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		account?: AccountOrderByWithRelationInput
	}

	export type TokenWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			token?: string
			AND?: TokenWhereInput | TokenWhereInput[]
			OR?: TokenWhereInput[]
			NOT?: TokenWhereInput | TokenWhereInput[]
			type?: EnumTokenTypesFilter<'Token'> | $Enums.TokenTypes
			accountId?: StringFilter<'Token'> | string
			expiresIn?: DateTimeFilter<'Token'> | Date | string
			createdAt?: DateTimeFilter<'Token'> | Date | string
			updatedAt?: DateTimeFilter<'Token'> | Date | string
			account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
		},
		'id' | 'token'
	>

	export type TokenOrderByWithAggregationInput = {
		id?: SortOrder
		token?: SortOrder
		type?: SortOrder
		accountId?: SortOrder
		expiresIn?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: TokenCountOrderByAggregateInput
		_max?: TokenMaxOrderByAggregateInput
		_min?: TokenMinOrderByAggregateInput
	}

	export type TokenScalarWhereWithAggregatesInput = {
		AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
		OR?: TokenScalarWhereWithAggregatesInput[]
		NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Token'> | string
		token?: StringWithAggregatesFilter<'Token'> | string
		type?: EnumTokenTypesWithAggregatesFilter<'Token'> | $Enums.TokenTypes
		accountId?: StringWithAggregatesFilter<'Token'> | string
		expiresIn?: DateTimeWithAggregatesFilter<'Token'> | Date | string
		createdAt?: DateTimeWithAggregatesFilter<'Token'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Token'> | Date | string
	}

	export type NotificationWhereInput = {
		AND?: NotificationWhereInput | NotificationWhereInput[]
		OR?: NotificationWhereInput[]
		NOT?: NotificationWhereInput | NotificationWhereInput[]
		id?: StringFilter<'Notification'> | string
		title?: StringFilter<'Notification'> | string
		message?: StringFilter<'Notification'> | string
		link?: StringFilter<'Notification'> | string
		type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType
		isRead?: BoolFilter<'Notification'> | boolean
		accountId?: StringFilter<'Notification'> | string
		createdAt?: DateTimeFilter<'Notification'> | Date | string
		updatedAt?: DateTimeFilter<'Notification'> | Date | string
		account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
	}

	export type NotificationOrderByWithRelationInput = {
		id?: SortOrder
		title?: SortOrder
		message?: SortOrder
		link?: SortOrder
		type?: SortOrder
		isRead?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		account?: AccountOrderByWithRelationInput
	}

	export type NotificationWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: NotificationWhereInput | NotificationWhereInput[]
			OR?: NotificationWhereInput[]
			NOT?: NotificationWhereInput | NotificationWhereInput[]
			title?: StringFilter<'Notification'> | string
			message?: StringFilter<'Notification'> | string
			link?: StringFilter<'Notification'> | string
			type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType
			isRead?: BoolFilter<'Notification'> | boolean
			accountId?: StringFilter<'Notification'> | string
			createdAt?: DateTimeFilter<'Notification'> | Date | string
			updatedAt?: DateTimeFilter<'Notification'> | Date | string
			account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
		},
		'id'
	>

	export type NotificationOrderByWithAggregationInput = {
		id?: SortOrder
		title?: SortOrder
		message?: SortOrder
		link?: SortOrder
		type?: SortOrder
		isRead?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: NotificationCountOrderByAggregateInput
		_max?: NotificationMaxOrderByAggregateInput
		_min?: NotificationMinOrderByAggregateInput
	}

	export type NotificationScalarWhereWithAggregatesInput = {
		AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
		OR?: NotificationScalarWhereWithAggregatesInput[]
		NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'Notification'> | string
		title?: StringWithAggregatesFilter<'Notification'> | string
		message?: StringWithAggregatesFilter<'Notification'> | string
		link?: StringWithAggregatesFilter<'Notification'> | string
		type?: EnumNotificationTypeWithAggregatesFilter<'Notification'> | $Enums.NotificationType
		isRead?: BoolWithAggregatesFilter<'Notification'> | boolean
		accountId?: StringWithAggregatesFilter<'Notification'> | string
		createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string
	}

	export type SupportMessageWhereInput = {
		AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
		OR?: SupportMessageWhereInput[]
		NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
		id?: StringFilter<'SupportMessage'> | string
		message?: StringFilter<'SupportMessage'> | string
		senderId?: StringFilter<'SupportMessage'> | string
		receiverId?: StringFilter<'SupportMessage'> | string
		createdAt?: DateTimeFilter<'SupportMessage'> | Date | string
		updatedAt?: DateTimeFilter<'SupportMessage'> | Date | string
		sender?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		receiver?: XOR<AccountScalarRelationFilter, AccountWhereInput>
	}

	export type SupportMessageOrderByWithRelationInput = {
		id?: SortOrder
		message?: SortOrder
		senderId?: SortOrder
		receiverId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		sender?: AccountOrderByWithRelationInput
		receiver?: AccountOrderByWithRelationInput
	}

	export type SupportMessageWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
			OR?: SupportMessageWhereInput[]
			NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
			message?: StringFilter<'SupportMessage'> | string
			senderId?: StringFilter<'SupportMessage'> | string
			receiverId?: StringFilter<'SupportMessage'> | string
			createdAt?: DateTimeFilter<'SupportMessage'> | Date | string
			updatedAt?: DateTimeFilter<'SupportMessage'> | Date | string
			sender?: XOR<AccountScalarRelationFilter, AccountWhereInput>
			receiver?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		},
		'id'
	>

	export type SupportMessageOrderByWithAggregationInput = {
		id?: SortOrder
		message?: SortOrder
		senderId?: SortOrder
		receiverId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: SupportMessageCountOrderByAggregateInput
		_max?: SupportMessageMaxOrderByAggregateInput
		_min?: SupportMessageMinOrderByAggregateInput
	}

	export type SupportMessageScalarWhereWithAggregatesInput = {
		AND?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
		OR?: SupportMessageScalarWhereWithAggregatesInput[]
		NOT?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'SupportMessage'> | string
		message?: StringWithAggregatesFilter<'SupportMessage'> | string
		senderId?: StringWithAggregatesFilter<'SupportMessage'> | string
		receiverId?: StringWithAggregatesFilter<'SupportMessage'> | string
		createdAt?: DateTimeWithAggregatesFilter<'SupportMessage'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'SupportMessage'> | Date | string
	}

	export type LoyaltyLevelWhereInput = {
		AND?: LoyaltyLevelWhereInput | LoyaltyLevelWhereInput[]
		OR?: LoyaltyLevelWhereInput[]
		NOT?: LoyaltyLevelWhereInput | LoyaltyLevelWhereInput[]
		id?: StringFilter<'LoyaltyLevel'> | string
		name?: StringFilter<'LoyaltyLevel'> | string
		minPoints?: IntFilter<'LoyaltyLevel'> | number
		bonusPercentage?: FloatFilter<'LoyaltyLevel'> | number
		hasPriorityDelivery?: BoolFilter<'LoyaltyLevel'> | boolean
		hasPersonalManager?: BoolFilter<'LoyaltyLevel'> | boolean
		hasExclusiveAccess?: BoolFilter<'LoyaltyLevel'> | boolean
		additionalBenefits?: JsonNullableFilter<'LoyaltyLevel'>
		createdAt?: DateTimeFilter<'LoyaltyLevel'> | Date | string
		updatedAt?: DateTimeFilter<'LoyaltyLevel'> | Date | string
		accountLoyalties?: AccountLoyaltyListRelationFilter
	}

	export type LoyaltyLevelOrderByWithRelationInput = {
		id?: SortOrder
		name?: SortOrder
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
		hasPriorityDelivery?: SortOrder
		hasPersonalManager?: SortOrder
		hasExclusiveAccess?: SortOrder
		additionalBenefits?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		accountLoyalties?: AccountLoyaltyOrderByRelationAggregateInput
	}

	export type LoyaltyLevelWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: LoyaltyLevelWhereInput | LoyaltyLevelWhereInput[]
			OR?: LoyaltyLevelWhereInput[]
			NOT?: LoyaltyLevelWhereInput | LoyaltyLevelWhereInput[]
			name?: StringFilter<'LoyaltyLevel'> | string
			minPoints?: IntFilter<'LoyaltyLevel'> | number
			bonusPercentage?: FloatFilter<'LoyaltyLevel'> | number
			hasPriorityDelivery?: BoolFilter<'LoyaltyLevel'> | boolean
			hasPersonalManager?: BoolFilter<'LoyaltyLevel'> | boolean
			hasExclusiveAccess?: BoolFilter<'LoyaltyLevel'> | boolean
			additionalBenefits?: JsonNullableFilter<'LoyaltyLevel'>
			createdAt?: DateTimeFilter<'LoyaltyLevel'> | Date | string
			updatedAt?: DateTimeFilter<'LoyaltyLevel'> | Date | string
			accountLoyalties?: AccountLoyaltyListRelationFilter
		},
		'id'
	>

	export type LoyaltyLevelOrderByWithAggregationInput = {
		id?: SortOrder
		name?: SortOrder
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
		hasPriorityDelivery?: SortOrder
		hasPersonalManager?: SortOrder
		hasExclusiveAccess?: SortOrder
		additionalBenefits?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: LoyaltyLevelCountOrderByAggregateInput
		_avg?: LoyaltyLevelAvgOrderByAggregateInput
		_max?: LoyaltyLevelMaxOrderByAggregateInput
		_min?: LoyaltyLevelMinOrderByAggregateInput
		_sum?: LoyaltyLevelSumOrderByAggregateInput
	}

	export type LoyaltyLevelScalarWhereWithAggregatesInput = {
		AND?: LoyaltyLevelScalarWhereWithAggregatesInput | LoyaltyLevelScalarWhereWithAggregatesInput[]
		OR?: LoyaltyLevelScalarWhereWithAggregatesInput[]
		NOT?: LoyaltyLevelScalarWhereWithAggregatesInput | LoyaltyLevelScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'LoyaltyLevel'> | string
		name?: StringWithAggregatesFilter<'LoyaltyLevel'> | string
		minPoints?: IntWithAggregatesFilter<'LoyaltyLevel'> | number
		bonusPercentage?: FloatWithAggregatesFilter<'LoyaltyLevel'> | number
		hasPriorityDelivery?: BoolWithAggregatesFilter<'LoyaltyLevel'> | boolean
		hasPersonalManager?: BoolWithAggregatesFilter<'LoyaltyLevel'> | boolean
		hasExclusiveAccess?: BoolWithAggregatesFilter<'LoyaltyLevel'> | boolean
		additionalBenefits?: JsonNullableWithAggregatesFilter<'LoyaltyLevel'>
		createdAt?: DateTimeWithAggregatesFilter<'LoyaltyLevel'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'LoyaltyLevel'> | Date | string
	}

	export type AccountLoyaltyWhereInput = {
		AND?: AccountLoyaltyWhereInput | AccountLoyaltyWhereInput[]
		OR?: AccountLoyaltyWhereInput[]
		NOT?: AccountLoyaltyWhereInput | AccountLoyaltyWhereInput[]
		id?: StringFilter<'AccountLoyalty'> | string
		accountId?: StringFilter<'AccountLoyalty'> | string
		loyaltyLevelId?: StringFilter<'AccountLoyalty'> | string
		points?: IntFilter<'AccountLoyalty'> | number
		totalSpent?: FloatFilter<'AccountLoyalty'> | number
		ordersCount?: IntFilter<'AccountLoyalty'> | number
		lastActivity?: DateTimeFilter<'AccountLoyalty'> | Date | string
		achievements?: JsonNullableFilter<'AccountLoyalty'>
		createdAt?: DateTimeFilter<'AccountLoyalty'> | Date | string
		updatedAt?: DateTimeFilter<'AccountLoyalty'> | Date | string
		account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
		loyaltyLevel?: XOR<LoyaltyLevelScalarRelationFilter, LoyaltyLevelWhereInput>
		transactions?: LoyaltyTransactionListRelationFilter
	}

	export type AccountLoyaltyOrderByWithRelationInput = {
		id?: SortOrder
		accountId?: SortOrder
		loyaltyLevelId?: SortOrder
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
		lastActivity?: SortOrder
		achievements?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		account?: AccountOrderByWithRelationInput
		loyaltyLevel?: LoyaltyLevelOrderByWithRelationInput
		transactions?: LoyaltyTransactionOrderByRelationAggregateInput
	}

	export type AccountLoyaltyWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			accountId?: string
			AND?: AccountLoyaltyWhereInput | AccountLoyaltyWhereInput[]
			OR?: AccountLoyaltyWhereInput[]
			NOT?: AccountLoyaltyWhereInput | AccountLoyaltyWhereInput[]
			loyaltyLevelId?: StringFilter<'AccountLoyalty'> | string
			points?: IntFilter<'AccountLoyalty'> | number
			totalSpent?: FloatFilter<'AccountLoyalty'> | number
			ordersCount?: IntFilter<'AccountLoyalty'> | number
			lastActivity?: DateTimeFilter<'AccountLoyalty'> | Date | string
			achievements?: JsonNullableFilter<'AccountLoyalty'>
			createdAt?: DateTimeFilter<'AccountLoyalty'> | Date | string
			updatedAt?: DateTimeFilter<'AccountLoyalty'> | Date | string
			account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
			loyaltyLevel?: XOR<LoyaltyLevelScalarRelationFilter, LoyaltyLevelWhereInput>
			transactions?: LoyaltyTransactionListRelationFilter
		},
		'id' | 'accountId'
	>

	export type AccountLoyaltyOrderByWithAggregationInput = {
		id?: SortOrder
		accountId?: SortOrder
		loyaltyLevelId?: SortOrder
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
		lastActivity?: SortOrder
		achievements?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		_count?: AccountLoyaltyCountOrderByAggregateInput
		_avg?: AccountLoyaltyAvgOrderByAggregateInput
		_max?: AccountLoyaltyMaxOrderByAggregateInput
		_min?: AccountLoyaltyMinOrderByAggregateInput
		_sum?: AccountLoyaltySumOrderByAggregateInput
	}

	export type AccountLoyaltyScalarWhereWithAggregatesInput = {
		AND?: AccountLoyaltyScalarWhereWithAggregatesInput | AccountLoyaltyScalarWhereWithAggregatesInput[]
		OR?: AccountLoyaltyScalarWhereWithAggregatesInput[]
		NOT?: AccountLoyaltyScalarWhereWithAggregatesInput | AccountLoyaltyScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'AccountLoyalty'> | string
		accountId?: StringWithAggregatesFilter<'AccountLoyalty'> | string
		loyaltyLevelId?: StringWithAggregatesFilter<'AccountLoyalty'> | string
		points?: IntWithAggregatesFilter<'AccountLoyalty'> | number
		totalSpent?: FloatWithAggregatesFilter<'AccountLoyalty'> | number
		ordersCount?: IntWithAggregatesFilter<'AccountLoyalty'> | number
		lastActivity?: DateTimeWithAggregatesFilter<'AccountLoyalty'> | Date | string
		achievements?: JsonNullableWithAggregatesFilter<'AccountLoyalty'>
		createdAt?: DateTimeWithAggregatesFilter<'AccountLoyalty'> | Date | string
		updatedAt?: DateTimeWithAggregatesFilter<'AccountLoyalty'> | Date | string
	}

	export type LoyaltyTransactionWhereInput = {
		AND?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
		OR?: LoyaltyTransactionWhereInput[]
		NOT?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
		id?: StringFilter<'LoyaltyTransaction'> | string
		accountLoyaltyId?: StringFilter<'LoyaltyTransaction'> | string
		points?: IntFilter<'LoyaltyTransaction'> | number
		type?: EnumLoyaltyTransactionTypeFilter<'LoyaltyTransaction'> | $Enums.LoyaltyTransactionType
		orderId?: StringNullableFilter<'LoyaltyTransaction'> | string | null
		description?: StringNullableFilter<'LoyaltyTransaction'> | string | null
		metadata?: JsonNullableFilter<'LoyaltyTransaction'>
		createdAt?: DateTimeFilter<'LoyaltyTransaction'> | Date | string
		accountLoyalty?: XOR<AccountLoyaltyScalarRelationFilter, AccountLoyaltyWhereInput>
	}

	export type LoyaltyTransactionOrderByWithRelationInput = {
		id?: SortOrder
		accountLoyaltyId?: SortOrder
		points?: SortOrder
		type?: SortOrder
		orderId?: SortOrderInput | SortOrder
		description?: SortOrderInput | SortOrder
		metadata?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		accountLoyalty?: AccountLoyaltyOrderByWithRelationInput
	}

	export type LoyaltyTransactionWhereUniqueInput = Prisma.AtLeast<
		{
			id?: string
			AND?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
			OR?: LoyaltyTransactionWhereInput[]
			NOT?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
			accountLoyaltyId?: StringFilter<'LoyaltyTransaction'> | string
			points?: IntFilter<'LoyaltyTransaction'> | number
			type?: EnumLoyaltyTransactionTypeFilter<'LoyaltyTransaction'> | $Enums.LoyaltyTransactionType
			orderId?: StringNullableFilter<'LoyaltyTransaction'> | string | null
			description?: StringNullableFilter<'LoyaltyTransaction'> | string | null
			metadata?: JsonNullableFilter<'LoyaltyTransaction'>
			createdAt?: DateTimeFilter<'LoyaltyTransaction'> | Date | string
			accountLoyalty?: XOR<AccountLoyaltyScalarRelationFilter, AccountLoyaltyWhereInput>
		},
		'id'
	>

	export type LoyaltyTransactionOrderByWithAggregationInput = {
		id?: SortOrder
		accountLoyaltyId?: SortOrder
		points?: SortOrder
		type?: SortOrder
		orderId?: SortOrderInput | SortOrder
		description?: SortOrderInput | SortOrder
		metadata?: SortOrderInput | SortOrder
		createdAt?: SortOrder
		_count?: LoyaltyTransactionCountOrderByAggregateInput
		_avg?: LoyaltyTransactionAvgOrderByAggregateInput
		_max?: LoyaltyTransactionMaxOrderByAggregateInput
		_min?: LoyaltyTransactionMinOrderByAggregateInput
		_sum?: LoyaltyTransactionSumOrderByAggregateInput
	}

	export type LoyaltyTransactionScalarWhereWithAggregatesInput = {
		AND?: LoyaltyTransactionScalarWhereWithAggregatesInput | LoyaltyTransactionScalarWhereWithAggregatesInput[]
		OR?: LoyaltyTransactionScalarWhereWithAggregatesInput[]
		NOT?: LoyaltyTransactionScalarWhereWithAggregatesInput | LoyaltyTransactionScalarWhereWithAggregatesInput[]
		id?: StringWithAggregatesFilter<'LoyaltyTransaction'> | string
		accountLoyaltyId?: StringWithAggregatesFilter<'LoyaltyTransaction'> | string
		points?: IntWithAggregatesFilter<'LoyaltyTransaction'> | number
		type?: EnumLoyaltyTransactionTypeWithAggregatesFilter<'LoyaltyTransaction'> | $Enums.LoyaltyTransactionType
		orderId?: StringNullableWithAggregatesFilter<'LoyaltyTransaction'> | string | null
		description?: StringNullableWithAggregatesFilter<'LoyaltyTransaction'> | string | null
		metadata?: JsonNullableWithAggregatesFilter<'LoyaltyTransaction'>
		createdAt?: DateTimeWithAggregatesFilter<'LoyaltyTransaction'> | Date | string
	}

	export type RoleCreateInput = {
		id?: string
		name: $Enums.RoleName
		accountRoles?: AccountRoleCreateNestedManyWithoutRoleInput
	}

	export type RoleUncheckedCreateInput = {
		id?: string
		name: $Enums.RoleName
		accountRoles?: AccountRoleUncheckedCreateNestedManyWithoutRoleInput
	}

	export type RoleUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
		accountRoles?: AccountRoleUpdateManyWithoutRoleNestedInput
	}

	export type RoleUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
		accountRoles?: AccountRoleUncheckedUpdateManyWithoutRoleNestedInput
	}

	export type RoleCreateManyInput = {
		id?: string
		name: $Enums.RoleName
	}

	export type RoleUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
	}

	export type RoleUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
	}

	export type AccountRoleCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutRolesInput
		role: RoleCreateNestedOneWithoutAccountRolesInput
	}

	export type AccountRoleUncheckedCreateInput = {
		id?: string
		accountId: string
		roleId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountRoleUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutRolesNestedInput
		role?: RoleUpdateOneRequiredWithoutAccountRolesNestedInput
	}

	export type AccountRoleUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		roleId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountRoleCreateManyInput = {
		id?: string
		accountId: string
		roleId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountRoleUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountRoleUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		roleId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartCreateInput = {
		id?: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutCartInput
		product: ProductCreateNestedOneWithoutCartInput
	}

	export type CartUncheckedCreateInput = {
		id?: string
		accountId: string
		productId: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CartUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutCartNestedInput
		product?: ProductUpdateOneRequiredWithoutCartNestedInput
	}

	export type CartUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartCreateManyInput = {
		id?: string
		accountId: string
		productId: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CartUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CategoryCreateInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		products?: ProductCreateNestedManyWithoutCategoryInput
	}

	export type CategoryUncheckedCreateInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
	}

	export type CategoryUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		products?: ProductUpdateManyWithoutCategoryNestedInput
	}

	export type CategoryUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
	}

	export type CategoryCreateManyInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CategoryUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CategoryUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type IngredientCreateInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		productIngredients?: ProductIngredientsCreateNestedManyWithoutIngredientInput
	}

	export type IngredientUncheckedCreateInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		productIngredients?: ProductIngredientsUncheckedCreateNestedManyWithoutIngredientInput
	}

	export type IngredientUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		productIngredients?: ProductIngredientsUpdateManyWithoutIngredientNestedInput
	}

	export type IngredientUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		productIngredients?: ProductIngredientsUncheckedUpdateManyWithoutIngredientNestedInput
	}

	export type IngredientCreateManyInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type IngredientUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type IngredientUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		product: ProductCreateNestedOneWithoutIngredientsInput
		ingredient: IngredientCreateNestedOneWithoutProductIngredientsInput
	}

	export type ProductIngredientsUncheckedCreateInput = {
		id?: string
		productId: string
		ingredientId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductIngredientsUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		product?: ProductUpdateOneRequiredWithoutIngredientsNestedInput
		ingredient?: IngredientUpdateOneRequiredWithoutProductIngredientsNestedInput
	}

	export type ProductIngredientsUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		ingredientId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsCreateManyInput = {
		id?: string
		productId: string
		ingredientId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductIngredientsUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		ingredientId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCreateInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		category: CategoryCreateNestedOneWithoutProductsInput
		cart?: CartCreateNestedManyWithoutProductInput
		favorite?: FavoriteCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsCreateNestedManyWithoutProductInput
		orderItem?: OrderItemCreateNestedManyWithoutProductInput
		comments?: ProductCommentCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutProductInput
		favorite?: FavoriteUncheckedCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsUncheckedCreateNestedManyWithoutProductInput
		orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
		comments?: ProductCommentUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
		cart?: CartUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUncheckedUpdateManyWithoutProductNestedInput
	}

	export type ProductCreateManyInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		product: ProductCreateNestedOneWithoutFavoriteInput
		account: AccountCreateNestedOneWithoutFavoritesInput
	}

	export type FavoriteUncheckedCreateInput = {
		id?: string
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type FavoriteUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		product?: ProductUpdateOneRequiredWithoutFavoriteNestedInput
		account?: AccountUpdateOneRequiredWithoutFavoritesNestedInput
	}

	export type FavoriteUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteCreateManyInput = {
		id?: string
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type FavoriteUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountSettingsCreateInput = {
		id?: string
		telegramId?: string | null
		isVerifiedEmail?: boolean
		isTwoFactorEmailEnabled?: boolean
		isTwoFactorTotpEnabled?: boolean
		totpSecret?: string | null
		siteNotification?: boolean
		telegramNotification?: boolean
		account: AccountCreateNestedOneWithoutAccountSettingsInput
	}

	export type AccountSettingsUncheckedCreateInput = {
		id?: string
		accountId: string
		telegramId?: string | null
		isVerifiedEmail?: boolean
		isTwoFactorEmailEnabled?: boolean
		isTwoFactorTotpEnabled?: boolean
		totpSecret?: string | null
		siteNotification?: boolean
		telegramNotification?: boolean
	}

	export type AccountSettingsUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		telegramId?: NullableStringFieldUpdateOperationsInput | string | null
		isVerifiedEmail?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorTotpEnabled?: BoolFieldUpdateOperationsInput | boolean
		totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
		siteNotification?: BoolFieldUpdateOperationsInput | boolean
		telegramNotification?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutAccountSettingsNestedInput
	}

	export type AccountSettingsUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		telegramId?: NullableStringFieldUpdateOperationsInput | string | null
		isVerifiedEmail?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorTotpEnabled?: BoolFieldUpdateOperationsInput | boolean
		totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
		siteNotification?: BoolFieldUpdateOperationsInput | boolean
		telegramNotification?: BoolFieldUpdateOperationsInput | boolean
	}

	export type AccountSettingsCreateManyInput = {
		id?: string
		accountId: string
		telegramId?: string | null
		isVerifiedEmail?: boolean
		isTwoFactorEmailEnabled?: boolean
		isTwoFactorTotpEnabled?: boolean
		totpSecret?: string | null
		siteNotification?: boolean
		telegramNotification?: boolean
	}

	export type AccountSettingsUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		telegramId?: NullableStringFieldUpdateOperationsInput | string | null
		isVerifiedEmail?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorTotpEnabled?: BoolFieldUpdateOperationsInput | boolean
		totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
		siteNotification?: BoolFieldUpdateOperationsInput | boolean
		telegramNotification?: BoolFieldUpdateOperationsInput | boolean
	}

	export type AccountSettingsUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		telegramId?: NullableStringFieldUpdateOperationsInput | string | null
		isVerifiedEmail?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorTotpEnabled?: BoolFieldUpdateOperationsInput | boolean
		totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
		siteNotification?: BoolFieldUpdateOperationsInput | boolean
		telegramNotification?: BoolFieldUpdateOperationsInput | boolean
	}

	export type AccountCreateInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountCreateManyInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type DeliveryAddressCreateInput = {
		id?: string
		city: string
		street: string
		house: string
		flat: string
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutDeliveryAdressesInput
	}

	export type DeliveryAddressUncheckedCreateInput = {
		id?: string
		accountId: string
		city: string
		street: string
		house: string
		flat: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type DeliveryAddressUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutDeliveryAdressesNestedInput
	}

	export type DeliveryAddressUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type DeliveryAddressCreateManyInput = {
		id?: string
		accountId: string
		city: string
		street: string
		house: string
		flat: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type DeliveryAddressUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type DeliveryAddressUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderCreateInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		createdAt?: Date | string
		updatedAt?: Date | string
		items?: OrderItemCreateNestedManyWithoutOrderInput
		account?: AccountCreateNestedOneWithoutOrdersInput
	}

	export type OrderUncheckedCreateInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		accountId?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
	}

	export type OrderUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		items?: OrderItemUpdateManyWithoutOrderNestedInput
		account?: AccountUpdateOneWithoutOrdersNestedInput
	}

	export type OrderUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		accountId?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
	}

	export type OrderCreateManyInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		accountId?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		accountId?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemCreateInput = {
		id?: string
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		order?: OrderCreateNestedOneWithoutItemsInput
		product: ProductCreateNestedOneWithoutOrderItemInput
	}

	export type OrderItemUncheckedCreateInput = {
		id?: string
		orderId?: string | null
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderItemUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		order?: OrderUpdateOneWithoutItemsNestedInput
		product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
	}

	export type OrderItemUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemCreateManyInput = {
		id?: string
		orderId?: string | null
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderItemUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCommentCreateInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		createdAt?: Date | string
		updatedAt?: Date | string
		parent?: ProductCommentCreateNestedOneWithoutRepliesInput
		replies?: ProductCommentCreateNestedManyWithoutParentInput
		product: ProductCreateNestedOneWithoutCommentsInput
		account: AccountCreateNestedOneWithoutProductCommentsInput
	}

	export type ProductCommentUncheckedCreateInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		replies?: ProductCommentUncheckedCreateNestedManyWithoutParentInput
	}

	export type ProductCommentUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		parent?: ProductCommentUpdateOneWithoutRepliesNestedInput
		replies?: ProductCommentUpdateManyWithoutParentNestedInput
		product?: ProductUpdateOneRequiredWithoutCommentsNestedInput
		account?: AccountUpdateOneRequiredWithoutProductCommentsNestedInput
	}

	export type ProductCommentUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		replies?: ProductCommentUncheckedUpdateManyWithoutParentNestedInput
	}

	export type ProductCommentCreateManyInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductCommentUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCommentUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCreateInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		author: AccountCreateNestedOneWithoutPostsInput
		comments?: PostCommentCreateNestedManyWithoutPostInput
		likes?: PostLikeCreateNestedManyWithoutPostInput
	}

	export type PostUncheckedCreateInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		authorId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
		likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
	}

	export type PostUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		author?: AccountUpdateOneRequiredWithoutPostsNestedInput
		comments?: PostCommentUpdateManyWithoutPostNestedInput
		likes?: PostLikeUpdateManyWithoutPostNestedInput
	}

	export type PostUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		authorId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
		likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
	}

	export type PostCreateManyInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		authorId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		authorId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentCreateInput = {
		id?: string
		comment: string
		createdAt?: Date | string
		updatedAt?: Date | string
		author: AccountCreateNestedOneWithoutPostCommentsInput
		post: PostCreateNestedOneWithoutCommentsInput
	}

	export type PostCommentUncheckedCreateInput = {
		id?: string
		comment: string
		authorId: string
		postId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCommentUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		author?: AccountUpdateOneRequiredWithoutPostCommentsNestedInput
		post?: PostUpdateOneRequiredWithoutCommentsNestedInput
	}

	export type PostCommentUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		authorId?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentCreateManyInput = {
		id?: string
		comment: string
		authorId: string
		postId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCommentUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		authorId?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		post: PostCreateNestedOneWithoutLikesInput
		account: AccountCreateNestedOneWithoutPostLikesInput
	}

	export type PostLikeUncheckedCreateInput = {
		id?: string
		postId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostLikeUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		post?: PostUpdateOneRequiredWithoutLikesNestedInput
		account?: AccountUpdateOneRequiredWithoutPostLikesNestedInput
	}

	export type PostLikeUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeCreateManyInput = {
		id?: string
		postId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostLikeUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type TokenCreateInput = {
		id?: string
		token: string
		type: $Enums.TokenTypes
		expiresIn: Date | string
		createdAt?: Date | string
		updatedAt?: Date | string
		account?: AccountCreateNestedOneWithoutTokensInput
	}

	export type TokenUncheckedCreateInput = {
		id?: string
		token: string
		type: $Enums.TokenTypes
		accountId: string
		expiresIn: Date | string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type TokenUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneWithoutTokensNestedInput
	}

	export type TokenUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		accountId?: StringFieldUpdateOperationsInput | string
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type TokenCreateManyInput = {
		id?: string
		token: string
		type: $Enums.TokenTypes
		accountId: string
		expiresIn: Date | string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type TokenUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type TokenUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		accountId?: StringFieldUpdateOperationsInput | string
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type NotificationCreateInput = {
		id?: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		account?: AccountCreateNestedOneWithoutNotificationsInput
	}

	export type NotificationUncheckedCreateInput = {
		id?: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead?: boolean
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type NotificationUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneWithoutNotificationsNestedInput
	}

	export type NotificationUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type NotificationCreateManyInput = {
		id?: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead?: boolean
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type NotificationUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type NotificationUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageCreateInput = {
		id?: string
		message: string
		createdAt?: Date | string
		updatedAt?: Date | string
		sender: AccountCreateNestedOneWithoutSentMessagesInput
		receiver: AccountCreateNestedOneWithoutReceivedMessagesInput
	}

	export type SupportMessageUncheckedCreateInput = {
		id?: string
		message: string
		senderId: string
		receiverId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type SupportMessageUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		sender?: AccountUpdateOneRequiredWithoutSentMessagesNestedInput
		receiver?: AccountUpdateOneRequiredWithoutReceivedMessagesNestedInput
	}

	export type SupportMessageUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		senderId?: StringFieldUpdateOperationsInput | string
		receiverId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageCreateManyInput = {
		id?: string
		message: string
		senderId: string
		receiverId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type SupportMessageUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		senderId?: StringFieldUpdateOperationsInput | string
		receiverId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyLevelCreateInput = {
		id?: string
		name: string
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery?: boolean
		hasPersonalManager?: boolean
		hasExclusiveAccess?: boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		accountLoyalties?: AccountLoyaltyCreateNestedManyWithoutLoyaltyLevelInput
	}

	export type LoyaltyLevelUncheckedCreateInput = {
		id?: string
		name: string
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery?: boolean
		hasPersonalManager?: boolean
		hasExclusiveAccess?: boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		accountLoyalties?: AccountLoyaltyUncheckedCreateNestedManyWithoutLoyaltyLevelInput
	}

	export type LoyaltyLevelUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		minPoints?: IntFieldUpdateOperationsInput | number
		bonusPercentage?: FloatFieldUpdateOperationsInput | number
		hasPriorityDelivery?: BoolFieldUpdateOperationsInput | boolean
		hasPersonalManager?: BoolFieldUpdateOperationsInput | boolean
		hasExclusiveAccess?: BoolFieldUpdateOperationsInput | boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountLoyalties?: AccountLoyaltyUpdateManyWithoutLoyaltyLevelNestedInput
	}

	export type LoyaltyLevelUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		minPoints?: IntFieldUpdateOperationsInput | number
		bonusPercentage?: FloatFieldUpdateOperationsInput | number
		hasPriorityDelivery?: BoolFieldUpdateOperationsInput | boolean
		hasPersonalManager?: BoolFieldUpdateOperationsInput | boolean
		hasExclusiveAccess?: BoolFieldUpdateOperationsInput | boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountLoyalties?: AccountLoyaltyUncheckedUpdateManyWithoutLoyaltyLevelNestedInput
	}

	export type LoyaltyLevelCreateManyInput = {
		id?: string
		name: string
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery?: boolean
		hasPersonalManager?: boolean
		hasExclusiveAccess?: boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type LoyaltyLevelUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		minPoints?: IntFieldUpdateOperationsInput | number
		bonusPercentage?: FloatFieldUpdateOperationsInput | number
		hasPriorityDelivery?: BoolFieldUpdateOperationsInput | boolean
		hasPersonalManager?: BoolFieldUpdateOperationsInput | boolean
		hasExclusiveAccess?: BoolFieldUpdateOperationsInput | boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyLevelUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		minPoints?: IntFieldUpdateOperationsInput | number
		bonusPercentage?: FloatFieldUpdateOperationsInput | number
		hasPriorityDelivery?: BoolFieldUpdateOperationsInput | boolean
		hasPersonalManager?: BoolFieldUpdateOperationsInput | boolean
		hasExclusiveAccess?: BoolFieldUpdateOperationsInput | boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountLoyaltyCreateInput = {
		id?: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutAccountLoyaltyInput
		loyaltyLevel: LoyaltyLevelCreateNestedOneWithoutAccountLoyaltiesInput
		transactions?: LoyaltyTransactionCreateNestedManyWithoutAccountLoyaltyInput
	}

	export type AccountLoyaltyUncheckedCreateInput = {
		id?: string
		accountId: string
		loyaltyLevelId: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutAccountLoyaltyInput
	}

	export type AccountLoyaltyUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutAccountLoyaltyNestedInput
		loyaltyLevel?: LoyaltyLevelUpdateOneRequiredWithoutAccountLoyaltiesNestedInput
		transactions?: LoyaltyTransactionUpdateManyWithoutAccountLoyaltyNestedInput
	}

	export type AccountLoyaltyUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		loyaltyLevelId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutAccountLoyaltyNestedInput
	}

	export type AccountLoyaltyCreateManyInput = {
		id?: string
		accountId: string
		loyaltyLevelId: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountLoyaltyUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountLoyaltyUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		loyaltyLevelId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionCreateInput = {
		id?: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId?: string | null
		description?: string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		accountLoyalty: AccountLoyaltyCreateNestedOneWithoutTransactionsInput
	}

	export type LoyaltyTransactionUncheckedCreateInput = {
		id?: string
		accountLoyaltyId: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId?: string | null
		description?: string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
	}

	export type LoyaltyTransactionUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountLoyalty?: AccountLoyaltyUpdateOneRequiredWithoutTransactionsNestedInput
	}

	export type LoyaltyTransactionUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountLoyaltyId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionCreateManyInput = {
		id?: string
		accountLoyaltyId: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId?: string | null
		description?: string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
	}

	export type LoyaltyTransactionUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountLoyaltyId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type StringFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel>
		in?: string[] | ListStringFieldRefInput<$PrismaModel>
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		mode?: QueryMode
		not?: NestedStringFilter<$PrismaModel> | string
	}

	export type EnumRoleNameFilter<$PrismaModel = never> = {
		equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
		in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
	}

	export type AccountRoleListRelationFilter = {
		every?: AccountRoleWhereInput
		some?: AccountRoleWhereInput
		none?: AccountRoleWhereInput
	}

	export type AccountRoleOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type RoleCountOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
	}

	export type RoleMaxOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
	}

	export type RoleMinOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
	}

	export type StringWithAggregatesFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel>
		in?: string[] | ListStringFieldRefInput<$PrismaModel>
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		mode?: QueryMode
		not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedStringFilter<$PrismaModel>
		_max?: NestedStringFilter<$PrismaModel>
	}

	export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
		in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumRoleNameFilter<$PrismaModel>
		_max?: NestedEnumRoleNameFilter<$PrismaModel>
	}

	export type DateTimeFilter<$PrismaModel = never> = {
		equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		not?: NestedDateTimeFilter<$PrismaModel> | Date | string
	}

	export type AccountScalarRelationFilter = {
		is?: AccountWhereInput
		isNot?: AccountWhereInput
	}

	export type RoleScalarRelationFilter = {
		is?: RoleWhereInput
		isNot?: RoleWhereInput
	}

	export type AccountRoleCountOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		roleId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountRoleMaxOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		roleId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountRoleMinOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		roleId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedDateTimeFilter<$PrismaModel>
		_max?: NestedDateTimeFilter<$PrismaModel>
	}

	export type IntFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel>
		in?: number[] | ListIntFieldRefInput<$PrismaModel>
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntFilter<$PrismaModel> | number
	}

	export type ProductScalarRelationFilter = {
		is?: ProductWhereInput
		isNot?: ProductWhereInput
	}

	export type CartCountOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		productId?: SortOrder
		quantity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type CartAvgOrderByAggregateInput = {
		quantity?: SortOrder
	}

	export type CartMaxOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		productId?: SortOrder
		quantity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type CartMinOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		productId?: SortOrder
		quantity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type CartSumOrderByAggregateInput = {
		quantity?: SortOrder
	}

	export type IntWithAggregatesFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel>
		in?: number[] | ListIntFieldRefInput<$PrismaModel>
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
		_count?: NestedIntFilter<$PrismaModel>
		_avg?: NestedFloatFilter<$PrismaModel>
		_sum?: NestedIntFilter<$PrismaModel>
		_min?: NestedIntFilter<$PrismaModel>
		_max?: NestedIntFilter<$PrismaModel>
	}

	export type StringNullableFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel> | null
		in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		mode?: QueryMode
		not?: NestedStringNullableFilter<$PrismaModel> | string | null
	}

	export type ProductListRelationFilter = {
		every?: ProductWhereInput
		some?: ProductWhereInput
		none?: ProductWhereInput
	}

	export type SortOrderInput = {
		sort: SortOrder
		nulls?: NullsOrder
	}

	export type ProductOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type CategoryCountOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type CategoryMaxOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type CategoryMinOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel> | null
		in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		mode?: QueryMode
		not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
		_count?: NestedIntNullableFilter<$PrismaModel>
		_min?: NestedStringNullableFilter<$PrismaModel>
		_max?: NestedStringNullableFilter<$PrismaModel>
	}

	export type ProductIngredientsListRelationFilter = {
		every?: ProductIngredientsWhereInput
		some?: ProductIngredientsWhereInput
		none?: ProductIngredientsWhereInput
	}

	export type ProductIngredientsOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type IngredientCountOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type IngredientMaxOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type IngredientMinOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		imageUrl?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type IngredientScalarRelationFilter = {
		is?: IngredientWhereInput
		isNot?: IngredientWhereInput
	}

	export type ProductIngredientsCountOrderByAggregateInput = {
		id?: SortOrder
		productId?: SortOrder
		ingredientId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductIngredientsMaxOrderByAggregateInput = {
		id?: SortOrder
		productId?: SortOrder
		ingredientId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductIngredientsMinOrderByAggregateInput = {
		id?: SortOrder
		productId?: SortOrder
		ingredientId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type FloatFilter<$PrismaModel = never> = {
		equals?: number | FloatFieldRefInput<$PrismaModel>
		in?: number[] | ListFloatFieldRefInput<$PrismaModel>
		notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
		lt?: number | FloatFieldRefInput<$PrismaModel>
		lte?: number | FloatFieldRefInput<$PrismaModel>
		gt?: number | FloatFieldRefInput<$PrismaModel>
		gte?: number | FloatFieldRefInput<$PrismaModel>
		not?: NestedFloatFilter<$PrismaModel> | number
	}

	export type BoolFilter<$PrismaModel = never> = {
		equals?: boolean | BooleanFieldRefInput<$PrismaModel>
		not?: NestedBoolFilter<$PrismaModel> | boolean
	}

	export type CategoryScalarRelationFilter = {
		is?: CategoryWhereInput
		isNot?: CategoryWhereInput
	}

	export type CartListRelationFilter = {
		every?: CartWhereInput
		some?: CartWhereInput
		none?: CartWhereInput
	}

	export type FavoriteListRelationFilter = {
		every?: FavoriteWhereInput
		some?: FavoriteWhereInput
		none?: FavoriteWhereInput
	}

	export type OrderItemListRelationFilter = {
		every?: OrderItemWhereInput
		some?: OrderItemWhereInput
		none?: OrderItemWhereInput
	}

	export type ProductCommentListRelationFilter = {
		every?: ProductCommentWhereInput
		some?: ProductCommentWhereInput
		none?: ProductCommentWhereInput
	}

	export type CartOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type FavoriteOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type OrderItemOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ProductCommentOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ProductCountOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrder
		weight?: SortOrder
		imageUrl?: SortOrder
		price?: SortOrder
		onSale?: SortOrder
		categoryId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductAvgOrderByAggregateInput = {
		weight?: SortOrder
		price?: SortOrder
	}

	export type ProductMaxOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrder
		weight?: SortOrder
		imageUrl?: SortOrder
		price?: SortOrder
		onSale?: SortOrder
		categoryId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductMinOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrder
		weight?: SortOrder
		imageUrl?: SortOrder
		price?: SortOrder
		onSale?: SortOrder
		categoryId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductSumOrderByAggregateInput = {
		weight?: SortOrder
		price?: SortOrder
	}

	export type FloatWithAggregatesFilter<$PrismaModel = never> = {
		equals?: number | FloatFieldRefInput<$PrismaModel>
		in?: number[] | ListFloatFieldRefInput<$PrismaModel>
		notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
		lt?: number | FloatFieldRefInput<$PrismaModel>
		lte?: number | FloatFieldRefInput<$PrismaModel>
		gt?: number | FloatFieldRefInput<$PrismaModel>
		gte?: number | FloatFieldRefInput<$PrismaModel>
		not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
		_count?: NestedIntFilter<$PrismaModel>
		_avg?: NestedFloatFilter<$PrismaModel>
		_sum?: NestedFloatFilter<$PrismaModel>
		_min?: NestedFloatFilter<$PrismaModel>
		_max?: NestedFloatFilter<$PrismaModel>
	}

	export type BoolWithAggregatesFilter<$PrismaModel = never> = {
		equals?: boolean | BooleanFieldRefInput<$PrismaModel>
		not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedBoolFilter<$PrismaModel>
		_max?: NestedBoolFilter<$PrismaModel>
	}

	export type FavoriteAccountIdProductIdCompoundUniqueInput = {
		accountId: string
		productId: string
	}

	export type FavoriteCountOrderByAggregateInput = {
		id?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type FavoriteMaxOrderByAggregateInput = {
		id?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type FavoriteMinOrderByAggregateInput = {
		id?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountSettingsCountOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		telegramId?: SortOrder
		isVerifiedEmail?: SortOrder
		isTwoFactorEmailEnabled?: SortOrder
		isTwoFactorTotpEnabled?: SortOrder
		totpSecret?: SortOrder
		siteNotification?: SortOrder
		telegramNotification?: SortOrder
	}

	export type AccountSettingsMaxOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		telegramId?: SortOrder
		isVerifiedEmail?: SortOrder
		isTwoFactorEmailEnabled?: SortOrder
		isTwoFactorTotpEnabled?: SortOrder
		totpSecret?: SortOrder
		siteNotification?: SortOrder
		telegramNotification?: SortOrder
	}

	export type AccountSettingsMinOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		telegramId?: SortOrder
		isVerifiedEmail?: SortOrder
		isTwoFactorEmailEnabled?: SortOrder
		isTwoFactorTotpEnabled?: SortOrder
		totpSecret?: SortOrder
		siteNotification?: SortOrder
		telegramNotification?: SortOrder
	}

	export type OrderListRelationFilter = {
		every?: OrderWhereInput
		some?: OrderWhereInput
		none?: OrderWhereInput
	}

	export type DeliveryAddressListRelationFilter = {
		every?: DeliveryAddressWhereInput
		some?: DeliveryAddressWhereInput
		none?: DeliveryAddressWhereInput
	}

	export type NotificationListRelationFilter = {
		every?: NotificationWhereInput
		some?: NotificationWhereInput
		none?: NotificationWhereInput
	}

	export type PostListRelationFilter = {
		every?: PostWhereInput
		some?: PostWhereInput
		none?: PostWhereInput
	}

	export type PostCommentListRelationFilter = {
		every?: PostCommentWhereInput
		some?: PostCommentWhereInput
		none?: PostCommentWhereInput
	}

	export type PostLikeListRelationFilter = {
		every?: PostLikeWhereInput
		some?: PostLikeWhereInput
		none?: PostLikeWhereInput
	}

	export type TokenListRelationFilter = {
		every?: TokenWhereInput
		some?: TokenWhereInput
		none?: TokenWhereInput
	}

	export type AccountSettingsNullableScalarRelationFilter = {
		is?: AccountSettingsWhereInput | null
		isNot?: AccountSettingsWhereInput | null
	}

	export type AccountLoyaltyNullableScalarRelationFilter = {
		is?: AccountLoyaltyWhereInput | null
		isNot?: AccountLoyaltyWhereInput | null
	}

	export type SupportMessageListRelationFilter = {
		every?: SupportMessageWhereInput
		some?: SupportMessageWhereInput
		none?: SupportMessageWhereInput
	}

	export type OrderOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type DeliveryAddressOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type NotificationOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type PostOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type PostCommentOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type PostLikeOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type TokenOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type SupportMessageOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type AccountCountOrderByAggregateInput = {
		id?: SortOrder
		email?: SortOrder
		password?: SortOrder
		userName?: SortOrder
		picture?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountMaxOrderByAggregateInput = {
		id?: SortOrder
		email?: SortOrder
		password?: SortOrder
		userName?: SortOrder
		picture?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountMinOrderByAggregateInput = {
		id?: SortOrder
		email?: SortOrder
		password?: SortOrder
		userName?: SortOrder
		picture?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type DeliveryAddressCountOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		city?: SortOrder
		street?: SortOrder
		house?: SortOrder
		flat?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type DeliveryAddressMaxOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		city?: SortOrder
		street?: SortOrder
		house?: SortOrder
		flat?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type DeliveryAddressMinOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		city?: SortOrder
		street?: SortOrder
		house?: SortOrder
		flat?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type EnumOrderStatusFilter<$PrismaModel = never> = {
		equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
		in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
	}
	export type JsonNullableFilter<$PrismaModel = never> =
		| PatchUndefined<
				Either<
					Required<JsonNullableFilterBase<$PrismaModel>>,
					Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
				>,
				Required<JsonNullableFilterBase<$PrismaModel>>
		  >
		| OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

	export type JsonNullableFilterBase<$PrismaModel = never> = {
		equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
		path?: string[]
		mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
		string_contains?: string | StringFieldRefInput<$PrismaModel>
		string_starts_with?: string | StringFieldRefInput<$PrismaModel>
		string_ends_with?: string | StringFieldRefInput<$PrismaModel>
		array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
	}

	export type EnumDeliveryTypeFilter<$PrismaModel = never> = {
		equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
		in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumDeliveryTypeFilter<$PrismaModel> | $Enums.DeliveryType
	}

	export type EnumPaymentMethodFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
	}

	export type EnumPaymentStatusFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
	}

	export type AccountNullableScalarRelationFilter = {
		is?: AccountWhereInput | null
		isNot?: AccountWhereInput | null
	}

	export type OrderCountOrderByAggregateInput = {
		id?: SortOrder
		status?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		phone?: SortOrder
		email?: SortOrder
		deliveryAddressId?: SortOrder
		deliveryAddress?: SortOrder
		deliveryType?: SortOrder
		paymentMethod?: SortOrder
		paymentStatus?: SortOrder
		comment?: SortOrder
		total?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type OrderAvgOrderByAggregateInput = {
		total?: SortOrder
	}

	export type OrderMaxOrderByAggregateInput = {
		id?: SortOrder
		status?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		phone?: SortOrder
		email?: SortOrder
		deliveryAddressId?: SortOrder
		deliveryType?: SortOrder
		paymentMethod?: SortOrder
		paymentStatus?: SortOrder
		comment?: SortOrder
		total?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type OrderMinOrderByAggregateInput = {
		id?: SortOrder
		status?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		phone?: SortOrder
		email?: SortOrder
		deliveryAddressId?: SortOrder
		deliveryType?: SortOrder
		paymentMethod?: SortOrder
		paymentStatus?: SortOrder
		comment?: SortOrder
		total?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type OrderSumOrderByAggregateInput = {
		total?: SortOrder
	}

	export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
		in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumOrderStatusFilter<$PrismaModel>
		_max?: NestedEnumOrderStatusFilter<$PrismaModel>
	}
	export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
		| PatchUndefined<
				Either<
					Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
					Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
				>,
				Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
		  >
		| OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

	export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
		equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
		path?: string[]
		mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
		string_contains?: string | StringFieldRefInput<$PrismaModel>
		string_starts_with?: string | StringFieldRefInput<$PrismaModel>
		string_ends_with?: string | StringFieldRefInput<$PrismaModel>
		array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
		_count?: NestedIntNullableFilter<$PrismaModel>
		_min?: NestedJsonNullableFilter<$PrismaModel>
		_max?: NestedJsonNullableFilter<$PrismaModel>
	}

	export type EnumDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
		in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryType
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumDeliveryTypeFilter<$PrismaModel>
		_max?: NestedEnumDeliveryTypeFilter<$PrismaModel>
	}

	export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumPaymentMethodFilter<$PrismaModel>
		_max?: NestedEnumPaymentMethodFilter<$PrismaModel>
	}

	export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumPaymentStatusFilter<$PrismaModel>
		_max?: NestedEnumPaymentStatusFilter<$PrismaModel>
	}

	export type OrderNullableScalarRelationFilter = {
		is?: OrderWhereInput | null
		isNot?: OrderWhereInput | null
	}

	export type OrderItemCountOrderByAggregateInput = {
		id?: SortOrder
		orderId?: SortOrder
		quantity?: SortOrder
		price?: SortOrder
		productTitle?: SortOrder
		productDescription?: SortOrder
		productImageUrl?: SortOrder
		productId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type OrderItemAvgOrderByAggregateInput = {
		quantity?: SortOrder
		price?: SortOrder
	}

	export type OrderItemMaxOrderByAggregateInput = {
		id?: SortOrder
		orderId?: SortOrder
		quantity?: SortOrder
		price?: SortOrder
		productTitle?: SortOrder
		productDescription?: SortOrder
		productImageUrl?: SortOrder
		productId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type OrderItemMinOrderByAggregateInput = {
		id?: SortOrder
		orderId?: SortOrder
		quantity?: SortOrder
		price?: SortOrder
		productTitle?: SortOrder
		productDescription?: SortOrder
		productImageUrl?: SortOrder
		productId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type OrderItemSumOrderByAggregateInput = {
		quantity?: SortOrder
		price?: SortOrder
	}

	export type IntNullableFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel> | null
		in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntNullableFilter<$PrismaModel> | number | null
	}

	export type ProductCommentNullableScalarRelationFilter = {
		is?: ProductCommentWhereInput | null
		isNot?: ProductCommentWhereInput | null
	}

	export type ProductCommentCountOrderByAggregateInput = {
		id?: SortOrder
		comment?: SortOrder
		rating?: SortOrder
		parentId?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductCommentAvgOrderByAggregateInput = {
		rating?: SortOrder
	}

	export type ProductCommentMaxOrderByAggregateInput = {
		id?: SortOrder
		comment?: SortOrder
		rating?: SortOrder
		parentId?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductCommentMinOrderByAggregateInput = {
		id?: SortOrder
		comment?: SortOrder
		rating?: SortOrder
		parentId?: SortOrder
		productId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type ProductCommentSumOrderByAggregateInput = {
		rating?: SortOrder
	}

	export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel> | null
		in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
		_count?: NestedIntNullableFilter<$PrismaModel>
		_avg?: NestedFloatNullableFilter<$PrismaModel>
		_sum?: NestedIntNullableFilter<$PrismaModel>
		_min?: NestedIntNullableFilter<$PrismaModel>
		_max?: NestedIntNullableFilter<$PrismaModel>
	}

	export type PostCountOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrder
		imageUrl?: SortOrder
		published?: SortOrder
		authorId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostMaxOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrder
		imageUrl?: SortOrder
		published?: SortOrder
		authorId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostMinOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		description?: SortOrder
		imageUrl?: SortOrder
		published?: SortOrder
		authorId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostScalarRelationFilter = {
		is?: PostWhereInput
		isNot?: PostWhereInput
	}

	export type PostCommentCountOrderByAggregateInput = {
		id?: SortOrder
		comment?: SortOrder
		authorId?: SortOrder
		postId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostCommentMaxOrderByAggregateInput = {
		id?: SortOrder
		comment?: SortOrder
		authorId?: SortOrder
		postId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostCommentMinOrderByAggregateInput = {
		id?: SortOrder
		comment?: SortOrder
		authorId?: SortOrder
		postId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostLikePostIdAccountIdCompoundUniqueInput = {
		postId: string
		accountId: string
	}

	export type PostLikeCountOrderByAggregateInput = {
		id?: SortOrder
		postId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostLikeMaxOrderByAggregateInput = {
		id?: SortOrder
		postId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type PostLikeMinOrderByAggregateInput = {
		id?: SortOrder
		postId?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type EnumTokenTypesFilter<$PrismaModel = never> = {
		equals?: $Enums.TokenTypes | EnumTokenTypesFieldRefInput<$PrismaModel>
		in?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		notIn?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		not?: NestedEnumTokenTypesFilter<$PrismaModel> | $Enums.TokenTypes
	}

	export type TokenCountOrderByAggregateInput = {
		id?: SortOrder
		token?: SortOrder
		type?: SortOrder
		accountId?: SortOrder
		expiresIn?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type TokenMaxOrderByAggregateInput = {
		id?: SortOrder
		token?: SortOrder
		type?: SortOrder
		accountId?: SortOrder
		expiresIn?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type TokenMinOrderByAggregateInput = {
		id?: SortOrder
		token?: SortOrder
		type?: SortOrder
		accountId?: SortOrder
		expiresIn?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type EnumTokenTypesWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.TokenTypes | EnumTokenTypesFieldRefInput<$PrismaModel>
		in?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		notIn?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		not?: NestedEnumTokenTypesWithAggregatesFilter<$PrismaModel> | $Enums.TokenTypes
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumTokenTypesFilter<$PrismaModel>
		_max?: NestedEnumTokenTypesFilter<$PrismaModel>
	}

	export type EnumNotificationTypeFilter<$PrismaModel = never> = {
		equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
		in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
	}

	export type NotificationCountOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		message?: SortOrder
		link?: SortOrder
		type?: SortOrder
		isRead?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type NotificationMaxOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		message?: SortOrder
		link?: SortOrder
		type?: SortOrder
		isRead?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type NotificationMinOrderByAggregateInput = {
		id?: SortOrder
		title?: SortOrder
		message?: SortOrder
		link?: SortOrder
		type?: SortOrder
		isRead?: SortOrder
		accountId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
		in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumNotificationTypeFilter<$PrismaModel>
		_max?: NestedEnumNotificationTypeFilter<$PrismaModel>
	}

	export type SupportMessageCountOrderByAggregateInput = {
		id?: SortOrder
		message?: SortOrder
		senderId?: SortOrder
		receiverId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type SupportMessageMaxOrderByAggregateInput = {
		id?: SortOrder
		message?: SortOrder
		senderId?: SortOrder
		receiverId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type SupportMessageMinOrderByAggregateInput = {
		id?: SortOrder
		message?: SortOrder
		senderId?: SortOrder
		receiverId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountLoyaltyListRelationFilter = {
		every?: AccountLoyaltyWhereInput
		some?: AccountLoyaltyWhereInput
		none?: AccountLoyaltyWhereInput
	}

	export type AccountLoyaltyOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type LoyaltyLevelCountOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
		hasPriorityDelivery?: SortOrder
		hasPersonalManager?: SortOrder
		hasExclusiveAccess?: SortOrder
		additionalBenefits?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type LoyaltyLevelAvgOrderByAggregateInput = {
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
	}

	export type LoyaltyLevelMaxOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
		hasPriorityDelivery?: SortOrder
		hasPersonalManager?: SortOrder
		hasExclusiveAccess?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type LoyaltyLevelMinOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
		hasPriorityDelivery?: SortOrder
		hasPersonalManager?: SortOrder
		hasExclusiveAccess?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type LoyaltyLevelSumOrderByAggregateInput = {
		minPoints?: SortOrder
		bonusPercentage?: SortOrder
	}

	export type LoyaltyLevelScalarRelationFilter = {
		is?: LoyaltyLevelWhereInput
		isNot?: LoyaltyLevelWhereInput
	}

	export type LoyaltyTransactionListRelationFilter = {
		every?: LoyaltyTransactionWhereInput
		some?: LoyaltyTransactionWhereInput
		none?: LoyaltyTransactionWhereInput
	}

	export type LoyaltyTransactionOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type AccountLoyaltyCountOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		loyaltyLevelId?: SortOrder
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
		lastActivity?: SortOrder
		achievements?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountLoyaltyAvgOrderByAggregateInput = {
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
	}

	export type AccountLoyaltyMaxOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		loyaltyLevelId?: SortOrder
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
		lastActivity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountLoyaltyMinOrderByAggregateInput = {
		id?: SortOrder
		accountId?: SortOrder
		loyaltyLevelId?: SortOrder
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
		lastActivity?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
	}

	export type AccountLoyaltySumOrderByAggregateInput = {
		points?: SortOrder
		totalSpent?: SortOrder
		ordersCount?: SortOrder
	}

	export type EnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
		equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
	}

	export type AccountLoyaltyScalarRelationFilter = {
		is?: AccountLoyaltyWhereInput
		isNot?: AccountLoyaltyWhereInput
	}

	export type LoyaltyTransactionCountOrderByAggregateInput = {
		id?: SortOrder
		accountLoyaltyId?: SortOrder
		points?: SortOrder
		type?: SortOrder
		orderId?: SortOrder
		description?: SortOrder
		metadata?: SortOrder
		createdAt?: SortOrder
	}

	export type LoyaltyTransactionAvgOrderByAggregateInput = {
		points?: SortOrder
	}

	export type LoyaltyTransactionMaxOrderByAggregateInput = {
		id?: SortOrder
		accountLoyaltyId?: SortOrder
		points?: SortOrder
		type?: SortOrder
		orderId?: SortOrder
		description?: SortOrder
		createdAt?: SortOrder
	}

	export type LoyaltyTransactionMinOrderByAggregateInput = {
		id?: SortOrder
		accountLoyaltyId?: SortOrder
		points?: SortOrder
		type?: SortOrder
		orderId?: SortOrder
		description?: SortOrder
		createdAt?: SortOrder
	}

	export type LoyaltyTransactionSumOrderByAggregateInput = {
		points?: SortOrder
	}

	export type EnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
		_max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
	}

	export type AccountRoleCreateNestedManyWithoutRoleInput = {
		create?:
			| XOR<AccountRoleCreateWithoutRoleInput, AccountRoleUncheckedCreateWithoutRoleInput>
			| AccountRoleCreateWithoutRoleInput[]
			| AccountRoleUncheckedCreateWithoutRoleInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutRoleInput | AccountRoleCreateOrConnectWithoutRoleInput[]
		createMany?: AccountRoleCreateManyRoleInputEnvelope
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
	}

	export type AccountRoleUncheckedCreateNestedManyWithoutRoleInput = {
		create?:
			| XOR<AccountRoleCreateWithoutRoleInput, AccountRoleUncheckedCreateWithoutRoleInput>
			| AccountRoleCreateWithoutRoleInput[]
			| AccountRoleUncheckedCreateWithoutRoleInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutRoleInput | AccountRoleCreateOrConnectWithoutRoleInput[]
		createMany?: AccountRoleCreateManyRoleInputEnvelope
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
	}

	export type StringFieldUpdateOperationsInput = {
		set?: string
	}

	export type EnumRoleNameFieldUpdateOperationsInput = {
		set?: $Enums.RoleName
	}

	export type AccountRoleUpdateManyWithoutRoleNestedInput = {
		create?:
			| XOR<AccountRoleCreateWithoutRoleInput, AccountRoleUncheckedCreateWithoutRoleInput>
			| AccountRoleCreateWithoutRoleInput[]
			| AccountRoleUncheckedCreateWithoutRoleInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutRoleInput | AccountRoleCreateOrConnectWithoutRoleInput[]
		upsert?: AccountRoleUpsertWithWhereUniqueWithoutRoleInput | AccountRoleUpsertWithWhereUniqueWithoutRoleInput[]
		createMany?: AccountRoleCreateManyRoleInputEnvelope
		set?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		disconnect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		delete?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		update?: AccountRoleUpdateWithWhereUniqueWithoutRoleInput | AccountRoleUpdateWithWhereUniqueWithoutRoleInput[]
		updateMany?: AccountRoleUpdateManyWithWhereWithoutRoleInput | AccountRoleUpdateManyWithWhereWithoutRoleInput[]
		deleteMany?: AccountRoleScalarWhereInput | AccountRoleScalarWhereInput[]
	}

	export type AccountRoleUncheckedUpdateManyWithoutRoleNestedInput = {
		create?:
			| XOR<AccountRoleCreateWithoutRoleInput, AccountRoleUncheckedCreateWithoutRoleInput>
			| AccountRoleCreateWithoutRoleInput[]
			| AccountRoleUncheckedCreateWithoutRoleInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutRoleInput | AccountRoleCreateOrConnectWithoutRoleInput[]
		upsert?: AccountRoleUpsertWithWhereUniqueWithoutRoleInput | AccountRoleUpsertWithWhereUniqueWithoutRoleInput[]
		createMany?: AccountRoleCreateManyRoleInputEnvelope
		set?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		disconnect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		delete?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		update?: AccountRoleUpdateWithWhereUniqueWithoutRoleInput | AccountRoleUpdateWithWhereUniqueWithoutRoleInput[]
		updateMany?: AccountRoleUpdateManyWithWhereWithoutRoleInput | AccountRoleUpdateManyWithWhereWithoutRoleInput[]
		deleteMany?: AccountRoleScalarWhereInput | AccountRoleScalarWhereInput[]
	}

	export type AccountCreateNestedOneWithoutRolesInput = {
		create?: XOR<AccountCreateWithoutRolesInput, AccountUncheckedCreateWithoutRolesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutRolesInput
		connect?: AccountWhereUniqueInput
	}

	export type RoleCreateNestedOneWithoutAccountRolesInput = {
		create?: XOR<RoleCreateWithoutAccountRolesInput, RoleUncheckedCreateWithoutAccountRolesInput>
		connectOrCreate?: RoleCreateOrConnectWithoutAccountRolesInput
		connect?: RoleWhereUniqueInput
	}

	export type DateTimeFieldUpdateOperationsInput = {
		set?: Date | string
	}

	export type AccountUpdateOneRequiredWithoutRolesNestedInput = {
		create?: XOR<AccountCreateWithoutRolesInput, AccountUncheckedCreateWithoutRolesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutRolesInput
		upsert?: AccountUpsertWithoutRolesInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutRolesInput, AccountUpdateWithoutRolesInput>,
			AccountUncheckedUpdateWithoutRolesInput
		>
	}

	export type RoleUpdateOneRequiredWithoutAccountRolesNestedInput = {
		create?: XOR<RoleCreateWithoutAccountRolesInput, RoleUncheckedCreateWithoutAccountRolesInput>
		connectOrCreate?: RoleCreateOrConnectWithoutAccountRolesInput
		upsert?: RoleUpsertWithoutAccountRolesInput
		connect?: RoleWhereUniqueInput
		update?: XOR<
			XOR<RoleUpdateToOneWithWhereWithoutAccountRolesInput, RoleUpdateWithoutAccountRolesInput>,
			RoleUncheckedUpdateWithoutAccountRolesInput
		>
	}

	export type AccountCreateNestedOneWithoutCartInput = {
		create?: XOR<AccountCreateWithoutCartInput, AccountUncheckedCreateWithoutCartInput>
		connectOrCreate?: AccountCreateOrConnectWithoutCartInput
		connect?: AccountWhereUniqueInput
	}

	export type ProductCreateNestedOneWithoutCartInput = {
		create?: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
		connectOrCreate?: ProductCreateOrConnectWithoutCartInput
		connect?: ProductWhereUniqueInput
	}

	export type IntFieldUpdateOperationsInput = {
		set?: number
		increment?: number
		decrement?: number
		multiply?: number
		divide?: number
	}

	export type AccountUpdateOneRequiredWithoutCartNestedInput = {
		create?: XOR<AccountCreateWithoutCartInput, AccountUncheckedCreateWithoutCartInput>
		connectOrCreate?: AccountCreateOrConnectWithoutCartInput
		upsert?: AccountUpsertWithoutCartInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutCartInput, AccountUpdateWithoutCartInput>,
			AccountUncheckedUpdateWithoutCartInput
		>
	}

	export type ProductUpdateOneRequiredWithoutCartNestedInput = {
		create?: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
		connectOrCreate?: ProductCreateOrConnectWithoutCartInput
		upsert?: ProductUpsertWithoutCartInput
		connect?: ProductWhereUniqueInput
		update?: XOR<
			XOR<ProductUpdateToOneWithWhereWithoutCartInput, ProductUpdateWithoutCartInput>,
			ProductUncheckedUpdateWithoutCartInput
		>
	}

	export type ProductCreateNestedManyWithoutCategoryInput = {
		create?:
			| XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
			| ProductCreateWithoutCategoryInput[]
			| ProductUncheckedCreateWithoutCategoryInput[]
		connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
		createMany?: ProductCreateManyCategoryInputEnvelope
		connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
	}

	export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
		create?:
			| XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
			| ProductCreateWithoutCategoryInput[]
			| ProductUncheckedCreateWithoutCategoryInput[]
		connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
		createMany?: ProductCreateManyCategoryInputEnvelope
		connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
	}

	export type NullableStringFieldUpdateOperationsInput = {
		set?: string | null
	}

	export type ProductUpdateManyWithoutCategoryNestedInput = {
		create?:
			| XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
			| ProductCreateWithoutCategoryInput[]
			| ProductUncheckedCreateWithoutCategoryInput[]
		connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
		upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
		createMany?: ProductCreateManyCategoryInputEnvelope
		set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
		updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
		deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
	}

	export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
		create?:
			| XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
			| ProductCreateWithoutCategoryInput[]
			| ProductUncheckedCreateWithoutCategoryInput[]
		connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
		upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
		createMany?: ProductCreateManyCategoryInputEnvelope
		set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
		update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
		updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
		deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
	}

	export type ProductIngredientsCreateNestedManyWithoutIngredientInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutIngredientInput, ProductIngredientsUncheckedCreateWithoutIngredientInput>
			| ProductIngredientsCreateWithoutIngredientInput[]
			| ProductIngredientsUncheckedCreateWithoutIngredientInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutIngredientInput
			| ProductIngredientsCreateOrConnectWithoutIngredientInput[]
		createMany?: ProductIngredientsCreateManyIngredientInputEnvelope
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
	}

	export type ProductIngredientsUncheckedCreateNestedManyWithoutIngredientInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutIngredientInput, ProductIngredientsUncheckedCreateWithoutIngredientInput>
			| ProductIngredientsCreateWithoutIngredientInput[]
			| ProductIngredientsUncheckedCreateWithoutIngredientInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutIngredientInput
			| ProductIngredientsCreateOrConnectWithoutIngredientInput[]
		createMany?: ProductIngredientsCreateManyIngredientInputEnvelope
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
	}

	export type ProductIngredientsUpdateManyWithoutIngredientNestedInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutIngredientInput, ProductIngredientsUncheckedCreateWithoutIngredientInput>
			| ProductIngredientsCreateWithoutIngredientInput[]
			| ProductIngredientsUncheckedCreateWithoutIngredientInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutIngredientInput
			| ProductIngredientsCreateOrConnectWithoutIngredientInput[]
		upsert?:
			| ProductIngredientsUpsertWithWhereUniqueWithoutIngredientInput
			| ProductIngredientsUpsertWithWhereUniqueWithoutIngredientInput[]
		createMany?: ProductIngredientsCreateManyIngredientInputEnvelope
		set?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		disconnect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		delete?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		update?:
			| ProductIngredientsUpdateWithWhereUniqueWithoutIngredientInput
			| ProductIngredientsUpdateWithWhereUniqueWithoutIngredientInput[]
		updateMany?:
			| ProductIngredientsUpdateManyWithWhereWithoutIngredientInput
			| ProductIngredientsUpdateManyWithWhereWithoutIngredientInput[]
		deleteMany?: ProductIngredientsScalarWhereInput | ProductIngredientsScalarWhereInput[]
	}

	export type ProductIngredientsUncheckedUpdateManyWithoutIngredientNestedInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutIngredientInput, ProductIngredientsUncheckedCreateWithoutIngredientInput>
			| ProductIngredientsCreateWithoutIngredientInput[]
			| ProductIngredientsUncheckedCreateWithoutIngredientInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutIngredientInput
			| ProductIngredientsCreateOrConnectWithoutIngredientInput[]
		upsert?:
			| ProductIngredientsUpsertWithWhereUniqueWithoutIngredientInput
			| ProductIngredientsUpsertWithWhereUniqueWithoutIngredientInput[]
		createMany?: ProductIngredientsCreateManyIngredientInputEnvelope
		set?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		disconnect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		delete?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		update?:
			| ProductIngredientsUpdateWithWhereUniqueWithoutIngredientInput
			| ProductIngredientsUpdateWithWhereUniqueWithoutIngredientInput[]
		updateMany?:
			| ProductIngredientsUpdateManyWithWhereWithoutIngredientInput
			| ProductIngredientsUpdateManyWithWhereWithoutIngredientInput[]
		deleteMany?: ProductIngredientsScalarWhereInput | ProductIngredientsScalarWhereInput[]
	}

	export type ProductCreateNestedOneWithoutIngredientsInput = {
		create?: XOR<ProductCreateWithoutIngredientsInput, ProductUncheckedCreateWithoutIngredientsInput>
		connectOrCreate?: ProductCreateOrConnectWithoutIngredientsInput
		connect?: ProductWhereUniqueInput
	}

	export type IngredientCreateNestedOneWithoutProductIngredientsInput = {
		create?: XOR<IngredientCreateWithoutProductIngredientsInput, IngredientUncheckedCreateWithoutProductIngredientsInput>
		connectOrCreate?: IngredientCreateOrConnectWithoutProductIngredientsInput
		connect?: IngredientWhereUniqueInput
	}

	export type ProductUpdateOneRequiredWithoutIngredientsNestedInput = {
		create?: XOR<ProductCreateWithoutIngredientsInput, ProductUncheckedCreateWithoutIngredientsInput>
		connectOrCreate?: ProductCreateOrConnectWithoutIngredientsInput
		upsert?: ProductUpsertWithoutIngredientsInput
		connect?: ProductWhereUniqueInput
		update?: XOR<
			XOR<ProductUpdateToOneWithWhereWithoutIngredientsInput, ProductUpdateWithoutIngredientsInput>,
			ProductUncheckedUpdateWithoutIngredientsInput
		>
	}

	export type IngredientUpdateOneRequiredWithoutProductIngredientsNestedInput = {
		create?: XOR<IngredientCreateWithoutProductIngredientsInput, IngredientUncheckedCreateWithoutProductIngredientsInput>
		connectOrCreate?: IngredientCreateOrConnectWithoutProductIngredientsInput
		upsert?: IngredientUpsertWithoutProductIngredientsInput
		connect?: IngredientWhereUniqueInput
		update?: XOR<
			XOR<IngredientUpdateToOneWithWhereWithoutProductIngredientsInput, IngredientUpdateWithoutProductIngredientsInput>,
			IngredientUncheckedUpdateWithoutProductIngredientsInput
		>
	}

	export type CategoryCreateNestedOneWithoutProductsInput = {
		create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
		connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
		connect?: CategoryWhereUniqueInput
	}

	export type CartCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
			| CartCreateWithoutProductInput[]
			| CartUncheckedCreateWithoutProductInput[]
		connectOrCreate?: CartCreateOrConnectWithoutProductInput | CartCreateOrConnectWithoutProductInput[]
		createMany?: CartCreateManyProductInputEnvelope
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
	}

	export type FavoriteCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
			| FavoriteCreateWithoutProductInput[]
			| FavoriteUncheckedCreateWithoutProductInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
		createMany?: FavoriteCreateManyProductInputEnvelope
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
	}

	export type ProductIngredientsCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutProductInput, ProductIngredientsUncheckedCreateWithoutProductInput>
			| ProductIngredientsCreateWithoutProductInput[]
			| ProductIngredientsUncheckedCreateWithoutProductInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutProductInput
			| ProductIngredientsCreateOrConnectWithoutProductInput[]
		createMany?: ProductIngredientsCreateManyProductInputEnvelope
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
	}

	export type OrderItemCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
			| OrderItemCreateWithoutProductInput[]
			| OrderItemUncheckedCreateWithoutProductInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
		createMany?: OrderItemCreateManyProductInputEnvelope
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
	}

	export type ProductCommentCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<ProductCommentCreateWithoutProductInput, ProductCommentUncheckedCreateWithoutProductInput>
			| ProductCommentCreateWithoutProductInput[]
			| ProductCommentUncheckedCreateWithoutProductInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutProductInput | ProductCommentCreateOrConnectWithoutProductInput[]
		createMany?: ProductCommentCreateManyProductInputEnvelope
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
	}

	export type CartUncheckedCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
			| CartCreateWithoutProductInput[]
			| CartUncheckedCreateWithoutProductInput[]
		connectOrCreate?: CartCreateOrConnectWithoutProductInput | CartCreateOrConnectWithoutProductInput[]
		createMany?: CartCreateManyProductInputEnvelope
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
	}

	export type FavoriteUncheckedCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
			| FavoriteCreateWithoutProductInput[]
			| FavoriteUncheckedCreateWithoutProductInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
		createMany?: FavoriteCreateManyProductInputEnvelope
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
	}

	export type ProductIngredientsUncheckedCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutProductInput, ProductIngredientsUncheckedCreateWithoutProductInput>
			| ProductIngredientsCreateWithoutProductInput[]
			| ProductIngredientsUncheckedCreateWithoutProductInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutProductInput
			| ProductIngredientsCreateOrConnectWithoutProductInput[]
		createMany?: ProductIngredientsCreateManyProductInputEnvelope
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
	}

	export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
			| OrderItemCreateWithoutProductInput[]
			| OrderItemUncheckedCreateWithoutProductInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
		createMany?: OrderItemCreateManyProductInputEnvelope
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
	}

	export type ProductCommentUncheckedCreateNestedManyWithoutProductInput = {
		create?:
			| XOR<ProductCommentCreateWithoutProductInput, ProductCommentUncheckedCreateWithoutProductInput>
			| ProductCommentCreateWithoutProductInput[]
			| ProductCommentUncheckedCreateWithoutProductInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutProductInput | ProductCommentCreateOrConnectWithoutProductInput[]
		createMany?: ProductCommentCreateManyProductInputEnvelope
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
	}

	export type FloatFieldUpdateOperationsInput = {
		set?: number
		increment?: number
		decrement?: number
		multiply?: number
		divide?: number
	}

	export type BoolFieldUpdateOperationsInput = {
		set?: boolean
	}

	export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
		create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
		connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
		upsert?: CategoryUpsertWithoutProductsInput
		connect?: CategoryWhereUniqueInput
		update?: XOR<
			XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>,
			CategoryUncheckedUpdateWithoutProductsInput
		>
	}

	export type CartUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
			| CartCreateWithoutProductInput[]
			| CartUncheckedCreateWithoutProductInput[]
		connectOrCreate?: CartCreateOrConnectWithoutProductInput | CartCreateOrConnectWithoutProductInput[]
		upsert?: CartUpsertWithWhereUniqueWithoutProductInput | CartUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: CartCreateManyProductInputEnvelope
		set?: CartWhereUniqueInput | CartWhereUniqueInput[]
		disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		update?: CartUpdateWithWhereUniqueWithoutProductInput | CartUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: CartUpdateManyWithWhereWithoutProductInput | CartUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
	}

	export type FavoriteUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
			| FavoriteCreateWithoutProductInput[]
			| FavoriteUncheckedCreateWithoutProductInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
		upsert?: FavoriteUpsertWithWhereUniqueWithoutProductInput | FavoriteUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: FavoriteCreateManyProductInputEnvelope
		set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		update?: FavoriteUpdateWithWhereUniqueWithoutProductInput | FavoriteUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: FavoriteUpdateManyWithWhereWithoutProductInput | FavoriteUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
	}

	export type ProductIngredientsUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutProductInput, ProductIngredientsUncheckedCreateWithoutProductInput>
			| ProductIngredientsCreateWithoutProductInput[]
			| ProductIngredientsUncheckedCreateWithoutProductInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutProductInput
			| ProductIngredientsCreateOrConnectWithoutProductInput[]
		upsert?:
			| ProductIngredientsUpsertWithWhereUniqueWithoutProductInput
			| ProductIngredientsUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: ProductIngredientsCreateManyProductInputEnvelope
		set?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		disconnect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		delete?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		update?:
			| ProductIngredientsUpdateWithWhereUniqueWithoutProductInput
			| ProductIngredientsUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?:
			| ProductIngredientsUpdateManyWithWhereWithoutProductInput
			| ProductIngredientsUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: ProductIngredientsScalarWhereInput | ProductIngredientsScalarWhereInput[]
	}

	export type OrderItemUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
			| OrderItemCreateWithoutProductInput[]
			| OrderItemUncheckedCreateWithoutProductInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
		upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: OrderItemCreateManyProductInputEnvelope
		set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
	}

	export type ProductCommentUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<ProductCommentCreateWithoutProductInput, ProductCommentUncheckedCreateWithoutProductInput>
			| ProductCommentCreateWithoutProductInput[]
			| ProductCommentUncheckedCreateWithoutProductInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutProductInput | ProductCommentCreateOrConnectWithoutProductInput[]
		upsert?: ProductCommentUpsertWithWhereUniqueWithoutProductInput | ProductCommentUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: ProductCommentCreateManyProductInputEnvelope
		set?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		disconnect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		delete?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		update?: ProductCommentUpdateWithWhereUniqueWithoutProductInput | ProductCommentUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: ProductCommentUpdateManyWithWhereWithoutProductInput | ProductCommentUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
	}

	export type CartUncheckedUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
			| CartCreateWithoutProductInput[]
			| CartUncheckedCreateWithoutProductInput[]
		connectOrCreate?: CartCreateOrConnectWithoutProductInput | CartCreateOrConnectWithoutProductInput[]
		upsert?: CartUpsertWithWhereUniqueWithoutProductInput | CartUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: CartCreateManyProductInputEnvelope
		set?: CartWhereUniqueInput | CartWhereUniqueInput[]
		disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		update?: CartUpdateWithWhereUniqueWithoutProductInput | CartUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: CartUpdateManyWithWhereWithoutProductInput | CartUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
	}

	export type FavoriteUncheckedUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
			| FavoriteCreateWithoutProductInput[]
			| FavoriteUncheckedCreateWithoutProductInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
		upsert?: FavoriteUpsertWithWhereUniqueWithoutProductInput | FavoriteUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: FavoriteCreateManyProductInputEnvelope
		set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		update?: FavoriteUpdateWithWhereUniqueWithoutProductInput | FavoriteUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: FavoriteUpdateManyWithWhereWithoutProductInput | FavoriteUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
	}

	export type ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<ProductIngredientsCreateWithoutProductInput, ProductIngredientsUncheckedCreateWithoutProductInput>
			| ProductIngredientsCreateWithoutProductInput[]
			| ProductIngredientsUncheckedCreateWithoutProductInput[]
		connectOrCreate?:
			| ProductIngredientsCreateOrConnectWithoutProductInput
			| ProductIngredientsCreateOrConnectWithoutProductInput[]
		upsert?:
			| ProductIngredientsUpsertWithWhereUniqueWithoutProductInput
			| ProductIngredientsUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: ProductIngredientsCreateManyProductInputEnvelope
		set?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		disconnect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		delete?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		connect?: ProductIngredientsWhereUniqueInput | ProductIngredientsWhereUniqueInput[]
		update?:
			| ProductIngredientsUpdateWithWhereUniqueWithoutProductInput
			| ProductIngredientsUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?:
			| ProductIngredientsUpdateManyWithWhereWithoutProductInput
			| ProductIngredientsUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: ProductIngredientsScalarWhereInput | ProductIngredientsScalarWhereInput[]
	}

	export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
			| OrderItemCreateWithoutProductInput[]
			| OrderItemUncheckedCreateWithoutProductInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
		upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: OrderItemCreateManyProductInputEnvelope
		set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
	}

	export type ProductCommentUncheckedUpdateManyWithoutProductNestedInput = {
		create?:
			| XOR<ProductCommentCreateWithoutProductInput, ProductCommentUncheckedCreateWithoutProductInput>
			| ProductCommentCreateWithoutProductInput[]
			| ProductCommentUncheckedCreateWithoutProductInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutProductInput | ProductCommentCreateOrConnectWithoutProductInput[]
		upsert?: ProductCommentUpsertWithWhereUniqueWithoutProductInput | ProductCommentUpsertWithWhereUniqueWithoutProductInput[]
		createMany?: ProductCommentCreateManyProductInputEnvelope
		set?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		disconnect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		delete?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		update?: ProductCommentUpdateWithWhereUniqueWithoutProductInput | ProductCommentUpdateWithWhereUniqueWithoutProductInput[]
		updateMany?: ProductCommentUpdateManyWithWhereWithoutProductInput | ProductCommentUpdateManyWithWhereWithoutProductInput[]
		deleteMany?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
	}

	export type ProductCreateNestedOneWithoutFavoriteInput = {
		create?: XOR<ProductCreateWithoutFavoriteInput, ProductUncheckedCreateWithoutFavoriteInput>
		connectOrCreate?: ProductCreateOrConnectWithoutFavoriteInput
		connect?: ProductWhereUniqueInput
	}

	export type AccountCreateNestedOneWithoutFavoritesInput = {
		create?: XOR<AccountCreateWithoutFavoritesInput, AccountUncheckedCreateWithoutFavoritesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutFavoritesInput
		connect?: AccountWhereUniqueInput
	}

	export type ProductUpdateOneRequiredWithoutFavoriteNestedInput = {
		create?: XOR<ProductCreateWithoutFavoriteInput, ProductUncheckedCreateWithoutFavoriteInput>
		connectOrCreate?: ProductCreateOrConnectWithoutFavoriteInput
		upsert?: ProductUpsertWithoutFavoriteInput
		connect?: ProductWhereUniqueInput
		update?: XOR<
			XOR<ProductUpdateToOneWithWhereWithoutFavoriteInput, ProductUpdateWithoutFavoriteInput>,
			ProductUncheckedUpdateWithoutFavoriteInput
		>
	}

	export type AccountUpdateOneRequiredWithoutFavoritesNestedInput = {
		create?: XOR<AccountCreateWithoutFavoritesInput, AccountUncheckedCreateWithoutFavoritesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutFavoritesInput
		upsert?: AccountUpsertWithoutFavoritesInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutFavoritesInput, AccountUpdateWithoutFavoritesInput>,
			AccountUncheckedUpdateWithoutFavoritesInput
		>
	}

	export type AccountCreateNestedOneWithoutAccountSettingsInput = {
		create?: XOR<AccountCreateWithoutAccountSettingsInput, AccountUncheckedCreateWithoutAccountSettingsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutAccountSettingsInput
		connect?: AccountWhereUniqueInput
	}

	export type AccountUpdateOneRequiredWithoutAccountSettingsNestedInput = {
		create?: XOR<AccountCreateWithoutAccountSettingsInput, AccountUncheckedCreateWithoutAccountSettingsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutAccountSettingsInput
		upsert?: AccountUpsertWithoutAccountSettingsInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutAccountSettingsInput, AccountUpdateWithoutAccountSettingsInput>,
			AccountUncheckedUpdateWithoutAccountSettingsInput
		>
	}

	export type AccountRoleCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<AccountRoleCreateWithoutAccountInput, AccountRoleUncheckedCreateWithoutAccountInput>
			| AccountRoleCreateWithoutAccountInput[]
			| AccountRoleUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutAccountInput | AccountRoleCreateOrConnectWithoutAccountInput[]
		createMany?: AccountRoleCreateManyAccountInputEnvelope
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
	}

	export type CartCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<CartCreateWithoutAccountInput, CartUncheckedCreateWithoutAccountInput>
			| CartCreateWithoutAccountInput[]
			| CartUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: CartCreateOrConnectWithoutAccountInput | CartCreateOrConnectWithoutAccountInput[]
		createMany?: CartCreateManyAccountInputEnvelope
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
	}

	export type FavoriteCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<FavoriteCreateWithoutAccountInput, FavoriteUncheckedCreateWithoutAccountInput>
			| FavoriteCreateWithoutAccountInput[]
			| FavoriteUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutAccountInput | FavoriteCreateOrConnectWithoutAccountInput[]
		createMany?: FavoriteCreateManyAccountInputEnvelope
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
	}

	export type OrderCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
			| OrderCreateWithoutAccountInput[]
			| OrderUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: OrderCreateOrConnectWithoutAccountInput | OrderCreateOrConnectWithoutAccountInput[]
		createMany?: OrderCreateManyAccountInputEnvelope
		connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
	}

	export type ProductCommentCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<ProductCommentCreateWithoutAccountInput, ProductCommentUncheckedCreateWithoutAccountInput>
			| ProductCommentCreateWithoutAccountInput[]
			| ProductCommentUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutAccountInput | ProductCommentCreateOrConnectWithoutAccountInput[]
		createMany?: ProductCommentCreateManyAccountInputEnvelope
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
	}

	export type DeliveryAddressCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<DeliveryAddressCreateWithoutAccountInput, DeliveryAddressUncheckedCreateWithoutAccountInput>
			| DeliveryAddressCreateWithoutAccountInput[]
			| DeliveryAddressUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: DeliveryAddressCreateOrConnectWithoutAccountInput | DeliveryAddressCreateOrConnectWithoutAccountInput[]
		createMany?: DeliveryAddressCreateManyAccountInputEnvelope
		connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
	}

	export type NotificationCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
			| NotificationCreateWithoutAccountInput[]
			| NotificationUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
		createMany?: NotificationCreateManyAccountInputEnvelope
		connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
	}

	export type PostCreateNestedManyWithoutAuthorInput = {
		create?:
			| XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
			| PostCreateWithoutAuthorInput[]
			| PostUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
		createMany?: PostCreateManyAuthorInputEnvelope
		connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
	}

	export type PostCommentCreateNestedManyWithoutAuthorInput = {
		create?:
			| XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
			| PostCommentCreateWithoutAuthorInput[]
			| PostCommentUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutAuthorInput | PostCommentCreateOrConnectWithoutAuthorInput[]
		createMany?: PostCommentCreateManyAuthorInputEnvelope
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
	}

	export type PostLikeCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<PostLikeCreateWithoutAccountInput, PostLikeUncheckedCreateWithoutAccountInput>
			| PostLikeCreateWithoutAccountInput[]
			| PostLikeUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutAccountInput | PostLikeCreateOrConnectWithoutAccountInput[]
		createMany?: PostLikeCreateManyAccountInputEnvelope
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
	}

	export type TokenCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<TokenCreateWithoutAccountInput, TokenUncheckedCreateWithoutAccountInput>
			| TokenCreateWithoutAccountInput[]
			| TokenUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: TokenCreateOrConnectWithoutAccountInput | TokenCreateOrConnectWithoutAccountInput[]
		createMany?: TokenCreateManyAccountInputEnvelope
		connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
	}

	export type AccountSettingsCreateNestedOneWithoutAccountInput = {
		create?: XOR<AccountSettingsCreateWithoutAccountInput, AccountSettingsUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountSettingsCreateOrConnectWithoutAccountInput
		connect?: AccountSettingsWhereUniqueInput
	}

	export type AccountLoyaltyCreateNestedOneWithoutAccountInput = {
		create?: XOR<AccountLoyaltyCreateWithoutAccountInput, AccountLoyaltyUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountLoyaltyCreateOrConnectWithoutAccountInput
		connect?: AccountLoyaltyWhereUniqueInput
	}

	export type SupportMessageCreateNestedManyWithoutSenderInput = {
		create?:
			| XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
			| SupportMessageCreateWithoutSenderInput[]
			| SupportMessageUncheckedCreateWithoutSenderInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
		createMany?: SupportMessageCreateManySenderInputEnvelope
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
	}

	export type SupportMessageCreateNestedManyWithoutReceiverInput = {
		create?:
			| XOR<SupportMessageCreateWithoutReceiverInput, SupportMessageUncheckedCreateWithoutReceiverInput>
			| SupportMessageCreateWithoutReceiverInput[]
			| SupportMessageUncheckedCreateWithoutReceiverInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutReceiverInput | SupportMessageCreateOrConnectWithoutReceiverInput[]
		createMany?: SupportMessageCreateManyReceiverInputEnvelope
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
	}

	export type AccountRoleUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<AccountRoleCreateWithoutAccountInput, AccountRoleUncheckedCreateWithoutAccountInput>
			| AccountRoleCreateWithoutAccountInput[]
			| AccountRoleUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutAccountInput | AccountRoleCreateOrConnectWithoutAccountInput[]
		createMany?: AccountRoleCreateManyAccountInputEnvelope
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
	}

	export type CartUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<CartCreateWithoutAccountInput, CartUncheckedCreateWithoutAccountInput>
			| CartCreateWithoutAccountInput[]
			| CartUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: CartCreateOrConnectWithoutAccountInput | CartCreateOrConnectWithoutAccountInput[]
		createMany?: CartCreateManyAccountInputEnvelope
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
	}

	export type FavoriteUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<FavoriteCreateWithoutAccountInput, FavoriteUncheckedCreateWithoutAccountInput>
			| FavoriteCreateWithoutAccountInput[]
			| FavoriteUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutAccountInput | FavoriteCreateOrConnectWithoutAccountInput[]
		createMany?: FavoriteCreateManyAccountInputEnvelope
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
	}

	export type OrderUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
			| OrderCreateWithoutAccountInput[]
			| OrderUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: OrderCreateOrConnectWithoutAccountInput | OrderCreateOrConnectWithoutAccountInput[]
		createMany?: OrderCreateManyAccountInputEnvelope
		connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
	}

	export type ProductCommentUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<ProductCommentCreateWithoutAccountInput, ProductCommentUncheckedCreateWithoutAccountInput>
			| ProductCommentCreateWithoutAccountInput[]
			| ProductCommentUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutAccountInput | ProductCommentCreateOrConnectWithoutAccountInput[]
		createMany?: ProductCommentCreateManyAccountInputEnvelope
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
	}

	export type DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<DeliveryAddressCreateWithoutAccountInput, DeliveryAddressUncheckedCreateWithoutAccountInput>
			| DeliveryAddressCreateWithoutAccountInput[]
			| DeliveryAddressUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: DeliveryAddressCreateOrConnectWithoutAccountInput | DeliveryAddressCreateOrConnectWithoutAccountInput[]
		createMany?: DeliveryAddressCreateManyAccountInputEnvelope
		connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
	}

	export type NotificationUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
			| NotificationCreateWithoutAccountInput[]
			| NotificationUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
		createMany?: NotificationCreateManyAccountInputEnvelope
		connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
	}

	export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
		create?:
			| XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
			| PostCreateWithoutAuthorInput[]
			| PostUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
		createMany?: PostCreateManyAuthorInputEnvelope
		connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
	}

	export type PostCommentUncheckedCreateNestedManyWithoutAuthorInput = {
		create?:
			| XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
			| PostCommentCreateWithoutAuthorInput[]
			| PostCommentUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutAuthorInput | PostCommentCreateOrConnectWithoutAuthorInput[]
		createMany?: PostCommentCreateManyAuthorInputEnvelope
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
	}

	export type PostLikeUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<PostLikeCreateWithoutAccountInput, PostLikeUncheckedCreateWithoutAccountInput>
			| PostLikeCreateWithoutAccountInput[]
			| PostLikeUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutAccountInput | PostLikeCreateOrConnectWithoutAccountInput[]
		createMany?: PostLikeCreateManyAccountInputEnvelope
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
	}

	export type TokenUncheckedCreateNestedManyWithoutAccountInput = {
		create?:
			| XOR<TokenCreateWithoutAccountInput, TokenUncheckedCreateWithoutAccountInput>
			| TokenCreateWithoutAccountInput[]
			| TokenUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: TokenCreateOrConnectWithoutAccountInput | TokenCreateOrConnectWithoutAccountInput[]
		createMany?: TokenCreateManyAccountInputEnvelope
		connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
	}

	export type AccountSettingsUncheckedCreateNestedOneWithoutAccountInput = {
		create?: XOR<AccountSettingsCreateWithoutAccountInput, AccountSettingsUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountSettingsCreateOrConnectWithoutAccountInput
		connect?: AccountSettingsWhereUniqueInput
	}

	export type AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput = {
		create?: XOR<AccountLoyaltyCreateWithoutAccountInput, AccountLoyaltyUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountLoyaltyCreateOrConnectWithoutAccountInput
		connect?: AccountLoyaltyWhereUniqueInput
	}

	export type SupportMessageUncheckedCreateNestedManyWithoutSenderInput = {
		create?:
			| XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
			| SupportMessageCreateWithoutSenderInput[]
			| SupportMessageUncheckedCreateWithoutSenderInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
		createMany?: SupportMessageCreateManySenderInputEnvelope
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
	}

	export type SupportMessageUncheckedCreateNestedManyWithoutReceiverInput = {
		create?:
			| XOR<SupportMessageCreateWithoutReceiverInput, SupportMessageUncheckedCreateWithoutReceiverInput>
			| SupportMessageCreateWithoutReceiverInput[]
			| SupportMessageUncheckedCreateWithoutReceiverInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutReceiverInput | SupportMessageCreateOrConnectWithoutReceiverInput[]
		createMany?: SupportMessageCreateManyReceiverInputEnvelope
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
	}

	export type AccountRoleUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<AccountRoleCreateWithoutAccountInput, AccountRoleUncheckedCreateWithoutAccountInput>
			| AccountRoleCreateWithoutAccountInput[]
			| AccountRoleUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutAccountInput | AccountRoleCreateOrConnectWithoutAccountInput[]
		upsert?: AccountRoleUpsertWithWhereUniqueWithoutAccountInput | AccountRoleUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: AccountRoleCreateManyAccountInputEnvelope
		set?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		disconnect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		delete?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		update?: AccountRoleUpdateWithWhereUniqueWithoutAccountInput | AccountRoleUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: AccountRoleUpdateManyWithWhereWithoutAccountInput | AccountRoleUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: AccountRoleScalarWhereInput | AccountRoleScalarWhereInput[]
	}

	export type CartUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<CartCreateWithoutAccountInput, CartUncheckedCreateWithoutAccountInput>
			| CartCreateWithoutAccountInput[]
			| CartUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: CartCreateOrConnectWithoutAccountInput | CartCreateOrConnectWithoutAccountInput[]
		upsert?: CartUpsertWithWhereUniqueWithoutAccountInput | CartUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: CartCreateManyAccountInputEnvelope
		set?: CartWhereUniqueInput | CartWhereUniqueInput[]
		disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		update?: CartUpdateWithWhereUniqueWithoutAccountInput | CartUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: CartUpdateManyWithWhereWithoutAccountInput | CartUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
	}

	export type FavoriteUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<FavoriteCreateWithoutAccountInput, FavoriteUncheckedCreateWithoutAccountInput>
			| FavoriteCreateWithoutAccountInput[]
			| FavoriteUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutAccountInput | FavoriteCreateOrConnectWithoutAccountInput[]
		upsert?: FavoriteUpsertWithWhereUniqueWithoutAccountInput | FavoriteUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: FavoriteCreateManyAccountInputEnvelope
		set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		update?: FavoriteUpdateWithWhereUniqueWithoutAccountInput | FavoriteUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: FavoriteUpdateManyWithWhereWithoutAccountInput | FavoriteUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
	}

	export type OrderUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
			| OrderCreateWithoutAccountInput[]
			| OrderUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: OrderCreateOrConnectWithoutAccountInput | OrderCreateOrConnectWithoutAccountInput[]
		upsert?: OrderUpsertWithWhereUniqueWithoutAccountInput | OrderUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: OrderCreateManyAccountInputEnvelope
		set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		update?: OrderUpdateWithWhereUniqueWithoutAccountInput | OrderUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: OrderUpdateManyWithWhereWithoutAccountInput | OrderUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
	}

	export type ProductCommentUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<ProductCommentCreateWithoutAccountInput, ProductCommentUncheckedCreateWithoutAccountInput>
			| ProductCommentCreateWithoutAccountInput[]
			| ProductCommentUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutAccountInput | ProductCommentCreateOrConnectWithoutAccountInput[]
		upsert?: ProductCommentUpsertWithWhereUniqueWithoutAccountInput | ProductCommentUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: ProductCommentCreateManyAccountInputEnvelope
		set?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		disconnect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		delete?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		update?: ProductCommentUpdateWithWhereUniqueWithoutAccountInput | ProductCommentUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: ProductCommentUpdateManyWithWhereWithoutAccountInput | ProductCommentUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
	}

	export type DeliveryAddressUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<DeliveryAddressCreateWithoutAccountInput, DeliveryAddressUncheckedCreateWithoutAccountInput>
			| DeliveryAddressCreateWithoutAccountInput[]
			| DeliveryAddressUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: DeliveryAddressCreateOrConnectWithoutAccountInput | DeliveryAddressCreateOrConnectWithoutAccountInput[]
		upsert?: DeliveryAddressUpsertWithWhereUniqueWithoutAccountInput | DeliveryAddressUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: DeliveryAddressCreateManyAccountInputEnvelope
		set?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		disconnect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		delete?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		update?: DeliveryAddressUpdateWithWhereUniqueWithoutAccountInput | DeliveryAddressUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: DeliveryAddressUpdateManyWithWhereWithoutAccountInput | DeliveryAddressUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
	}

	export type NotificationUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
			| NotificationCreateWithoutAccountInput[]
			| NotificationUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
		upsert?: NotificationUpsertWithWhereUniqueWithoutAccountInput | NotificationUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: NotificationCreateManyAccountInputEnvelope
		set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		update?: NotificationUpdateWithWhereUniqueWithoutAccountInput | NotificationUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: NotificationUpdateManyWithWhereWithoutAccountInput | NotificationUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
	}

	export type PostUpdateManyWithoutAuthorNestedInput = {
		create?:
			| XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
			| PostCreateWithoutAuthorInput[]
			| PostUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
		upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
		createMany?: PostCreateManyAuthorInputEnvelope
		set?: PostWhereUniqueInput | PostWhereUniqueInput[]
		disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
		delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
		connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
		update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
		updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
		deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
	}

	export type PostCommentUpdateManyWithoutAuthorNestedInput = {
		create?:
			| XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
			| PostCommentCreateWithoutAuthorInput[]
			| PostCommentUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutAuthorInput | PostCommentCreateOrConnectWithoutAuthorInput[]
		upsert?: PostCommentUpsertWithWhereUniqueWithoutAuthorInput | PostCommentUpsertWithWhereUniqueWithoutAuthorInput[]
		createMany?: PostCommentCreateManyAuthorInputEnvelope
		set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		update?: PostCommentUpdateWithWhereUniqueWithoutAuthorInput | PostCommentUpdateWithWhereUniqueWithoutAuthorInput[]
		updateMany?: PostCommentUpdateManyWithWhereWithoutAuthorInput | PostCommentUpdateManyWithWhereWithoutAuthorInput[]
		deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
	}

	export type PostLikeUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<PostLikeCreateWithoutAccountInput, PostLikeUncheckedCreateWithoutAccountInput>
			| PostLikeCreateWithoutAccountInput[]
			| PostLikeUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutAccountInput | PostLikeCreateOrConnectWithoutAccountInput[]
		upsert?: PostLikeUpsertWithWhereUniqueWithoutAccountInput | PostLikeUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: PostLikeCreateManyAccountInputEnvelope
		set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		update?: PostLikeUpdateWithWhereUniqueWithoutAccountInput | PostLikeUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: PostLikeUpdateManyWithWhereWithoutAccountInput | PostLikeUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
	}

	export type TokenUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<TokenCreateWithoutAccountInput, TokenUncheckedCreateWithoutAccountInput>
			| TokenCreateWithoutAccountInput[]
			| TokenUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: TokenCreateOrConnectWithoutAccountInput | TokenCreateOrConnectWithoutAccountInput[]
		upsert?: TokenUpsertWithWhereUniqueWithoutAccountInput | TokenUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: TokenCreateManyAccountInputEnvelope
		set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		update?: TokenUpdateWithWhereUniqueWithoutAccountInput | TokenUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: TokenUpdateManyWithWhereWithoutAccountInput | TokenUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
	}

	export type AccountSettingsUpdateOneWithoutAccountNestedInput = {
		create?: XOR<AccountSettingsCreateWithoutAccountInput, AccountSettingsUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountSettingsCreateOrConnectWithoutAccountInput
		upsert?: AccountSettingsUpsertWithoutAccountInput
		disconnect?: AccountSettingsWhereInput | boolean
		delete?: AccountSettingsWhereInput | boolean
		connect?: AccountSettingsWhereUniqueInput
		update?: XOR<
			XOR<AccountSettingsUpdateToOneWithWhereWithoutAccountInput, AccountSettingsUpdateWithoutAccountInput>,
			AccountSettingsUncheckedUpdateWithoutAccountInput
		>
	}

	export type AccountLoyaltyUpdateOneWithoutAccountNestedInput = {
		create?: XOR<AccountLoyaltyCreateWithoutAccountInput, AccountLoyaltyUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountLoyaltyCreateOrConnectWithoutAccountInput
		upsert?: AccountLoyaltyUpsertWithoutAccountInput
		disconnect?: AccountLoyaltyWhereInput | boolean
		delete?: AccountLoyaltyWhereInput | boolean
		connect?: AccountLoyaltyWhereUniqueInput
		update?: XOR<
			XOR<AccountLoyaltyUpdateToOneWithWhereWithoutAccountInput, AccountLoyaltyUpdateWithoutAccountInput>,
			AccountLoyaltyUncheckedUpdateWithoutAccountInput
		>
	}

	export type SupportMessageUpdateManyWithoutSenderNestedInput = {
		create?:
			| XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
			| SupportMessageCreateWithoutSenderInput[]
			| SupportMessageUncheckedCreateWithoutSenderInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
		upsert?: SupportMessageUpsertWithWhereUniqueWithoutSenderInput | SupportMessageUpsertWithWhereUniqueWithoutSenderInput[]
		createMany?: SupportMessageCreateManySenderInputEnvelope
		set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		update?: SupportMessageUpdateWithWhereUniqueWithoutSenderInput | SupportMessageUpdateWithWhereUniqueWithoutSenderInput[]
		updateMany?: SupportMessageUpdateManyWithWhereWithoutSenderInput | SupportMessageUpdateManyWithWhereWithoutSenderInput[]
		deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
	}

	export type SupportMessageUpdateManyWithoutReceiverNestedInput = {
		create?:
			| XOR<SupportMessageCreateWithoutReceiverInput, SupportMessageUncheckedCreateWithoutReceiverInput>
			| SupportMessageCreateWithoutReceiverInput[]
			| SupportMessageUncheckedCreateWithoutReceiverInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutReceiverInput | SupportMessageCreateOrConnectWithoutReceiverInput[]
		upsert?: SupportMessageUpsertWithWhereUniqueWithoutReceiverInput | SupportMessageUpsertWithWhereUniqueWithoutReceiverInput[]
		createMany?: SupportMessageCreateManyReceiverInputEnvelope
		set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		update?: SupportMessageUpdateWithWhereUniqueWithoutReceiverInput | SupportMessageUpdateWithWhereUniqueWithoutReceiverInput[]
		updateMany?: SupportMessageUpdateManyWithWhereWithoutReceiverInput | SupportMessageUpdateManyWithWhereWithoutReceiverInput[]
		deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
	}

	export type AccountRoleUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<AccountRoleCreateWithoutAccountInput, AccountRoleUncheckedCreateWithoutAccountInput>
			| AccountRoleCreateWithoutAccountInput[]
			| AccountRoleUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: AccountRoleCreateOrConnectWithoutAccountInput | AccountRoleCreateOrConnectWithoutAccountInput[]
		upsert?: AccountRoleUpsertWithWhereUniqueWithoutAccountInput | AccountRoleUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: AccountRoleCreateManyAccountInputEnvelope
		set?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		disconnect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		delete?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		connect?: AccountRoleWhereUniqueInput | AccountRoleWhereUniqueInput[]
		update?: AccountRoleUpdateWithWhereUniqueWithoutAccountInput | AccountRoleUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: AccountRoleUpdateManyWithWhereWithoutAccountInput | AccountRoleUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: AccountRoleScalarWhereInput | AccountRoleScalarWhereInput[]
	}

	export type CartUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<CartCreateWithoutAccountInput, CartUncheckedCreateWithoutAccountInput>
			| CartCreateWithoutAccountInput[]
			| CartUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: CartCreateOrConnectWithoutAccountInput | CartCreateOrConnectWithoutAccountInput[]
		upsert?: CartUpsertWithWhereUniqueWithoutAccountInput | CartUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: CartCreateManyAccountInputEnvelope
		set?: CartWhereUniqueInput | CartWhereUniqueInput[]
		disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
		connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
		update?: CartUpdateWithWhereUniqueWithoutAccountInput | CartUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: CartUpdateManyWithWhereWithoutAccountInput | CartUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
	}

	export type FavoriteUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<FavoriteCreateWithoutAccountInput, FavoriteUncheckedCreateWithoutAccountInput>
			| FavoriteCreateWithoutAccountInput[]
			| FavoriteUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: FavoriteCreateOrConnectWithoutAccountInput | FavoriteCreateOrConnectWithoutAccountInput[]
		upsert?: FavoriteUpsertWithWhereUniqueWithoutAccountInput | FavoriteUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: FavoriteCreateManyAccountInputEnvelope
		set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
		update?: FavoriteUpdateWithWhereUniqueWithoutAccountInput | FavoriteUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: FavoriteUpdateManyWithWhereWithoutAccountInput | FavoriteUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
	}

	export type OrderUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
			| OrderCreateWithoutAccountInput[]
			| OrderUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: OrderCreateOrConnectWithoutAccountInput | OrderCreateOrConnectWithoutAccountInput[]
		upsert?: OrderUpsertWithWhereUniqueWithoutAccountInput | OrderUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: OrderCreateManyAccountInputEnvelope
		set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
		update?: OrderUpdateWithWhereUniqueWithoutAccountInput | OrderUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: OrderUpdateManyWithWhereWithoutAccountInput | OrderUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
	}

	export type ProductCommentUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<ProductCommentCreateWithoutAccountInput, ProductCommentUncheckedCreateWithoutAccountInput>
			| ProductCommentCreateWithoutAccountInput[]
			| ProductCommentUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutAccountInput | ProductCommentCreateOrConnectWithoutAccountInput[]
		upsert?: ProductCommentUpsertWithWhereUniqueWithoutAccountInput | ProductCommentUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: ProductCommentCreateManyAccountInputEnvelope
		set?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		disconnect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		delete?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		update?: ProductCommentUpdateWithWhereUniqueWithoutAccountInput | ProductCommentUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: ProductCommentUpdateManyWithWhereWithoutAccountInput | ProductCommentUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
	}

	export type DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<DeliveryAddressCreateWithoutAccountInput, DeliveryAddressUncheckedCreateWithoutAccountInput>
			| DeliveryAddressCreateWithoutAccountInput[]
			| DeliveryAddressUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: DeliveryAddressCreateOrConnectWithoutAccountInput | DeliveryAddressCreateOrConnectWithoutAccountInput[]
		upsert?: DeliveryAddressUpsertWithWhereUniqueWithoutAccountInput | DeliveryAddressUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: DeliveryAddressCreateManyAccountInputEnvelope
		set?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		disconnect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		delete?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
		update?: DeliveryAddressUpdateWithWhereUniqueWithoutAccountInput | DeliveryAddressUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: DeliveryAddressUpdateManyWithWhereWithoutAccountInput | DeliveryAddressUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
	}

	export type NotificationUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
			| NotificationCreateWithoutAccountInput[]
			| NotificationUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
		upsert?: NotificationUpsertWithWhereUniqueWithoutAccountInput | NotificationUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: NotificationCreateManyAccountInputEnvelope
		set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
		update?: NotificationUpdateWithWhereUniqueWithoutAccountInput | NotificationUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: NotificationUpdateManyWithWhereWithoutAccountInput | NotificationUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
	}

	export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
		create?:
			| XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
			| PostCreateWithoutAuthorInput[]
			| PostUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
		upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
		createMany?: PostCreateManyAuthorInputEnvelope
		set?: PostWhereUniqueInput | PostWhereUniqueInput[]
		disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
		delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
		connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
		update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
		updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
		deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
	}

	export type PostCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
		create?:
			| XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
			| PostCommentCreateWithoutAuthorInput[]
			| PostCommentUncheckedCreateWithoutAuthorInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutAuthorInput | PostCommentCreateOrConnectWithoutAuthorInput[]
		upsert?: PostCommentUpsertWithWhereUniqueWithoutAuthorInput | PostCommentUpsertWithWhereUniqueWithoutAuthorInput[]
		createMany?: PostCommentCreateManyAuthorInputEnvelope
		set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		update?: PostCommentUpdateWithWhereUniqueWithoutAuthorInput | PostCommentUpdateWithWhereUniqueWithoutAuthorInput[]
		updateMany?: PostCommentUpdateManyWithWhereWithoutAuthorInput | PostCommentUpdateManyWithWhereWithoutAuthorInput[]
		deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
	}

	export type PostLikeUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<PostLikeCreateWithoutAccountInput, PostLikeUncheckedCreateWithoutAccountInput>
			| PostLikeCreateWithoutAccountInput[]
			| PostLikeUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutAccountInput | PostLikeCreateOrConnectWithoutAccountInput[]
		upsert?: PostLikeUpsertWithWhereUniqueWithoutAccountInput | PostLikeUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: PostLikeCreateManyAccountInputEnvelope
		set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		update?: PostLikeUpdateWithWhereUniqueWithoutAccountInput | PostLikeUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: PostLikeUpdateManyWithWhereWithoutAccountInput | PostLikeUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
	}

	export type TokenUncheckedUpdateManyWithoutAccountNestedInput = {
		create?:
			| XOR<TokenCreateWithoutAccountInput, TokenUncheckedCreateWithoutAccountInput>
			| TokenCreateWithoutAccountInput[]
			| TokenUncheckedCreateWithoutAccountInput[]
		connectOrCreate?: TokenCreateOrConnectWithoutAccountInput | TokenCreateOrConnectWithoutAccountInput[]
		upsert?: TokenUpsertWithWhereUniqueWithoutAccountInput | TokenUpsertWithWhereUniqueWithoutAccountInput[]
		createMany?: TokenCreateManyAccountInputEnvelope
		set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
		update?: TokenUpdateWithWhereUniqueWithoutAccountInput | TokenUpdateWithWhereUniqueWithoutAccountInput[]
		updateMany?: TokenUpdateManyWithWhereWithoutAccountInput | TokenUpdateManyWithWhereWithoutAccountInput[]
		deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
	}

	export type AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput = {
		create?: XOR<AccountSettingsCreateWithoutAccountInput, AccountSettingsUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountSettingsCreateOrConnectWithoutAccountInput
		upsert?: AccountSettingsUpsertWithoutAccountInput
		disconnect?: AccountSettingsWhereInput | boolean
		delete?: AccountSettingsWhereInput | boolean
		connect?: AccountSettingsWhereUniqueInput
		update?: XOR<
			XOR<AccountSettingsUpdateToOneWithWhereWithoutAccountInput, AccountSettingsUpdateWithoutAccountInput>,
			AccountSettingsUncheckedUpdateWithoutAccountInput
		>
	}

	export type AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput = {
		create?: XOR<AccountLoyaltyCreateWithoutAccountInput, AccountLoyaltyUncheckedCreateWithoutAccountInput>
		connectOrCreate?: AccountLoyaltyCreateOrConnectWithoutAccountInput
		upsert?: AccountLoyaltyUpsertWithoutAccountInput
		disconnect?: AccountLoyaltyWhereInput | boolean
		delete?: AccountLoyaltyWhereInput | boolean
		connect?: AccountLoyaltyWhereUniqueInput
		update?: XOR<
			XOR<AccountLoyaltyUpdateToOneWithWhereWithoutAccountInput, AccountLoyaltyUpdateWithoutAccountInput>,
			AccountLoyaltyUncheckedUpdateWithoutAccountInput
		>
	}

	export type SupportMessageUncheckedUpdateManyWithoutSenderNestedInput = {
		create?:
			| XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
			| SupportMessageCreateWithoutSenderInput[]
			| SupportMessageUncheckedCreateWithoutSenderInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
		upsert?: SupportMessageUpsertWithWhereUniqueWithoutSenderInput | SupportMessageUpsertWithWhereUniqueWithoutSenderInput[]
		createMany?: SupportMessageCreateManySenderInputEnvelope
		set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		update?: SupportMessageUpdateWithWhereUniqueWithoutSenderInput | SupportMessageUpdateWithWhereUniqueWithoutSenderInput[]
		updateMany?: SupportMessageUpdateManyWithWhereWithoutSenderInput | SupportMessageUpdateManyWithWhereWithoutSenderInput[]
		deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
	}

	export type SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
		create?:
			| XOR<SupportMessageCreateWithoutReceiverInput, SupportMessageUncheckedCreateWithoutReceiverInput>
			| SupportMessageCreateWithoutReceiverInput[]
			| SupportMessageUncheckedCreateWithoutReceiverInput[]
		connectOrCreate?: SupportMessageCreateOrConnectWithoutReceiverInput | SupportMessageCreateOrConnectWithoutReceiverInput[]
		upsert?: SupportMessageUpsertWithWhereUniqueWithoutReceiverInput | SupportMessageUpsertWithWhereUniqueWithoutReceiverInput[]
		createMany?: SupportMessageCreateManyReceiverInputEnvelope
		set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
		update?: SupportMessageUpdateWithWhereUniqueWithoutReceiverInput | SupportMessageUpdateWithWhereUniqueWithoutReceiverInput[]
		updateMany?: SupportMessageUpdateManyWithWhereWithoutReceiverInput | SupportMessageUpdateManyWithWhereWithoutReceiverInput[]
		deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
	}

	export type AccountCreateNestedOneWithoutDeliveryAdressesInput = {
		create?: XOR<AccountCreateWithoutDeliveryAdressesInput, AccountUncheckedCreateWithoutDeliveryAdressesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutDeliveryAdressesInput
		connect?: AccountWhereUniqueInput
	}

	export type AccountUpdateOneRequiredWithoutDeliveryAdressesNestedInput = {
		create?: XOR<AccountCreateWithoutDeliveryAdressesInput, AccountUncheckedCreateWithoutDeliveryAdressesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutDeliveryAdressesInput
		upsert?: AccountUpsertWithoutDeliveryAdressesInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutDeliveryAdressesInput, AccountUpdateWithoutDeliveryAdressesInput>,
			AccountUncheckedUpdateWithoutDeliveryAdressesInput
		>
	}

	export type OrderItemCreateNestedManyWithoutOrderInput = {
		create?:
			| XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
			| OrderItemCreateWithoutOrderInput[]
			| OrderItemUncheckedCreateWithoutOrderInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
		createMany?: OrderItemCreateManyOrderInputEnvelope
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
	}

	export type AccountCreateNestedOneWithoutOrdersInput = {
		create?: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
		connectOrCreate?: AccountCreateOrConnectWithoutOrdersInput
		connect?: AccountWhereUniqueInput
	}

	export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
		create?:
			| XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
			| OrderItemCreateWithoutOrderInput[]
			| OrderItemUncheckedCreateWithoutOrderInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
		createMany?: OrderItemCreateManyOrderInputEnvelope
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
	}

	export type EnumOrderStatusFieldUpdateOperationsInput = {
		set?: $Enums.OrderStatus
	}

	export type EnumDeliveryTypeFieldUpdateOperationsInput = {
		set?: $Enums.DeliveryType
	}

	export type EnumPaymentMethodFieldUpdateOperationsInput = {
		set?: $Enums.PaymentMethod
	}

	export type EnumPaymentStatusFieldUpdateOperationsInput = {
		set?: $Enums.PaymentStatus
	}

	export type OrderItemUpdateManyWithoutOrderNestedInput = {
		create?:
			| XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
			| OrderItemCreateWithoutOrderInput[]
			| OrderItemUncheckedCreateWithoutOrderInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
		upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
		createMany?: OrderItemCreateManyOrderInputEnvelope
		set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
		updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
		deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
	}

	export type AccountUpdateOneWithoutOrdersNestedInput = {
		create?: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
		connectOrCreate?: AccountCreateOrConnectWithoutOrdersInput
		upsert?: AccountUpsertWithoutOrdersInput
		disconnect?: AccountWhereInput | boolean
		delete?: AccountWhereInput | boolean
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutOrdersInput, AccountUpdateWithoutOrdersInput>,
			AccountUncheckedUpdateWithoutOrdersInput
		>
	}

	export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
		create?:
			| XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
			| OrderItemCreateWithoutOrderInput[]
			| OrderItemUncheckedCreateWithoutOrderInput[]
		connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
		upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
		createMany?: OrderItemCreateManyOrderInputEnvelope
		set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
		update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
		updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
		deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
	}

	export type OrderCreateNestedOneWithoutItemsInput = {
		create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
		connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
		connect?: OrderWhereUniqueInput
	}

	export type ProductCreateNestedOneWithoutOrderItemInput = {
		create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
		connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput
		connect?: ProductWhereUniqueInput
	}

	export type OrderUpdateOneWithoutItemsNestedInput = {
		create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
		connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
		upsert?: OrderUpsertWithoutItemsInput
		disconnect?: OrderWhereInput | boolean
		delete?: OrderWhereInput | boolean
		connect?: OrderWhereUniqueInput
		update?: XOR<
			XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>,
			OrderUncheckedUpdateWithoutItemsInput
		>
	}

	export type ProductUpdateOneRequiredWithoutOrderItemNestedInput = {
		create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
		connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput
		upsert?: ProductUpsertWithoutOrderItemInput
		connect?: ProductWhereUniqueInput
		update?: XOR<
			XOR<ProductUpdateToOneWithWhereWithoutOrderItemInput, ProductUpdateWithoutOrderItemInput>,
			ProductUncheckedUpdateWithoutOrderItemInput
		>
	}

	export type ProductCommentCreateNestedOneWithoutRepliesInput = {
		create?: XOR<ProductCommentCreateWithoutRepliesInput, ProductCommentUncheckedCreateWithoutRepliesInput>
		connectOrCreate?: ProductCommentCreateOrConnectWithoutRepliesInput
		connect?: ProductCommentWhereUniqueInput
	}

	export type ProductCommentCreateNestedManyWithoutParentInput = {
		create?:
			| XOR<ProductCommentCreateWithoutParentInput, ProductCommentUncheckedCreateWithoutParentInput>
			| ProductCommentCreateWithoutParentInput[]
			| ProductCommentUncheckedCreateWithoutParentInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutParentInput | ProductCommentCreateOrConnectWithoutParentInput[]
		createMany?: ProductCommentCreateManyParentInputEnvelope
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
	}

	export type ProductCreateNestedOneWithoutCommentsInput = {
		create?: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
		connectOrCreate?: ProductCreateOrConnectWithoutCommentsInput
		connect?: ProductWhereUniqueInput
	}

	export type AccountCreateNestedOneWithoutProductCommentsInput = {
		create?: XOR<AccountCreateWithoutProductCommentsInput, AccountUncheckedCreateWithoutProductCommentsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutProductCommentsInput
		connect?: AccountWhereUniqueInput
	}

	export type ProductCommentUncheckedCreateNestedManyWithoutParentInput = {
		create?:
			| XOR<ProductCommentCreateWithoutParentInput, ProductCommentUncheckedCreateWithoutParentInput>
			| ProductCommentCreateWithoutParentInput[]
			| ProductCommentUncheckedCreateWithoutParentInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutParentInput | ProductCommentCreateOrConnectWithoutParentInput[]
		createMany?: ProductCommentCreateManyParentInputEnvelope
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
	}

	export type NullableIntFieldUpdateOperationsInput = {
		set?: number | null
		increment?: number
		decrement?: number
		multiply?: number
		divide?: number
	}

	export type ProductCommentUpdateOneWithoutRepliesNestedInput = {
		create?: XOR<ProductCommentCreateWithoutRepliesInput, ProductCommentUncheckedCreateWithoutRepliesInput>
		connectOrCreate?: ProductCommentCreateOrConnectWithoutRepliesInput
		upsert?: ProductCommentUpsertWithoutRepliesInput
		disconnect?: ProductCommentWhereInput | boolean
		delete?: ProductCommentWhereInput | boolean
		connect?: ProductCommentWhereUniqueInput
		update?: XOR<
			XOR<ProductCommentUpdateToOneWithWhereWithoutRepliesInput, ProductCommentUpdateWithoutRepliesInput>,
			ProductCommentUncheckedUpdateWithoutRepliesInput
		>
	}

	export type ProductCommentUpdateManyWithoutParentNestedInput = {
		create?:
			| XOR<ProductCommentCreateWithoutParentInput, ProductCommentUncheckedCreateWithoutParentInput>
			| ProductCommentCreateWithoutParentInput[]
			| ProductCommentUncheckedCreateWithoutParentInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutParentInput | ProductCommentCreateOrConnectWithoutParentInput[]
		upsert?: ProductCommentUpsertWithWhereUniqueWithoutParentInput | ProductCommentUpsertWithWhereUniqueWithoutParentInput[]
		createMany?: ProductCommentCreateManyParentInputEnvelope
		set?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		disconnect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		delete?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		update?: ProductCommentUpdateWithWhereUniqueWithoutParentInput | ProductCommentUpdateWithWhereUniqueWithoutParentInput[]
		updateMany?: ProductCommentUpdateManyWithWhereWithoutParentInput | ProductCommentUpdateManyWithWhereWithoutParentInput[]
		deleteMany?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
	}

	export type ProductUpdateOneRequiredWithoutCommentsNestedInput = {
		create?: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
		connectOrCreate?: ProductCreateOrConnectWithoutCommentsInput
		upsert?: ProductUpsertWithoutCommentsInput
		connect?: ProductWhereUniqueInput
		update?: XOR<
			XOR<ProductUpdateToOneWithWhereWithoutCommentsInput, ProductUpdateWithoutCommentsInput>,
			ProductUncheckedUpdateWithoutCommentsInput
		>
	}

	export type AccountUpdateOneRequiredWithoutProductCommentsNestedInput = {
		create?: XOR<AccountCreateWithoutProductCommentsInput, AccountUncheckedCreateWithoutProductCommentsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutProductCommentsInput
		upsert?: AccountUpsertWithoutProductCommentsInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutProductCommentsInput, AccountUpdateWithoutProductCommentsInput>,
			AccountUncheckedUpdateWithoutProductCommentsInput
		>
	}

	export type ProductCommentUncheckedUpdateManyWithoutParentNestedInput = {
		create?:
			| XOR<ProductCommentCreateWithoutParentInput, ProductCommentUncheckedCreateWithoutParentInput>
			| ProductCommentCreateWithoutParentInput[]
			| ProductCommentUncheckedCreateWithoutParentInput[]
		connectOrCreate?: ProductCommentCreateOrConnectWithoutParentInput | ProductCommentCreateOrConnectWithoutParentInput[]
		upsert?: ProductCommentUpsertWithWhereUniqueWithoutParentInput | ProductCommentUpsertWithWhereUniqueWithoutParentInput[]
		createMany?: ProductCommentCreateManyParentInputEnvelope
		set?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		disconnect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		delete?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		connect?: ProductCommentWhereUniqueInput | ProductCommentWhereUniqueInput[]
		update?: ProductCommentUpdateWithWhereUniqueWithoutParentInput | ProductCommentUpdateWithWhereUniqueWithoutParentInput[]
		updateMany?: ProductCommentUpdateManyWithWhereWithoutParentInput | ProductCommentUpdateManyWithWhereWithoutParentInput[]
		deleteMany?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
	}

	export type AccountCreateNestedOneWithoutPostsInput = {
		create?: XOR<AccountCreateWithoutPostsInput, AccountUncheckedCreateWithoutPostsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutPostsInput
		connect?: AccountWhereUniqueInput
	}

	export type PostCommentCreateNestedManyWithoutPostInput = {
		create?:
			| XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
			| PostCommentCreateWithoutPostInput[]
			| PostCommentUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
		createMany?: PostCommentCreateManyPostInputEnvelope
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
	}

	export type PostLikeCreateNestedManyWithoutPostInput = {
		create?:
			| XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
			| PostLikeCreateWithoutPostInput[]
			| PostLikeUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
		createMany?: PostLikeCreateManyPostInputEnvelope
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
	}

	export type PostCommentUncheckedCreateNestedManyWithoutPostInput = {
		create?:
			| XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
			| PostCommentCreateWithoutPostInput[]
			| PostCommentUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
		createMany?: PostCommentCreateManyPostInputEnvelope
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
	}

	export type PostLikeUncheckedCreateNestedManyWithoutPostInput = {
		create?:
			| XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
			| PostLikeCreateWithoutPostInput[]
			| PostLikeUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
		createMany?: PostLikeCreateManyPostInputEnvelope
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
	}

	export type AccountUpdateOneRequiredWithoutPostsNestedInput = {
		create?: XOR<AccountCreateWithoutPostsInput, AccountUncheckedCreateWithoutPostsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutPostsInput
		upsert?: AccountUpsertWithoutPostsInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutPostsInput, AccountUpdateWithoutPostsInput>,
			AccountUncheckedUpdateWithoutPostsInput
		>
	}

	export type PostCommentUpdateManyWithoutPostNestedInput = {
		create?:
			| XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
			| PostCommentCreateWithoutPostInput[]
			| PostCommentUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
		upsert?: PostCommentUpsertWithWhereUniqueWithoutPostInput | PostCommentUpsertWithWhereUniqueWithoutPostInput[]
		createMany?: PostCommentCreateManyPostInputEnvelope
		set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		update?: PostCommentUpdateWithWhereUniqueWithoutPostInput | PostCommentUpdateWithWhereUniqueWithoutPostInput[]
		updateMany?: PostCommentUpdateManyWithWhereWithoutPostInput | PostCommentUpdateManyWithWhereWithoutPostInput[]
		deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
	}

	export type PostLikeUpdateManyWithoutPostNestedInput = {
		create?:
			| XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
			| PostLikeCreateWithoutPostInput[]
			| PostLikeUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
		upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
		createMany?: PostLikeCreateManyPostInputEnvelope
		set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
		updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
		deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
	}

	export type PostCommentUncheckedUpdateManyWithoutPostNestedInput = {
		create?:
			| XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
			| PostCommentCreateWithoutPostInput[]
			| PostCommentUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
		upsert?: PostCommentUpsertWithWhereUniqueWithoutPostInput | PostCommentUpsertWithWhereUniqueWithoutPostInput[]
		createMany?: PostCommentCreateManyPostInputEnvelope
		set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
		update?: PostCommentUpdateWithWhereUniqueWithoutPostInput | PostCommentUpdateWithWhereUniqueWithoutPostInput[]
		updateMany?: PostCommentUpdateManyWithWhereWithoutPostInput | PostCommentUpdateManyWithWhereWithoutPostInput[]
		deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
	}

	export type PostLikeUncheckedUpdateManyWithoutPostNestedInput = {
		create?:
			| XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
			| PostLikeCreateWithoutPostInput[]
			| PostLikeUncheckedCreateWithoutPostInput[]
		connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
		upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
		createMany?: PostLikeCreateManyPostInputEnvelope
		set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
		update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
		updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
		deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
	}

	export type AccountCreateNestedOneWithoutPostCommentsInput = {
		create?: XOR<AccountCreateWithoutPostCommentsInput, AccountUncheckedCreateWithoutPostCommentsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutPostCommentsInput
		connect?: AccountWhereUniqueInput
	}

	export type PostCreateNestedOneWithoutCommentsInput = {
		create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
		connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
		connect?: PostWhereUniqueInput
	}

	export type AccountUpdateOneRequiredWithoutPostCommentsNestedInput = {
		create?: XOR<AccountCreateWithoutPostCommentsInput, AccountUncheckedCreateWithoutPostCommentsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutPostCommentsInput
		upsert?: AccountUpsertWithoutPostCommentsInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutPostCommentsInput, AccountUpdateWithoutPostCommentsInput>,
			AccountUncheckedUpdateWithoutPostCommentsInput
		>
	}

	export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
		create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
		connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
		upsert?: PostUpsertWithoutCommentsInput
		connect?: PostWhereUniqueInput
		update?: XOR<
			XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>,
			PostUncheckedUpdateWithoutCommentsInput
		>
	}

	export type PostCreateNestedOneWithoutLikesInput = {
		create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
		connectOrCreate?: PostCreateOrConnectWithoutLikesInput
		connect?: PostWhereUniqueInput
	}

	export type AccountCreateNestedOneWithoutPostLikesInput = {
		create?: XOR<AccountCreateWithoutPostLikesInput, AccountUncheckedCreateWithoutPostLikesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutPostLikesInput
		connect?: AccountWhereUniqueInput
	}

	export type PostUpdateOneRequiredWithoutLikesNestedInput = {
		create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
		connectOrCreate?: PostCreateOrConnectWithoutLikesInput
		upsert?: PostUpsertWithoutLikesInput
		connect?: PostWhereUniqueInput
		update?: XOR<
			XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>,
			PostUncheckedUpdateWithoutLikesInput
		>
	}

	export type AccountUpdateOneRequiredWithoutPostLikesNestedInput = {
		create?: XOR<AccountCreateWithoutPostLikesInput, AccountUncheckedCreateWithoutPostLikesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutPostLikesInput
		upsert?: AccountUpsertWithoutPostLikesInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutPostLikesInput, AccountUpdateWithoutPostLikesInput>,
			AccountUncheckedUpdateWithoutPostLikesInput
		>
	}

	export type AccountCreateNestedOneWithoutTokensInput = {
		create?: XOR<AccountCreateWithoutTokensInput, AccountUncheckedCreateWithoutTokensInput>
		connectOrCreate?: AccountCreateOrConnectWithoutTokensInput
		connect?: AccountWhereUniqueInput
	}

	export type EnumTokenTypesFieldUpdateOperationsInput = {
		set?: $Enums.TokenTypes
	}

	export type AccountUpdateOneWithoutTokensNestedInput = {
		create?: XOR<AccountCreateWithoutTokensInput, AccountUncheckedCreateWithoutTokensInput>
		connectOrCreate?: AccountCreateOrConnectWithoutTokensInput
		upsert?: AccountUpsertWithoutTokensInput
		disconnect?: AccountWhereInput | boolean
		delete?: AccountWhereInput | boolean
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutTokensInput, AccountUpdateWithoutTokensInput>,
			AccountUncheckedUpdateWithoutTokensInput
		>
	}

	export type AccountCreateNestedOneWithoutNotificationsInput = {
		create?: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutNotificationsInput
		connect?: AccountWhereUniqueInput
	}

	export type EnumNotificationTypeFieldUpdateOperationsInput = {
		set?: $Enums.NotificationType
	}

	export type AccountUpdateOneWithoutNotificationsNestedInput = {
		create?: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
		connectOrCreate?: AccountCreateOrConnectWithoutNotificationsInput
		upsert?: AccountUpsertWithoutNotificationsInput
		disconnect?: AccountWhereInput | boolean
		delete?: AccountWhereInput | boolean
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutNotificationsInput, AccountUpdateWithoutNotificationsInput>,
			AccountUncheckedUpdateWithoutNotificationsInput
		>
	}

	export type AccountCreateNestedOneWithoutSentMessagesInput = {
		create?: XOR<AccountCreateWithoutSentMessagesInput, AccountUncheckedCreateWithoutSentMessagesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutSentMessagesInput
		connect?: AccountWhereUniqueInput
	}

	export type AccountCreateNestedOneWithoutReceivedMessagesInput = {
		create?: XOR<AccountCreateWithoutReceivedMessagesInput, AccountUncheckedCreateWithoutReceivedMessagesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutReceivedMessagesInput
		connect?: AccountWhereUniqueInput
	}

	export type AccountUpdateOneRequiredWithoutSentMessagesNestedInput = {
		create?: XOR<AccountCreateWithoutSentMessagesInput, AccountUncheckedCreateWithoutSentMessagesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutSentMessagesInput
		upsert?: AccountUpsertWithoutSentMessagesInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutSentMessagesInput, AccountUpdateWithoutSentMessagesInput>,
			AccountUncheckedUpdateWithoutSentMessagesInput
		>
	}

	export type AccountUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
		create?: XOR<AccountCreateWithoutReceivedMessagesInput, AccountUncheckedCreateWithoutReceivedMessagesInput>
		connectOrCreate?: AccountCreateOrConnectWithoutReceivedMessagesInput
		upsert?: AccountUpsertWithoutReceivedMessagesInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutReceivedMessagesInput, AccountUpdateWithoutReceivedMessagesInput>,
			AccountUncheckedUpdateWithoutReceivedMessagesInput
		>
	}

	export type AccountLoyaltyCreateNestedManyWithoutLoyaltyLevelInput = {
		create?:
			| XOR<AccountLoyaltyCreateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput>
			| AccountLoyaltyCreateWithoutLoyaltyLevelInput[]
			| AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput[]
		connectOrCreate?:
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput[]
		createMany?: AccountLoyaltyCreateManyLoyaltyLevelInputEnvelope
		connect?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
	}

	export type AccountLoyaltyUncheckedCreateNestedManyWithoutLoyaltyLevelInput = {
		create?:
			| XOR<AccountLoyaltyCreateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput>
			| AccountLoyaltyCreateWithoutLoyaltyLevelInput[]
			| AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput[]
		connectOrCreate?:
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput[]
		createMany?: AccountLoyaltyCreateManyLoyaltyLevelInputEnvelope
		connect?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
	}

	export type AccountLoyaltyUpdateManyWithoutLoyaltyLevelNestedInput = {
		create?:
			| XOR<AccountLoyaltyCreateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput>
			| AccountLoyaltyCreateWithoutLoyaltyLevelInput[]
			| AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput[]
		connectOrCreate?:
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput[]
		upsert?:
			| AccountLoyaltyUpsertWithWhereUniqueWithoutLoyaltyLevelInput
			| AccountLoyaltyUpsertWithWhereUniqueWithoutLoyaltyLevelInput[]
		createMany?: AccountLoyaltyCreateManyLoyaltyLevelInputEnvelope
		set?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		disconnect?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		delete?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		connect?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		update?:
			| AccountLoyaltyUpdateWithWhereUniqueWithoutLoyaltyLevelInput
			| AccountLoyaltyUpdateWithWhereUniqueWithoutLoyaltyLevelInput[]
		updateMany?:
			| AccountLoyaltyUpdateManyWithWhereWithoutLoyaltyLevelInput
			| AccountLoyaltyUpdateManyWithWhereWithoutLoyaltyLevelInput[]
		deleteMany?: AccountLoyaltyScalarWhereInput | AccountLoyaltyScalarWhereInput[]
	}

	export type AccountLoyaltyUncheckedUpdateManyWithoutLoyaltyLevelNestedInput = {
		create?:
			| XOR<AccountLoyaltyCreateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput>
			| AccountLoyaltyCreateWithoutLoyaltyLevelInput[]
			| AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput[]
		connectOrCreate?:
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput
			| AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput[]
		upsert?:
			| AccountLoyaltyUpsertWithWhereUniqueWithoutLoyaltyLevelInput
			| AccountLoyaltyUpsertWithWhereUniqueWithoutLoyaltyLevelInput[]
		createMany?: AccountLoyaltyCreateManyLoyaltyLevelInputEnvelope
		set?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		disconnect?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		delete?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		connect?: AccountLoyaltyWhereUniqueInput | AccountLoyaltyWhereUniqueInput[]
		update?:
			| AccountLoyaltyUpdateWithWhereUniqueWithoutLoyaltyLevelInput
			| AccountLoyaltyUpdateWithWhereUniqueWithoutLoyaltyLevelInput[]
		updateMany?:
			| AccountLoyaltyUpdateManyWithWhereWithoutLoyaltyLevelInput
			| AccountLoyaltyUpdateManyWithWhereWithoutLoyaltyLevelInput[]
		deleteMany?: AccountLoyaltyScalarWhereInput | AccountLoyaltyScalarWhereInput[]
	}

	export type AccountCreateNestedOneWithoutAccountLoyaltyInput = {
		create?: XOR<AccountCreateWithoutAccountLoyaltyInput, AccountUncheckedCreateWithoutAccountLoyaltyInput>
		connectOrCreate?: AccountCreateOrConnectWithoutAccountLoyaltyInput
		connect?: AccountWhereUniqueInput
	}

	export type LoyaltyLevelCreateNestedOneWithoutAccountLoyaltiesInput = {
		create?: XOR<LoyaltyLevelCreateWithoutAccountLoyaltiesInput, LoyaltyLevelUncheckedCreateWithoutAccountLoyaltiesInput>
		connectOrCreate?: LoyaltyLevelCreateOrConnectWithoutAccountLoyaltiesInput
		connect?: LoyaltyLevelWhereUniqueInput
	}

	export type LoyaltyTransactionCreateNestedManyWithoutAccountLoyaltyInput = {
		create?:
			| XOR<LoyaltyTransactionCreateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput>
			| LoyaltyTransactionCreateWithoutAccountLoyaltyInput[]
			| LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput[]
		connectOrCreate?:
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput[]
		createMany?: LoyaltyTransactionCreateManyAccountLoyaltyInputEnvelope
		connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
	}

	export type LoyaltyTransactionUncheckedCreateNestedManyWithoutAccountLoyaltyInput = {
		create?:
			| XOR<LoyaltyTransactionCreateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput>
			| LoyaltyTransactionCreateWithoutAccountLoyaltyInput[]
			| LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput[]
		connectOrCreate?:
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput[]
		createMany?: LoyaltyTransactionCreateManyAccountLoyaltyInputEnvelope
		connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
	}

	export type AccountUpdateOneRequiredWithoutAccountLoyaltyNestedInput = {
		create?: XOR<AccountCreateWithoutAccountLoyaltyInput, AccountUncheckedCreateWithoutAccountLoyaltyInput>
		connectOrCreate?: AccountCreateOrConnectWithoutAccountLoyaltyInput
		upsert?: AccountUpsertWithoutAccountLoyaltyInput
		connect?: AccountWhereUniqueInput
		update?: XOR<
			XOR<AccountUpdateToOneWithWhereWithoutAccountLoyaltyInput, AccountUpdateWithoutAccountLoyaltyInput>,
			AccountUncheckedUpdateWithoutAccountLoyaltyInput
		>
	}

	export type LoyaltyLevelUpdateOneRequiredWithoutAccountLoyaltiesNestedInput = {
		create?: XOR<LoyaltyLevelCreateWithoutAccountLoyaltiesInput, LoyaltyLevelUncheckedCreateWithoutAccountLoyaltiesInput>
		connectOrCreate?: LoyaltyLevelCreateOrConnectWithoutAccountLoyaltiesInput
		upsert?: LoyaltyLevelUpsertWithoutAccountLoyaltiesInput
		connect?: LoyaltyLevelWhereUniqueInput
		update?: XOR<
			XOR<LoyaltyLevelUpdateToOneWithWhereWithoutAccountLoyaltiesInput, LoyaltyLevelUpdateWithoutAccountLoyaltiesInput>,
			LoyaltyLevelUncheckedUpdateWithoutAccountLoyaltiesInput
		>
	}

	export type LoyaltyTransactionUpdateManyWithoutAccountLoyaltyNestedInput = {
		create?:
			| XOR<LoyaltyTransactionCreateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput>
			| LoyaltyTransactionCreateWithoutAccountLoyaltyInput[]
			| LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput[]
		connectOrCreate?:
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput[]
		upsert?:
			| LoyaltyTransactionUpsertWithWhereUniqueWithoutAccountLoyaltyInput
			| LoyaltyTransactionUpsertWithWhereUniqueWithoutAccountLoyaltyInput[]
		createMany?: LoyaltyTransactionCreateManyAccountLoyaltyInputEnvelope
		set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		update?:
			| LoyaltyTransactionUpdateWithWhereUniqueWithoutAccountLoyaltyInput
			| LoyaltyTransactionUpdateWithWhereUniqueWithoutAccountLoyaltyInput[]
		updateMany?:
			| LoyaltyTransactionUpdateManyWithWhereWithoutAccountLoyaltyInput
			| LoyaltyTransactionUpdateManyWithWhereWithoutAccountLoyaltyInput[]
		deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
	}

	export type LoyaltyTransactionUncheckedUpdateManyWithoutAccountLoyaltyNestedInput = {
		create?:
			| XOR<LoyaltyTransactionCreateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput>
			| LoyaltyTransactionCreateWithoutAccountLoyaltyInput[]
			| LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput[]
		connectOrCreate?:
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput
			| LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput[]
		upsert?:
			| LoyaltyTransactionUpsertWithWhereUniqueWithoutAccountLoyaltyInput
			| LoyaltyTransactionUpsertWithWhereUniqueWithoutAccountLoyaltyInput[]
		createMany?: LoyaltyTransactionCreateManyAccountLoyaltyInputEnvelope
		set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
		update?:
			| LoyaltyTransactionUpdateWithWhereUniqueWithoutAccountLoyaltyInput
			| LoyaltyTransactionUpdateWithWhereUniqueWithoutAccountLoyaltyInput[]
		updateMany?:
			| LoyaltyTransactionUpdateManyWithWhereWithoutAccountLoyaltyInput
			| LoyaltyTransactionUpdateManyWithWhereWithoutAccountLoyaltyInput[]
		deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
	}

	export type AccountLoyaltyCreateNestedOneWithoutTransactionsInput = {
		create?: XOR<AccountLoyaltyCreateWithoutTransactionsInput, AccountLoyaltyUncheckedCreateWithoutTransactionsInput>
		connectOrCreate?: AccountLoyaltyCreateOrConnectWithoutTransactionsInput
		connect?: AccountLoyaltyWhereUniqueInput
	}

	export type EnumLoyaltyTransactionTypeFieldUpdateOperationsInput = {
		set?: $Enums.LoyaltyTransactionType
	}

	export type AccountLoyaltyUpdateOneRequiredWithoutTransactionsNestedInput = {
		create?: XOR<AccountLoyaltyCreateWithoutTransactionsInput, AccountLoyaltyUncheckedCreateWithoutTransactionsInput>
		connectOrCreate?: AccountLoyaltyCreateOrConnectWithoutTransactionsInput
		upsert?: AccountLoyaltyUpsertWithoutTransactionsInput
		connect?: AccountLoyaltyWhereUniqueInput
		update?: XOR<
			XOR<AccountLoyaltyUpdateToOneWithWhereWithoutTransactionsInput, AccountLoyaltyUpdateWithoutTransactionsInput>,
			AccountLoyaltyUncheckedUpdateWithoutTransactionsInput
		>
	}

	export type NestedStringFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel>
		in?: string[] | ListStringFieldRefInput<$PrismaModel>
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		not?: NestedStringFilter<$PrismaModel> | string
	}

	export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
		equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
		in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
	}

	export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel>
		in?: string[] | ListStringFieldRefInput<$PrismaModel>
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedStringFilter<$PrismaModel>
		_max?: NestedStringFilter<$PrismaModel>
	}

	export type NestedIntFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel>
		in?: number[] | ListIntFieldRefInput<$PrismaModel>
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntFilter<$PrismaModel> | number
	}

	export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
		in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
		not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumRoleNameFilter<$PrismaModel>
		_max?: NestedEnumRoleNameFilter<$PrismaModel>
	}

	export type NestedDateTimeFilter<$PrismaModel = never> = {
		equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		not?: NestedDateTimeFilter<$PrismaModel> | Date | string
	}

	export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
		lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
		not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedDateTimeFilter<$PrismaModel>
		_max?: NestedDateTimeFilter<$PrismaModel>
	}

	export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel>
		in?: number[] | ListIntFieldRefInput<$PrismaModel>
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
		_count?: NestedIntFilter<$PrismaModel>
		_avg?: NestedFloatFilter<$PrismaModel>
		_sum?: NestedIntFilter<$PrismaModel>
		_min?: NestedIntFilter<$PrismaModel>
		_max?: NestedIntFilter<$PrismaModel>
	}

	export type NestedFloatFilter<$PrismaModel = never> = {
		equals?: number | FloatFieldRefInput<$PrismaModel>
		in?: number[] | ListFloatFieldRefInput<$PrismaModel>
		notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
		lt?: number | FloatFieldRefInput<$PrismaModel>
		lte?: number | FloatFieldRefInput<$PrismaModel>
		gt?: number | FloatFieldRefInput<$PrismaModel>
		gte?: number | FloatFieldRefInput<$PrismaModel>
		not?: NestedFloatFilter<$PrismaModel> | number
	}

	export type NestedStringNullableFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel> | null
		in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		not?: NestedStringNullableFilter<$PrismaModel> | string | null
	}

	export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
		equals?: string | StringFieldRefInput<$PrismaModel> | null
		in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
		lt?: string | StringFieldRefInput<$PrismaModel>
		lte?: string | StringFieldRefInput<$PrismaModel>
		gt?: string | StringFieldRefInput<$PrismaModel>
		gte?: string | StringFieldRefInput<$PrismaModel>
		contains?: string | StringFieldRefInput<$PrismaModel>
		startsWith?: string | StringFieldRefInput<$PrismaModel>
		endsWith?: string | StringFieldRefInput<$PrismaModel>
		not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
		_count?: NestedIntNullableFilter<$PrismaModel>
		_min?: NestedStringNullableFilter<$PrismaModel>
		_max?: NestedStringNullableFilter<$PrismaModel>
	}

	export type NestedIntNullableFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel> | null
		in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntNullableFilter<$PrismaModel> | number | null
	}

	export type NestedBoolFilter<$PrismaModel = never> = {
		equals?: boolean | BooleanFieldRefInput<$PrismaModel>
		not?: NestedBoolFilter<$PrismaModel> | boolean
	}

	export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
		equals?: number | FloatFieldRefInput<$PrismaModel>
		in?: number[] | ListFloatFieldRefInput<$PrismaModel>
		notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
		lt?: number | FloatFieldRefInput<$PrismaModel>
		lte?: number | FloatFieldRefInput<$PrismaModel>
		gt?: number | FloatFieldRefInput<$PrismaModel>
		gte?: number | FloatFieldRefInput<$PrismaModel>
		not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
		_count?: NestedIntFilter<$PrismaModel>
		_avg?: NestedFloatFilter<$PrismaModel>
		_sum?: NestedFloatFilter<$PrismaModel>
		_min?: NestedFloatFilter<$PrismaModel>
		_max?: NestedFloatFilter<$PrismaModel>
	}

	export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
		equals?: boolean | BooleanFieldRefInput<$PrismaModel>
		not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedBoolFilter<$PrismaModel>
		_max?: NestedBoolFilter<$PrismaModel>
	}

	export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
		equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
		in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
	}

	export type NestedEnumDeliveryTypeFilter<$PrismaModel = never> = {
		equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
		in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumDeliveryTypeFilter<$PrismaModel> | $Enums.DeliveryType
	}

	export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
	}

	export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
	}

	export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
		in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumOrderStatusFilter<$PrismaModel>
		_max?: NestedEnumOrderStatusFilter<$PrismaModel>
	}
	export type NestedJsonNullableFilter<$PrismaModel = never> =
		| PatchUndefined<
				Either<
					Required<NestedJsonNullableFilterBase<$PrismaModel>>,
					Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
				>,
				Required<NestedJsonNullableFilterBase<$PrismaModel>>
		  >
		| OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

	export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
		equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
		path?: string[]
		mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
		string_contains?: string | StringFieldRefInput<$PrismaModel>
		string_starts_with?: string | StringFieldRefInput<$PrismaModel>
		string_ends_with?: string | StringFieldRefInput<$PrismaModel>
		array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
		lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
		not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
	}

	export type NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
		in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryType
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumDeliveryTypeFilter<$PrismaModel>
		_max?: NestedEnumDeliveryTypeFilter<$PrismaModel>
	}

	export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumPaymentMethodFilter<$PrismaModel>
		_max?: NestedEnumPaymentMethodFilter<$PrismaModel>
	}

	export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
		in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
		not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumPaymentStatusFilter<$PrismaModel>
		_max?: NestedEnumPaymentStatusFilter<$PrismaModel>
	}

	export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
		equals?: number | IntFieldRefInput<$PrismaModel> | null
		in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
		lt?: number | IntFieldRefInput<$PrismaModel>
		lte?: number | IntFieldRefInput<$PrismaModel>
		gt?: number | IntFieldRefInput<$PrismaModel>
		gte?: number | IntFieldRefInput<$PrismaModel>
		not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
		_count?: NestedIntNullableFilter<$PrismaModel>
		_avg?: NestedFloatNullableFilter<$PrismaModel>
		_sum?: NestedIntNullableFilter<$PrismaModel>
		_min?: NestedIntNullableFilter<$PrismaModel>
		_max?: NestedIntNullableFilter<$PrismaModel>
	}

	export type NestedFloatNullableFilter<$PrismaModel = never> = {
		equals?: number | FloatFieldRefInput<$PrismaModel> | null
		in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
		notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
		lt?: number | FloatFieldRefInput<$PrismaModel>
		lte?: number | FloatFieldRefInput<$PrismaModel>
		gt?: number | FloatFieldRefInput<$PrismaModel>
		gte?: number | FloatFieldRefInput<$PrismaModel>
		not?: NestedFloatNullableFilter<$PrismaModel> | number | null
	}

	export type NestedEnumTokenTypesFilter<$PrismaModel = never> = {
		equals?: $Enums.TokenTypes | EnumTokenTypesFieldRefInput<$PrismaModel>
		in?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		notIn?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		not?: NestedEnumTokenTypesFilter<$PrismaModel> | $Enums.TokenTypes
	}

	export type NestedEnumTokenTypesWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.TokenTypes | EnumTokenTypesFieldRefInput<$PrismaModel>
		in?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		notIn?: $Enums.TokenTypes[] | ListEnumTokenTypesFieldRefInput<$PrismaModel>
		not?: NestedEnumTokenTypesWithAggregatesFilter<$PrismaModel> | $Enums.TokenTypes
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumTokenTypesFilter<$PrismaModel>
		_max?: NestedEnumTokenTypesFilter<$PrismaModel>
	}

	export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
		equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
		in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
	}

	export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
		in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumNotificationTypeFilter<$PrismaModel>
		_max?: NestedEnumNotificationTypeFilter<$PrismaModel>
	}

	export type NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
		equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
	}

	export type NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
		equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
		not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
		_count?: NestedIntFilter<$PrismaModel>
		_min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
		_max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
	}

	export type AccountRoleCreateWithoutRoleInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutRolesInput
	}

	export type AccountRoleUncheckedCreateWithoutRoleInput = {
		id?: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountRoleCreateOrConnectWithoutRoleInput = {
		where: AccountRoleWhereUniqueInput
		create: XOR<AccountRoleCreateWithoutRoleInput, AccountRoleUncheckedCreateWithoutRoleInput>
	}

	export type AccountRoleCreateManyRoleInputEnvelope = {
		data: AccountRoleCreateManyRoleInput | AccountRoleCreateManyRoleInput[]
		skipDuplicates?: boolean
	}

	export type AccountRoleUpsertWithWhereUniqueWithoutRoleInput = {
		where: AccountRoleWhereUniqueInput
		update: XOR<AccountRoleUpdateWithoutRoleInput, AccountRoleUncheckedUpdateWithoutRoleInput>
		create: XOR<AccountRoleCreateWithoutRoleInput, AccountRoleUncheckedCreateWithoutRoleInput>
	}

	export type AccountRoleUpdateWithWhereUniqueWithoutRoleInput = {
		where: AccountRoleWhereUniqueInput
		data: XOR<AccountRoleUpdateWithoutRoleInput, AccountRoleUncheckedUpdateWithoutRoleInput>
	}

	export type AccountRoleUpdateManyWithWhereWithoutRoleInput = {
		where: AccountRoleScalarWhereInput
		data: XOR<AccountRoleUpdateManyMutationInput, AccountRoleUncheckedUpdateManyWithoutRoleInput>
	}

	export type AccountRoleScalarWhereInput = {
		AND?: AccountRoleScalarWhereInput | AccountRoleScalarWhereInput[]
		OR?: AccountRoleScalarWhereInput[]
		NOT?: AccountRoleScalarWhereInput | AccountRoleScalarWhereInput[]
		id?: StringFilter<'AccountRole'> | string
		accountId?: StringFilter<'AccountRole'> | string
		roleId?: StringFilter<'AccountRole'> | string
		createdAt?: DateTimeFilter<'AccountRole'> | Date | string
		updatedAt?: DateTimeFilter<'AccountRole'> | Date | string
	}

	export type AccountCreateWithoutRolesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutRolesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutRolesInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutRolesInput, AccountUncheckedCreateWithoutRolesInput>
	}

	export type RoleCreateWithoutAccountRolesInput = {
		id?: string
		name: $Enums.RoleName
	}

	export type RoleUncheckedCreateWithoutAccountRolesInput = {
		id?: string
		name: $Enums.RoleName
	}

	export type RoleCreateOrConnectWithoutAccountRolesInput = {
		where: RoleWhereUniqueInput
		create: XOR<RoleCreateWithoutAccountRolesInput, RoleUncheckedCreateWithoutAccountRolesInput>
	}

	export type AccountUpsertWithoutRolesInput = {
		update: XOR<AccountUpdateWithoutRolesInput, AccountUncheckedUpdateWithoutRolesInput>
		create: XOR<AccountCreateWithoutRolesInput, AccountUncheckedCreateWithoutRolesInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutRolesInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutRolesInput, AccountUncheckedUpdateWithoutRolesInput>
	}

	export type AccountUpdateWithoutRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type RoleUpsertWithoutAccountRolesInput = {
		update: XOR<RoleUpdateWithoutAccountRolesInput, RoleUncheckedUpdateWithoutAccountRolesInput>
		create: XOR<RoleCreateWithoutAccountRolesInput, RoleUncheckedCreateWithoutAccountRolesInput>
		where?: RoleWhereInput
	}

	export type RoleUpdateToOneWithWhereWithoutAccountRolesInput = {
		where?: RoleWhereInput
		data: XOR<RoleUpdateWithoutAccountRolesInput, RoleUncheckedUpdateWithoutAccountRolesInput>
	}

	export type RoleUpdateWithoutAccountRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
	}

	export type RoleUncheckedUpdateWithoutAccountRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
	}

	export type AccountCreateWithoutCartInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutCartInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutCartInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutCartInput, AccountUncheckedCreateWithoutCartInput>
	}

	export type ProductCreateWithoutCartInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		category: CategoryCreateNestedOneWithoutProductsInput
		favorite?: FavoriteCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsCreateNestedManyWithoutProductInput
		orderItem?: OrderItemCreateNestedManyWithoutProductInput
		comments?: ProductCommentCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateWithoutCartInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		favorite?: FavoriteUncheckedCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsUncheckedCreateNestedManyWithoutProductInput
		orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
		comments?: ProductCommentUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductCreateOrConnectWithoutCartInput = {
		where: ProductWhereUniqueInput
		create: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
	}

	export type AccountUpsertWithoutCartInput = {
		update: XOR<AccountUpdateWithoutCartInput, AccountUncheckedUpdateWithoutCartInput>
		create: XOR<AccountCreateWithoutCartInput, AccountUncheckedCreateWithoutCartInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutCartInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutCartInput, AccountUncheckedUpdateWithoutCartInput>
	}

	export type AccountUpdateWithoutCartInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutCartInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type ProductUpsertWithoutCartInput = {
		update: XOR<ProductUpdateWithoutCartInput, ProductUncheckedUpdateWithoutCartInput>
		create: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
		where?: ProductWhereInput
	}

	export type ProductUpdateToOneWithWhereWithoutCartInput = {
		where?: ProductWhereInput
		data: XOR<ProductUpdateWithoutCartInput, ProductUncheckedUpdateWithoutCartInput>
	}

	export type ProductUpdateWithoutCartInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
		favorite?: FavoriteUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateWithoutCartInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		favorite?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUncheckedUpdateManyWithoutProductNestedInput
	}

	export type ProductCreateWithoutCategoryInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartCreateNestedManyWithoutProductInput
		favorite?: FavoriteCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsCreateNestedManyWithoutProductInput
		orderItem?: OrderItemCreateNestedManyWithoutProductInput
		comments?: ProductCommentCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateWithoutCategoryInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutProductInput
		favorite?: FavoriteUncheckedCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsUncheckedCreateNestedManyWithoutProductInput
		orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
		comments?: ProductCommentUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductCreateOrConnectWithoutCategoryInput = {
		where: ProductWhereUniqueInput
		create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
	}

	export type ProductCreateManyCategoryInputEnvelope = {
		data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
		skipDuplicates?: boolean
	}

	export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
		where: ProductWhereUniqueInput
		update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
		create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
	}

	export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
		where: ProductWhereUniqueInput
		data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
	}

	export type ProductUpdateManyWithWhereWithoutCategoryInput = {
		where: ProductScalarWhereInput
		data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
	}

	export type ProductScalarWhereInput = {
		AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
		OR?: ProductScalarWhereInput[]
		NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
		id?: StringFilter<'Product'> | string
		title?: StringFilter<'Product'> | string
		description?: StringNullableFilter<'Product'> | string | null
		weight?: FloatFilter<'Product'> | number
		imageUrl?: StringNullableFilter<'Product'> | string | null
		price?: FloatFilter<'Product'> | number
		onSale?: BoolFilter<'Product'> | boolean
		categoryId?: StringFilter<'Product'> | string
		createdAt?: DateTimeFilter<'Product'> | Date | string
		updatedAt?: DateTimeFilter<'Product'> | Date | string
	}

	export type ProductIngredientsCreateWithoutIngredientInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		product: ProductCreateNestedOneWithoutIngredientsInput
	}

	export type ProductIngredientsUncheckedCreateWithoutIngredientInput = {
		id?: string
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductIngredientsCreateOrConnectWithoutIngredientInput = {
		where: ProductIngredientsWhereUniqueInput
		create: XOR<ProductIngredientsCreateWithoutIngredientInput, ProductIngredientsUncheckedCreateWithoutIngredientInput>
	}

	export type ProductIngredientsCreateManyIngredientInputEnvelope = {
		data: ProductIngredientsCreateManyIngredientInput | ProductIngredientsCreateManyIngredientInput[]
		skipDuplicates?: boolean
	}

	export type ProductIngredientsUpsertWithWhereUniqueWithoutIngredientInput = {
		where: ProductIngredientsWhereUniqueInput
		update: XOR<ProductIngredientsUpdateWithoutIngredientInput, ProductIngredientsUncheckedUpdateWithoutIngredientInput>
		create: XOR<ProductIngredientsCreateWithoutIngredientInput, ProductIngredientsUncheckedCreateWithoutIngredientInput>
	}

	export type ProductIngredientsUpdateWithWhereUniqueWithoutIngredientInput = {
		where: ProductIngredientsWhereUniqueInput
		data: XOR<ProductIngredientsUpdateWithoutIngredientInput, ProductIngredientsUncheckedUpdateWithoutIngredientInput>
	}

	export type ProductIngredientsUpdateManyWithWhereWithoutIngredientInput = {
		where: ProductIngredientsScalarWhereInput
		data: XOR<ProductIngredientsUpdateManyMutationInput, ProductIngredientsUncheckedUpdateManyWithoutIngredientInput>
	}

	export type ProductIngredientsScalarWhereInput = {
		AND?: ProductIngredientsScalarWhereInput | ProductIngredientsScalarWhereInput[]
		OR?: ProductIngredientsScalarWhereInput[]
		NOT?: ProductIngredientsScalarWhereInput | ProductIngredientsScalarWhereInput[]
		id?: StringFilter<'ProductIngredients'> | string
		productId?: StringFilter<'ProductIngredients'> | string
		ingredientId?: StringFilter<'ProductIngredients'> | string
		createdAt?: DateTimeFilter<'ProductIngredients'> | Date | string
		updatedAt?: DateTimeFilter<'ProductIngredients'> | Date | string
	}

	export type ProductCreateWithoutIngredientsInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		category: CategoryCreateNestedOneWithoutProductsInput
		cart?: CartCreateNestedManyWithoutProductInput
		favorite?: FavoriteCreateNestedManyWithoutProductInput
		orderItem?: OrderItemCreateNestedManyWithoutProductInput
		comments?: ProductCommentCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateWithoutIngredientsInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutProductInput
		favorite?: FavoriteUncheckedCreateNestedManyWithoutProductInput
		orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
		comments?: ProductCommentUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductCreateOrConnectWithoutIngredientsInput = {
		where: ProductWhereUniqueInput
		create: XOR<ProductCreateWithoutIngredientsInput, ProductUncheckedCreateWithoutIngredientsInput>
	}

	export type IngredientCreateWithoutProductIngredientsInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type IngredientUncheckedCreateWithoutProductIngredientsInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type IngredientCreateOrConnectWithoutProductIngredientsInput = {
		where: IngredientWhereUniqueInput
		create: XOR<IngredientCreateWithoutProductIngredientsInput, IngredientUncheckedCreateWithoutProductIngredientsInput>
	}

	export type ProductUpsertWithoutIngredientsInput = {
		update: XOR<ProductUpdateWithoutIngredientsInput, ProductUncheckedUpdateWithoutIngredientsInput>
		create: XOR<ProductCreateWithoutIngredientsInput, ProductUncheckedCreateWithoutIngredientsInput>
		where?: ProductWhereInput
	}

	export type ProductUpdateToOneWithWhereWithoutIngredientsInput = {
		where?: ProductWhereInput
		data: XOR<ProductUpdateWithoutIngredientsInput, ProductUncheckedUpdateWithoutIngredientsInput>
	}

	export type ProductUpdateWithoutIngredientsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
		cart?: CartUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateWithoutIngredientsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUncheckedUpdateManyWithoutProductNestedInput
	}

	export type IngredientUpsertWithoutProductIngredientsInput = {
		update: XOR<IngredientUpdateWithoutProductIngredientsInput, IngredientUncheckedUpdateWithoutProductIngredientsInput>
		create: XOR<IngredientCreateWithoutProductIngredientsInput, IngredientUncheckedCreateWithoutProductIngredientsInput>
		where?: IngredientWhereInput
	}

	export type IngredientUpdateToOneWithWhereWithoutProductIngredientsInput = {
		where?: IngredientWhereInput
		data: XOR<IngredientUpdateWithoutProductIngredientsInput, IngredientUncheckedUpdateWithoutProductIngredientsInput>
	}

	export type IngredientUpdateWithoutProductIngredientsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type IngredientUncheckedUpdateWithoutProductIngredientsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CategoryCreateWithoutProductsInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CategoryUncheckedCreateWithoutProductsInput = {
		id?: string
		title: string
		imageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CategoryCreateOrConnectWithoutProductsInput = {
		where: CategoryWhereUniqueInput
		create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
	}

	export type CartCreateWithoutProductInput = {
		id?: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutCartInput
	}

	export type CartUncheckedCreateWithoutProductInput = {
		id?: string
		accountId: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CartCreateOrConnectWithoutProductInput = {
		where: CartWhereUniqueInput
		create: XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
	}

	export type CartCreateManyProductInputEnvelope = {
		data: CartCreateManyProductInput | CartCreateManyProductInput[]
		skipDuplicates?: boolean
	}

	export type FavoriteCreateWithoutProductInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutFavoritesInput
	}

	export type FavoriteUncheckedCreateWithoutProductInput = {
		id?: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type FavoriteCreateOrConnectWithoutProductInput = {
		where: FavoriteWhereUniqueInput
		create: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
	}

	export type FavoriteCreateManyProductInputEnvelope = {
		data: FavoriteCreateManyProductInput | FavoriteCreateManyProductInput[]
		skipDuplicates?: boolean
	}

	export type ProductIngredientsCreateWithoutProductInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		ingredient: IngredientCreateNestedOneWithoutProductIngredientsInput
	}

	export type ProductIngredientsUncheckedCreateWithoutProductInput = {
		id?: string
		ingredientId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductIngredientsCreateOrConnectWithoutProductInput = {
		where: ProductIngredientsWhereUniqueInput
		create: XOR<ProductIngredientsCreateWithoutProductInput, ProductIngredientsUncheckedCreateWithoutProductInput>
	}

	export type ProductIngredientsCreateManyProductInputEnvelope = {
		data: ProductIngredientsCreateManyProductInput | ProductIngredientsCreateManyProductInput[]
		skipDuplicates?: boolean
	}

	export type OrderItemCreateWithoutProductInput = {
		id?: string
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		order?: OrderCreateNestedOneWithoutItemsInput
	}

	export type OrderItemUncheckedCreateWithoutProductInput = {
		id?: string
		orderId?: string | null
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderItemCreateOrConnectWithoutProductInput = {
		where: OrderItemWhereUniqueInput
		create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
	}

	export type OrderItemCreateManyProductInputEnvelope = {
		data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
		skipDuplicates?: boolean
	}

	export type ProductCommentCreateWithoutProductInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		createdAt?: Date | string
		updatedAt?: Date | string
		parent?: ProductCommentCreateNestedOneWithoutRepliesInput
		replies?: ProductCommentCreateNestedManyWithoutParentInput
		account: AccountCreateNestedOneWithoutProductCommentsInput
	}

	export type ProductCommentUncheckedCreateWithoutProductInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		replies?: ProductCommentUncheckedCreateNestedManyWithoutParentInput
	}

	export type ProductCommentCreateOrConnectWithoutProductInput = {
		where: ProductCommentWhereUniqueInput
		create: XOR<ProductCommentCreateWithoutProductInput, ProductCommentUncheckedCreateWithoutProductInput>
	}

	export type ProductCommentCreateManyProductInputEnvelope = {
		data: ProductCommentCreateManyProductInput | ProductCommentCreateManyProductInput[]
		skipDuplicates?: boolean
	}

	export type CategoryUpsertWithoutProductsInput = {
		update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
		create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
		where?: CategoryWhereInput
	}

	export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
		where?: CategoryWhereInput
		data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
	}

	export type CategoryUpdateWithoutProductsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CategoryUncheckedUpdateWithoutProductsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartUpsertWithWhereUniqueWithoutProductInput = {
		where: CartWhereUniqueInput
		update: XOR<CartUpdateWithoutProductInput, CartUncheckedUpdateWithoutProductInput>
		create: XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
	}

	export type CartUpdateWithWhereUniqueWithoutProductInput = {
		where: CartWhereUniqueInput
		data: XOR<CartUpdateWithoutProductInput, CartUncheckedUpdateWithoutProductInput>
	}

	export type CartUpdateManyWithWhereWithoutProductInput = {
		where: CartScalarWhereInput
		data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutProductInput>
	}

	export type CartScalarWhereInput = {
		AND?: CartScalarWhereInput | CartScalarWhereInput[]
		OR?: CartScalarWhereInput[]
		NOT?: CartScalarWhereInput | CartScalarWhereInput[]
		id?: StringFilter<'Cart'> | string
		accountId?: StringFilter<'Cart'> | string
		productId?: StringFilter<'Cart'> | string
		quantity?: IntFilter<'Cart'> | number
		createdAt?: DateTimeFilter<'Cart'> | Date | string
		updatedAt?: DateTimeFilter<'Cart'> | Date | string
	}

	export type FavoriteUpsertWithWhereUniqueWithoutProductInput = {
		where: FavoriteWhereUniqueInput
		update: XOR<FavoriteUpdateWithoutProductInput, FavoriteUncheckedUpdateWithoutProductInput>
		create: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
	}

	export type FavoriteUpdateWithWhereUniqueWithoutProductInput = {
		where: FavoriteWhereUniqueInput
		data: XOR<FavoriteUpdateWithoutProductInput, FavoriteUncheckedUpdateWithoutProductInput>
	}

	export type FavoriteUpdateManyWithWhereWithoutProductInput = {
		where: FavoriteScalarWhereInput
		data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutProductInput>
	}

	export type FavoriteScalarWhereInput = {
		AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
		OR?: FavoriteScalarWhereInput[]
		NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
		id?: StringFilter<'Favorite'> | string
		productId?: StringFilter<'Favorite'> | string
		accountId?: StringFilter<'Favorite'> | string
		createdAt?: DateTimeFilter<'Favorite'> | Date | string
		updatedAt?: DateTimeFilter<'Favorite'> | Date | string
	}

	export type ProductIngredientsUpsertWithWhereUniqueWithoutProductInput = {
		where: ProductIngredientsWhereUniqueInput
		update: XOR<ProductIngredientsUpdateWithoutProductInput, ProductIngredientsUncheckedUpdateWithoutProductInput>
		create: XOR<ProductIngredientsCreateWithoutProductInput, ProductIngredientsUncheckedCreateWithoutProductInput>
	}

	export type ProductIngredientsUpdateWithWhereUniqueWithoutProductInput = {
		where: ProductIngredientsWhereUniqueInput
		data: XOR<ProductIngredientsUpdateWithoutProductInput, ProductIngredientsUncheckedUpdateWithoutProductInput>
	}

	export type ProductIngredientsUpdateManyWithWhereWithoutProductInput = {
		where: ProductIngredientsScalarWhereInput
		data: XOR<ProductIngredientsUpdateManyMutationInput, ProductIngredientsUncheckedUpdateManyWithoutProductInput>
	}

	export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
		where: OrderItemWhereUniqueInput
		update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
		create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
	}

	export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
		where: OrderItemWhereUniqueInput
		data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
	}

	export type OrderItemUpdateManyWithWhereWithoutProductInput = {
		where: OrderItemScalarWhereInput
		data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
	}

	export type OrderItemScalarWhereInput = {
		AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
		OR?: OrderItemScalarWhereInput[]
		NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
		id?: StringFilter<'OrderItem'> | string
		orderId?: StringNullableFilter<'OrderItem'> | string | null
		quantity?: IntFilter<'OrderItem'> | number
		price?: FloatFilter<'OrderItem'> | number
		productTitle?: StringFilter<'OrderItem'> | string
		productDescription?: StringNullableFilter<'OrderItem'> | string | null
		productImageUrl?: StringNullableFilter<'OrderItem'> | string | null
		productId?: StringFilter<'OrderItem'> | string
		createdAt?: DateTimeFilter<'OrderItem'> | Date | string
		updatedAt?: DateTimeFilter<'OrderItem'> | Date | string
	}

	export type ProductCommentUpsertWithWhereUniqueWithoutProductInput = {
		where: ProductCommentWhereUniqueInput
		update: XOR<ProductCommentUpdateWithoutProductInput, ProductCommentUncheckedUpdateWithoutProductInput>
		create: XOR<ProductCommentCreateWithoutProductInput, ProductCommentUncheckedCreateWithoutProductInput>
	}

	export type ProductCommentUpdateWithWhereUniqueWithoutProductInput = {
		where: ProductCommentWhereUniqueInput
		data: XOR<ProductCommentUpdateWithoutProductInput, ProductCommentUncheckedUpdateWithoutProductInput>
	}

	export type ProductCommentUpdateManyWithWhereWithoutProductInput = {
		where: ProductCommentScalarWhereInput
		data: XOR<ProductCommentUpdateManyMutationInput, ProductCommentUncheckedUpdateManyWithoutProductInput>
	}

	export type ProductCommentScalarWhereInput = {
		AND?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
		OR?: ProductCommentScalarWhereInput[]
		NOT?: ProductCommentScalarWhereInput | ProductCommentScalarWhereInput[]
		id?: StringFilter<'ProductComment'> | string
		comment?: StringNullableFilter<'ProductComment'> | string | null
		rating?: IntNullableFilter<'ProductComment'> | number | null
		parentId?: StringNullableFilter<'ProductComment'> | string | null
		productId?: StringFilter<'ProductComment'> | string
		accountId?: StringFilter<'ProductComment'> | string
		createdAt?: DateTimeFilter<'ProductComment'> | Date | string
		updatedAt?: DateTimeFilter<'ProductComment'> | Date | string
	}

	export type ProductCreateWithoutFavoriteInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		category: CategoryCreateNestedOneWithoutProductsInput
		cart?: CartCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsCreateNestedManyWithoutProductInput
		orderItem?: OrderItemCreateNestedManyWithoutProductInput
		comments?: ProductCommentCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateWithoutFavoriteInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsUncheckedCreateNestedManyWithoutProductInput
		orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
		comments?: ProductCommentUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductCreateOrConnectWithoutFavoriteInput = {
		where: ProductWhereUniqueInput
		create: XOR<ProductCreateWithoutFavoriteInput, ProductUncheckedCreateWithoutFavoriteInput>
	}

	export type AccountCreateWithoutFavoritesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutFavoritesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutFavoritesInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutFavoritesInput, AccountUncheckedCreateWithoutFavoritesInput>
	}

	export type ProductUpsertWithoutFavoriteInput = {
		update: XOR<ProductUpdateWithoutFavoriteInput, ProductUncheckedUpdateWithoutFavoriteInput>
		create: XOR<ProductCreateWithoutFavoriteInput, ProductUncheckedCreateWithoutFavoriteInput>
		where?: ProductWhereInput
	}

	export type ProductUpdateToOneWithWhereWithoutFavoriteInput = {
		where?: ProductWhereInput
		data: XOR<ProductUpdateWithoutFavoriteInput, ProductUncheckedUpdateWithoutFavoriteInput>
	}

	export type ProductUpdateWithoutFavoriteInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
		cart?: CartUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateWithoutFavoriteInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUncheckedUpdateManyWithoutProductNestedInput
	}

	export type AccountUpsertWithoutFavoritesInput = {
		update: XOR<AccountUpdateWithoutFavoritesInput, AccountUncheckedUpdateWithoutFavoritesInput>
		create: XOR<AccountCreateWithoutFavoritesInput, AccountUncheckedCreateWithoutFavoritesInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutFavoritesInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutFavoritesInput, AccountUncheckedUpdateWithoutFavoritesInput>
	}

	export type AccountUpdateWithoutFavoritesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutFavoritesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountCreateWithoutAccountSettingsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutAccountSettingsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutAccountSettingsInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutAccountSettingsInput, AccountUncheckedCreateWithoutAccountSettingsInput>
	}

	export type AccountUpsertWithoutAccountSettingsInput = {
		update: XOR<AccountUpdateWithoutAccountSettingsInput, AccountUncheckedUpdateWithoutAccountSettingsInput>
		create: XOR<AccountCreateWithoutAccountSettingsInput, AccountUncheckedCreateWithoutAccountSettingsInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutAccountSettingsInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutAccountSettingsInput, AccountUncheckedUpdateWithoutAccountSettingsInput>
	}

	export type AccountUpdateWithoutAccountSettingsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutAccountSettingsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountRoleCreateWithoutAccountInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		role: RoleCreateNestedOneWithoutAccountRolesInput
	}

	export type AccountRoleUncheckedCreateWithoutAccountInput = {
		id?: string
		roleId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountRoleCreateOrConnectWithoutAccountInput = {
		where: AccountRoleWhereUniqueInput
		create: XOR<AccountRoleCreateWithoutAccountInput, AccountRoleUncheckedCreateWithoutAccountInput>
	}

	export type AccountRoleCreateManyAccountInputEnvelope = {
		data: AccountRoleCreateManyAccountInput | AccountRoleCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type CartCreateWithoutAccountInput = {
		id?: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
		product: ProductCreateNestedOneWithoutCartInput
	}

	export type CartUncheckedCreateWithoutAccountInput = {
		id?: string
		productId: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CartCreateOrConnectWithoutAccountInput = {
		where: CartWhereUniqueInput
		create: XOR<CartCreateWithoutAccountInput, CartUncheckedCreateWithoutAccountInput>
	}

	export type CartCreateManyAccountInputEnvelope = {
		data: CartCreateManyAccountInput | CartCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type FavoriteCreateWithoutAccountInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		product: ProductCreateNestedOneWithoutFavoriteInput
	}

	export type FavoriteUncheckedCreateWithoutAccountInput = {
		id?: string
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type FavoriteCreateOrConnectWithoutAccountInput = {
		where: FavoriteWhereUniqueInput
		create: XOR<FavoriteCreateWithoutAccountInput, FavoriteUncheckedCreateWithoutAccountInput>
	}

	export type FavoriteCreateManyAccountInputEnvelope = {
		data: FavoriteCreateManyAccountInput | FavoriteCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type OrderCreateWithoutAccountInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		createdAt?: Date | string
		updatedAt?: Date | string
		items?: OrderItemCreateNestedManyWithoutOrderInput
	}

	export type OrderUncheckedCreateWithoutAccountInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		createdAt?: Date | string
		updatedAt?: Date | string
		items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
	}

	export type OrderCreateOrConnectWithoutAccountInput = {
		where: OrderWhereUniqueInput
		create: XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
	}

	export type OrderCreateManyAccountInputEnvelope = {
		data: OrderCreateManyAccountInput | OrderCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type ProductCommentCreateWithoutAccountInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		createdAt?: Date | string
		updatedAt?: Date | string
		parent?: ProductCommentCreateNestedOneWithoutRepliesInput
		replies?: ProductCommentCreateNestedManyWithoutParentInput
		product: ProductCreateNestedOneWithoutCommentsInput
	}

	export type ProductCommentUncheckedCreateWithoutAccountInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		replies?: ProductCommentUncheckedCreateNestedManyWithoutParentInput
	}

	export type ProductCommentCreateOrConnectWithoutAccountInput = {
		where: ProductCommentWhereUniqueInput
		create: XOR<ProductCommentCreateWithoutAccountInput, ProductCommentUncheckedCreateWithoutAccountInput>
	}

	export type ProductCommentCreateManyAccountInputEnvelope = {
		data: ProductCommentCreateManyAccountInput | ProductCommentCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type DeliveryAddressCreateWithoutAccountInput = {
		id?: string
		city: string
		street: string
		house: string
		flat: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type DeliveryAddressUncheckedCreateWithoutAccountInput = {
		id?: string
		city: string
		street: string
		house: string
		flat: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type DeliveryAddressCreateOrConnectWithoutAccountInput = {
		where: DeliveryAddressWhereUniqueInput
		create: XOR<DeliveryAddressCreateWithoutAccountInput, DeliveryAddressUncheckedCreateWithoutAccountInput>
	}

	export type DeliveryAddressCreateManyAccountInputEnvelope = {
		data: DeliveryAddressCreateManyAccountInput | DeliveryAddressCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type NotificationCreateWithoutAccountInput = {
		id?: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type NotificationUncheckedCreateWithoutAccountInput = {
		id?: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type NotificationCreateOrConnectWithoutAccountInput = {
		where: NotificationWhereUniqueInput
		create: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
	}

	export type NotificationCreateManyAccountInputEnvelope = {
		data: NotificationCreateManyAccountInput | NotificationCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type PostCreateWithoutAuthorInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		comments?: PostCommentCreateNestedManyWithoutPostInput
		likes?: PostLikeCreateNestedManyWithoutPostInput
	}

	export type PostUncheckedCreateWithoutAuthorInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
		likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
	}

	export type PostCreateOrConnectWithoutAuthorInput = {
		where: PostWhereUniqueInput
		create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
	}

	export type PostCreateManyAuthorInputEnvelope = {
		data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
		skipDuplicates?: boolean
	}

	export type PostCommentCreateWithoutAuthorInput = {
		id?: string
		comment: string
		createdAt?: Date | string
		updatedAt?: Date | string
		post: PostCreateNestedOneWithoutCommentsInput
	}

	export type PostCommentUncheckedCreateWithoutAuthorInput = {
		id?: string
		comment: string
		postId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCommentCreateOrConnectWithoutAuthorInput = {
		where: PostCommentWhereUniqueInput
		create: XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
	}

	export type PostCommentCreateManyAuthorInputEnvelope = {
		data: PostCommentCreateManyAuthorInput | PostCommentCreateManyAuthorInput[]
		skipDuplicates?: boolean
	}

	export type PostLikeCreateWithoutAccountInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		post: PostCreateNestedOneWithoutLikesInput
	}

	export type PostLikeUncheckedCreateWithoutAccountInput = {
		id?: string
		postId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostLikeCreateOrConnectWithoutAccountInput = {
		where: PostLikeWhereUniqueInput
		create: XOR<PostLikeCreateWithoutAccountInput, PostLikeUncheckedCreateWithoutAccountInput>
	}

	export type PostLikeCreateManyAccountInputEnvelope = {
		data: PostLikeCreateManyAccountInput | PostLikeCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type TokenCreateWithoutAccountInput = {
		id?: string
		token: string
		type: $Enums.TokenTypes
		expiresIn: Date | string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type TokenUncheckedCreateWithoutAccountInput = {
		id?: string
		token: string
		type: $Enums.TokenTypes
		expiresIn: Date | string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type TokenCreateOrConnectWithoutAccountInput = {
		where: TokenWhereUniqueInput
		create: XOR<TokenCreateWithoutAccountInput, TokenUncheckedCreateWithoutAccountInput>
	}

	export type TokenCreateManyAccountInputEnvelope = {
		data: TokenCreateManyAccountInput | TokenCreateManyAccountInput[]
		skipDuplicates?: boolean
	}

	export type AccountSettingsCreateWithoutAccountInput = {
		id?: string
		telegramId?: string | null
		isVerifiedEmail?: boolean
		isTwoFactorEmailEnabled?: boolean
		isTwoFactorTotpEnabled?: boolean
		totpSecret?: string | null
		siteNotification?: boolean
		telegramNotification?: boolean
	}

	export type AccountSettingsUncheckedCreateWithoutAccountInput = {
		id?: string
		telegramId?: string | null
		isVerifiedEmail?: boolean
		isTwoFactorEmailEnabled?: boolean
		isTwoFactorTotpEnabled?: boolean
		totpSecret?: string | null
		siteNotification?: boolean
		telegramNotification?: boolean
	}

	export type AccountSettingsCreateOrConnectWithoutAccountInput = {
		where: AccountSettingsWhereUniqueInput
		create: XOR<AccountSettingsCreateWithoutAccountInput, AccountSettingsUncheckedCreateWithoutAccountInput>
	}

	export type AccountLoyaltyCreateWithoutAccountInput = {
		id?: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		loyaltyLevel: LoyaltyLevelCreateNestedOneWithoutAccountLoyaltiesInput
		transactions?: LoyaltyTransactionCreateNestedManyWithoutAccountLoyaltyInput
	}

	export type AccountLoyaltyUncheckedCreateWithoutAccountInput = {
		id?: string
		loyaltyLevelId: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutAccountLoyaltyInput
	}

	export type AccountLoyaltyCreateOrConnectWithoutAccountInput = {
		where: AccountLoyaltyWhereUniqueInput
		create: XOR<AccountLoyaltyCreateWithoutAccountInput, AccountLoyaltyUncheckedCreateWithoutAccountInput>
	}

	export type SupportMessageCreateWithoutSenderInput = {
		id?: string
		message: string
		createdAt?: Date | string
		updatedAt?: Date | string
		receiver: AccountCreateNestedOneWithoutReceivedMessagesInput
	}

	export type SupportMessageUncheckedCreateWithoutSenderInput = {
		id?: string
		message: string
		receiverId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type SupportMessageCreateOrConnectWithoutSenderInput = {
		where: SupportMessageWhereUniqueInput
		create: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
	}

	export type SupportMessageCreateManySenderInputEnvelope = {
		data: SupportMessageCreateManySenderInput | SupportMessageCreateManySenderInput[]
		skipDuplicates?: boolean
	}

	export type SupportMessageCreateWithoutReceiverInput = {
		id?: string
		message: string
		createdAt?: Date | string
		updatedAt?: Date | string
		sender: AccountCreateNestedOneWithoutSentMessagesInput
	}

	export type SupportMessageUncheckedCreateWithoutReceiverInput = {
		id?: string
		message: string
		senderId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type SupportMessageCreateOrConnectWithoutReceiverInput = {
		where: SupportMessageWhereUniqueInput
		create: XOR<SupportMessageCreateWithoutReceiverInput, SupportMessageUncheckedCreateWithoutReceiverInput>
	}

	export type SupportMessageCreateManyReceiverInputEnvelope = {
		data: SupportMessageCreateManyReceiverInput | SupportMessageCreateManyReceiverInput[]
		skipDuplicates?: boolean
	}

	export type AccountRoleUpsertWithWhereUniqueWithoutAccountInput = {
		where: AccountRoleWhereUniqueInput
		update: XOR<AccountRoleUpdateWithoutAccountInput, AccountRoleUncheckedUpdateWithoutAccountInput>
		create: XOR<AccountRoleCreateWithoutAccountInput, AccountRoleUncheckedCreateWithoutAccountInput>
	}

	export type AccountRoleUpdateWithWhereUniqueWithoutAccountInput = {
		where: AccountRoleWhereUniqueInput
		data: XOR<AccountRoleUpdateWithoutAccountInput, AccountRoleUncheckedUpdateWithoutAccountInput>
	}

	export type AccountRoleUpdateManyWithWhereWithoutAccountInput = {
		where: AccountRoleScalarWhereInput
		data: XOR<AccountRoleUpdateManyMutationInput, AccountRoleUncheckedUpdateManyWithoutAccountInput>
	}

	export type CartUpsertWithWhereUniqueWithoutAccountInput = {
		where: CartWhereUniqueInput
		update: XOR<CartUpdateWithoutAccountInput, CartUncheckedUpdateWithoutAccountInput>
		create: XOR<CartCreateWithoutAccountInput, CartUncheckedCreateWithoutAccountInput>
	}

	export type CartUpdateWithWhereUniqueWithoutAccountInput = {
		where: CartWhereUniqueInput
		data: XOR<CartUpdateWithoutAccountInput, CartUncheckedUpdateWithoutAccountInput>
	}

	export type CartUpdateManyWithWhereWithoutAccountInput = {
		where: CartScalarWhereInput
		data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutAccountInput>
	}

	export type FavoriteUpsertWithWhereUniqueWithoutAccountInput = {
		where: FavoriteWhereUniqueInput
		update: XOR<FavoriteUpdateWithoutAccountInput, FavoriteUncheckedUpdateWithoutAccountInput>
		create: XOR<FavoriteCreateWithoutAccountInput, FavoriteUncheckedCreateWithoutAccountInput>
	}

	export type FavoriteUpdateWithWhereUniqueWithoutAccountInput = {
		where: FavoriteWhereUniqueInput
		data: XOR<FavoriteUpdateWithoutAccountInput, FavoriteUncheckedUpdateWithoutAccountInput>
	}

	export type FavoriteUpdateManyWithWhereWithoutAccountInput = {
		where: FavoriteScalarWhereInput
		data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutAccountInput>
	}

	export type OrderUpsertWithWhereUniqueWithoutAccountInput = {
		where: OrderWhereUniqueInput
		update: XOR<OrderUpdateWithoutAccountInput, OrderUncheckedUpdateWithoutAccountInput>
		create: XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
	}

	export type OrderUpdateWithWhereUniqueWithoutAccountInput = {
		where: OrderWhereUniqueInput
		data: XOR<OrderUpdateWithoutAccountInput, OrderUncheckedUpdateWithoutAccountInput>
	}

	export type OrderUpdateManyWithWhereWithoutAccountInput = {
		where: OrderScalarWhereInput
		data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutAccountInput>
	}

	export type OrderScalarWhereInput = {
		AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
		OR?: OrderScalarWhereInput[]
		NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
		id?: StringFilter<'Order'> | string
		status?: EnumOrderStatusFilter<'Order'> | $Enums.OrderStatus
		firstName?: StringFilter<'Order'> | string
		lastName?: StringFilter<'Order'> | string
		phone?: StringFilter<'Order'> | string
		email?: StringNullableFilter<'Order'> | string | null
		deliveryAddressId?: StringNullableFilter<'Order'> | string | null
		deliveryAddress?: JsonNullableFilter<'Order'>
		deliveryType?: EnumDeliveryTypeFilter<'Order'> | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFilter<'Order'> | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFilter<'Order'> | $Enums.PaymentStatus
		comment?: StringNullableFilter<'Order'> | string | null
		total?: FloatFilter<'Order'> | number
		accountId?: StringNullableFilter<'Order'> | string | null
		createdAt?: DateTimeFilter<'Order'> | Date | string
		updatedAt?: DateTimeFilter<'Order'> | Date | string
	}

	export type ProductCommentUpsertWithWhereUniqueWithoutAccountInput = {
		where: ProductCommentWhereUniqueInput
		update: XOR<ProductCommentUpdateWithoutAccountInput, ProductCommentUncheckedUpdateWithoutAccountInput>
		create: XOR<ProductCommentCreateWithoutAccountInput, ProductCommentUncheckedCreateWithoutAccountInput>
	}

	export type ProductCommentUpdateWithWhereUniqueWithoutAccountInput = {
		where: ProductCommentWhereUniqueInput
		data: XOR<ProductCommentUpdateWithoutAccountInput, ProductCommentUncheckedUpdateWithoutAccountInput>
	}

	export type ProductCommentUpdateManyWithWhereWithoutAccountInput = {
		where: ProductCommentScalarWhereInput
		data: XOR<ProductCommentUpdateManyMutationInput, ProductCommentUncheckedUpdateManyWithoutAccountInput>
	}

	export type DeliveryAddressUpsertWithWhereUniqueWithoutAccountInput = {
		where: DeliveryAddressWhereUniqueInput
		update: XOR<DeliveryAddressUpdateWithoutAccountInput, DeliveryAddressUncheckedUpdateWithoutAccountInput>
		create: XOR<DeliveryAddressCreateWithoutAccountInput, DeliveryAddressUncheckedCreateWithoutAccountInput>
	}

	export type DeliveryAddressUpdateWithWhereUniqueWithoutAccountInput = {
		where: DeliveryAddressWhereUniqueInput
		data: XOR<DeliveryAddressUpdateWithoutAccountInput, DeliveryAddressUncheckedUpdateWithoutAccountInput>
	}

	export type DeliveryAddressUpdateManyWithWhereWithoutAccountInput = {
		where: DeliveryAddressScalarWhereInput
		data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyWithoutAccountInput>
	}

	export type DeliveryAddressScalarWhereInput = {
		AND?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
		OR?: DeliveryAddressScalarWhereInput[]
		NOT?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
		id?: StringFilter<'DeliveryAddress'> | string
		accountId?: StringFilter<'DeliveryAddress'> | string
		city?: StringFilter<'DeliveryAddress'> | string
		street?: StringFilter<'DeliveryAddress'> | string
		house?: StringFilter<'DeliveryAddress'> | string
		flat?: StringFilter<'DeliveryAddress'> | string
		createdAt?: DateTimeFilter<'DeliveryAddress'> | Date | string
		updatedAt?: DateTimeFilter<'DeliveryAddress'> | Date | string
	}

	export type NotificationUpsertWithWhereUniqueWithoutAccountInput = {
		where: NotificationWhereUniqueInput
		update: XOR<NotificationUpdateWithoutAccountInput, NotificationUncheckedUpdateWithoutAccountInput>
		create: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
	}

	export type NotificationUpdateWithWhereUniqueWithoutAccountInput = {
		where: NotificationWhereUniqueInput
		data: XOR<NotificationUpdateWithoutAccountInput, NotificationUncheckedUpdateWithoutAccountInput>
	}

	export type NotificationUpdateManyWithWhereWithoutAccountInput = {
		where: NotificationScalarWhereInput
		data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAccountInput>
	}

	export type NotificationScalarWhereInput = {
		AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
		OR?: NotificationScalarWhereInput[]
		NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
		id?: StringFilter<'Notification'> | string
		title?: StringFilter<'Notification'> | string
		message?: StringFilter<'Notification'> | string
		link?: StringFilter<'Notification'> | string
		type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType
		isRead?: BoolFilter<'Notification'> | boolean
		accountId?: StringFilter<'Notification'> | string
		createdAt?: DateTimeFilter<'Notification'> | Date | string
		updatedAt?: DateTimeFilter<'Notification'> | Date | string
	}

	export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
		where: PostWhereUniqueInput
		update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
		create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
	}

	export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
		where: PostWhereUniqueInput
		data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
	}

	export type PostUpdateManyWithWhereWithoutAuthorInput = {
		where: PostScalarWhereInput
		data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
	}

	export type PostScalarWhereInput = {
		AND?: PostScalarWhereInput | PostScalarWhereInput[]
		OR?: PostScalarWhereInput[]
		NOT?: PostScalarWhereInput | PostScalarWhereInput[]
		id?: StringFilter<'Post'> | string
		title?: StringFilter<'Post'> | string
		description?: StringNullableFilter<'Post'> | string | null
		imageUrl?: StringNullableFilter<'Post'> | string | null
		published?: BoolFilter<'Post'> | boolean
		authorId?: StringFilter<'Post'> | string
		createdAt?: DateTimeFilter<'Post'> | Date | string
		updatedAt?: DateTimeFilter<'Post'> | Date | string
	}

	export type PostCommentUpsertWithWhereUniqueWithoutAuthorInput = {
		where: PostCommentWhereUniqueInput
		update: XOR<PostCommentUpdateWithoutAuthorInput, PostCommentUncheckedUpdateWithoutAuthorInput>
		create: XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
	}

	export type PostCommentUpdateWithWhereUniqueWithoutAuthorInput = {
		where: PostCommentWhereUniqueInput
		data: XOR<PostCommentUpdateWithoutAuthorInput, PostCommentUncheckedUpdateWithoutAuthorInput>
	}

	export type PostCommentUpdateManyWithWhereWithoutAuthorInput = {
		where: PostCommentScalarWhereInput
		data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutAuthorInput>
	}

	export type PostCommentScalarWhereInput = {
		AND?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
		OR?: PostCommentScalarWhereInput[]
		NOT?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
		id?: StringFilter<'PostComment'> | string
		comment?: StringFilter<'PostComment'> | string
		authorId?: StringFilter<'PostComment'> | string
		postId?: StringFilter<'PostComment'> | string
		createdAt?: DateTimeFilter<'PostComment'> | Date | string
		updatedAt?: DateTimeFilter<'PostComment'> | Date | string
	}

	export type PostLikeUpsertWithWhereUniqueWithoutAccountInput = {
		where: PostLikeWhereUniqueInput
		update: XOR<PostLikeUpdateWithoutAccountInput, PostLikeUncheckedUpdateWithoutAccountInput>
		create: XOR<PostLikeCreateWithoutAccountInput, PostLikeUncheckedCreateWithoutAccountInput>
	}

	export type PostLikeUpdateWithWhereUniqueWithoutAccountInput = {
		where: PostLikeWhereUniqueInput
		data: XOR<PostLikeUpdateWithoutAccountInput, PostLikeUncheckedUpdateWithoutAccountInput>
	}

	export type PostLikeUpdateManyWithWhereWithoutAccountInput = {
		where: PostLikeScalarWhereInput
		data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutAccountInput>
	}

	export type PostLikeScalarWhereInput = {
		AND?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
		OR?: PostLikeScalarWhereInput[]
		NOT?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
		id?: StringFilter<'PostLike'> | string
		postId?: StringFilter<'PostLike'> | string
		accountId?: StringFilter<'PostLike'> | string
		createdAt?: DateTimeFilter<'PostLike'> | Date | string
		updatedAt?: DateTimeFilter<'PostLike'> | Date | string
	}

	export type TokenUpsertWithWhereUniqueWithoutAccountInput = {
		where: TokenWhereUniqueInput
		update: XOR<TokenUpdateWithoutAccountInput, TokenUncheckedUpdateWithoutAccountInput>
		create: XOR<TokenCreateWithoutAccountInput, TokenUncheckedCreateWithoutAccountInput>
	}

	export type TokenUpdateWithWhereUniqueWithoutAccountInput = {
		where: TokenWhereUniqueInput
		data: XOR<TokenUpdateWithoutAccountInput, TokenUncheckedUpdateWithoutAccountInput>
	}

	export type TokenUpdateManyWithWhereWithoutAccountInput = {
		where: TokenScalarWhereInput
		data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutAccountInput>
	}

	export type TokenScalarWhereInput = {
		AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
		OR?: TokenScalarWhereInput[]
		NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
		id?: StringFilter<'Token'> | string
		token?: StringFilter<'Token'> | string
		type?: EnumTokenTypesFilter<'Token'> | $Enums.TokenTypes
		accountId?: StringFilter<'Token'> | string
		expiresIn?: DateTimeFilter<'Token'> | Date | string
		createdAt?: DateTimeFilter<'Token'> | Date | string
		updatedAt?: DateTimeFilter<'Token'> | Date | string
	}

	export type AccountSettingsUpsertWithoutAccountInput = {
		update: XOR<AccountSettingsUpdateWithoutAccountInput, AccountSettingsUncheckedUpdateWithoutAccountInput>
		create: XOR<AccountSettingsCreateWithoutAccountInput, AccountSettingsUncheckedCreateWithoutAccountInput>
		where?: AccountSettingsWhereInput
	}

	export type AccountSettingsUpdateToOneWithWhereWithoutAccountInput = {
		where?: AccountSettingsWhereInput
		data: XOR<AccountSettingsUpdateWithoutAccountInput, AccountSettingsUncheckedUpdateWithoutAccountInput>
	}

	export type AccountSettingsUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		telegramId?: NullableStringFieldUpdateOperationsInput | string | null
		isVerifiedEmail?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorTotpEnabled?: BoolFieldUpdateOperationsInput | boolean
		totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
		siteNotification?: BoolFieldUpdateOperationsInput | boolean
		telegramNotification?: BoolFieldUpdateOperationsInput | boolean
	}

	export type AccountSettingsUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		telegramId?: NullableStringFieldUpdateOperationsInput | string | null
		isVerifiedEmail?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
		isTwoFactorTotpEnabled?: BoolFieldUpdateOperationsInput | boolean
		totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
		siteNotification?: BoolFieldUpdateOperationsInput | boolean
		telegramNotification?: BoolFieldUpdateOperationsInput | boolean
	}

	export type AccountLoyaltyUpsertWithoutAccountInput = {
		update: XOR<AccountLoyaltyUpdateWithoutAccountInput, AccountLoyaltyUncheckedUpdateWithoutAccountInput>
		create: XOR<AccountLoyaltyCreateWithoutAccountInput, AccountLoyaltyUncheckedCreateWithoutAccountInput>
		where?: AccountLoyaltyWhereInput
	}

	export type AccountLoyaltyUpdateToOneWithWhereWithoutAccountInput = {
		where?: AccountLoyaltyWhereInput
		data: XOR<AccountLoyaltyUpdateWithoutAccountInput, AccountLoyaltyUncheckedUpdateWithoutAccountInput>
	}

	export type AccountLoyaltyUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		loyaltyLevel?: LoyaltyLevelUpdateOneRequiredWithoutAccountLoyaltiesNestedInput
		transactions?: LoyaltyTransactionUpdateManyWithoutAccountLoyaltyNestedInput
	}

	export type AccountLoyaltyUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		loyaltyLevelId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutAccountLoyaltyNestedInput
	}

	export type SupportMessageUpsertWithWhereUniqueWithoutSenderInput = {
		where: SupportMessageWhereUniqueInput
		update: XOR<SupportMessageUpdateWithoutSenderInput, SupportMessageUncheckedUpdateWithoutSenderInput>
		create: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
	}

	export type SupportMessageUpdateWithWhereUniqueWithoutSenderInput = {
		where: SupportMessageWhereUniqueInput
		data: XOR<SupportMessageUpdateWithoutSenderInput, SupportMessageUncheckedUpdateWithoutSenderInput>
	}

	export type SupportMessageUpdateManyWithWhereWithoutSenderInput = {
		where: SupportMessageScalarWhereInput
		data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutSenderInput>
	}

	export type SupportMessageScalarWhereInput = {
		AND?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
		OR?: SupportMessageScalarWhereInput[]
		NOT?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
		id?: StringFilter<'SupportMessage'> | string
		message?: StringFilter<'SupportMessage'> | string
		senderId?: StringFilter<'SupportMessage'> | string
		receiverId?: StringFilter<'SupportMessage'> | string
		createdAt?: DateTimeFilter<'SupportMessage'> | Date | string
		updatedAt?: DateTimeFilter<'SupportMessage'> | Date | string
	}

	export type SupportMessageUpsertWithWhereUniqueWithoutReceiverInput = {
		where: SupportMessageWhereUniqueInput
		update: XOR<SupportMessageUpdateWithoutReceiverInput, SupportMessageUncheckedUpdateWithoutReceiverInput>
		create: XOR<SupportMessageCreateWithoutReceiverInput, SupportMessageUncheckedCreateWithoutReceiverInput>
	}

	export type SupportMessageUpdateWithWhereUniqueWithoutReceiverInput = {
		where: SupportMessageWhereUniqueInput
		data: XOR<SupportMessageUpdateWithoutReceiverInput, SupportMessageUncheckedUpdateWithoutReceiverInput>
	}

	export type SupportMessageUpdateManyWithWhereWithoutReceiverInput = {
		where: SupportMessageScalarWhereInput
		data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutReceiverInput>
	}

	export type AccountCreateWithoutDeliveryAdressesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutDeliveryAdressesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutDeliveryAdressesInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutDeliveryAdressesInput, AccountUncheckedCreateWithoutDeliveryAdressesInput>
	}

	export type AccountUpsertWithoutDeliveryAdressesInput = {
		update: XOR<AccountUpdateWithoutDeliveryAdressesInput, AccountUncheckedUpdateWithoutDeliveryAdressesInput>
		create: XOR<AccountCreateWithoutDeliveryAdressesInput, AccountUncheckedCreateWithoutDeliveryAdressesInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutDeliveryAdressesInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutDeliveryAdressesInput, AccountUncheckedUpdateWithoutDeliveryAdressesInput>
	}

	export type AccountUpdateWithoutDeliveryAdressesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutDeliveryAdressesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type OrderItemCreateWithoutOrderInput = {
		id?: string
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		product: ProductCreateNestedOneWithoutOrderItemInput
	}

	export type OrderItemUncheckedCreateWithoutOrderInput = {
		id?: string
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderItemCreateOrConnectWithoutOrderInput = {
		where: OrderItemWhereUniqueInput
		create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
	}

	export type OrderItemCreateManyOrderInputEnvelope = {
		data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
		skipDuplicates?: boolean
	}

	export type AccountCreateWithoutOrdersInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutOrdersInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutOrdersInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
	}

	export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
		where: OrderItemWhereUniqueInput
		update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
		create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
	}

	export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
		where: OrderItemWhereUniqueInput
		data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
	}

	export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
		where: OrderItemScalarWhereInput
		data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
	}

	export type AccountUpsertWithoutOrdersInput = {
		update: XOR<AccountUpdateWithoutOrdersInput, AccountUncheckedUpdateWithoutOrdersInput>
		create: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutOrdersInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutOrdersInput, AccountUncheckedUpdateWithoutOrdersInput>
	}

	export type AccountUpdateWithoutOrdersInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutOrdersInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type OrderCreateWithoutItemsInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		createdAt?: Date | string
		updatedAt?: Date | string
		account?: AccountCreateNestedOneWithoutOrdersInput
	}

	export type OrderUncheckedCreateWithoutItemsInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		accountId?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderCreateOrConnectWithoutItemsInput = {
		where: OrderWhereUniqueInput
		create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
	}

	export type ProductCreateWithoutOrderItemInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		category: CategoryCreateNestedOneWithoutProductsInput
		cart?: CartCreateNestedManyWithoutProductInput
		favorite?: FavoriteCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsCreateNestedManyWithoutProductInput
		comments?: ProductCommentCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateWithoutOrderItemInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutProductInput
		favorite?: FavoriteUncheckedCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsUncheckedCreateNestedManyWithoutProductInput
		comments?: ProductCommentUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductCreateOrConnectWithoutOrderItemInput = {
		where: ProductWhereUniqueInput
		create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
	}

	export type OrderUpsertWithoutItemsInput = {
		update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
		create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
		where?: OrderWhereInput
	}

	export type OrderUpdateToOneWithWhereWithoutItemsInput = {
		where?: OrderWhereInput
		data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
	}

	export type OrderUpdateWithoutItemsInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneWithoutOrdersNestedInput
	}

	export type OrderUncheckedUpdateWithoutItemsInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		accountId?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductUpsertWithoutOrderItemInput = {
		update: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>
		create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
		where?: ProductWhereInput
	}

	export type ProductUpdateToOneWithWhereWithoutOrderItemInput = {
		where?: ProductWhereInput
		data: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>
	}

	export type ProductUpdateWithoutOrderItemInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
		cart?: CartUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateWithoutOrderItemInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUncheckedUpdateManyWithoutProductNestedInput
	}

	export type ProductCommentCreateWithoutRepliesInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		createdAt?: Date | string
		updatedAt?: Date | string
		parent?: ProductCommentCreateNestedOneWithoutRepliesInput
		product: ProductCreateNestedOneWithoutCommentsInput
		account: AccountCreateNestedOneWithoutProductCommentsInput
	}

	export type ProductCommentUncheckedCreateWithoutRepliesInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductCommentCreateOrConnectWithoutRepliesInput = {
		where: ProductCommentWhereUniqueInput
		create: XOR<ProductCommentCreateWithoutRepliesInput, ProductCommentUncheckedCreateWithoutRepliesInput>
	}

	export type ProductCommentCreateWithoutParentInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		createdAt?: Date | string
		updatedAt?: Date | string
		replies?: ProductCommentCreateNestedManyWithoutParentInput
		product: ProductCreateNestedOneWithoutCommentsInput
		account: AccountCreateNestedOneWithoutProductCommentsInput
	}

	export type ProductCommentUncheckedCreateWithoutParentInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		replies?: ProductCommentUncheckedCreateNestedManyWithoutParentInput
	}

	export type ProductCommentCreateOrConnectWithoutParentInput = {
		where: ProductCommentWhereUniqueInput
		create: XOR<ProductCommentCreateWithoutParentInput, ProductCommentUncheckedCreateWithoutParentInput>
	}

	export type ProductCommentCreateManyParentInputEnvelope = {
		data: ProductCommentCreateManyParentInput | ProductCommentCreateManyParentInput[]
		skipDuplicates?: boolean
	}

	export type ProductCreateWithoutCommentsInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		category: CategoryCreateNestedOneWithoutProductsInput
		cart?: CartCreateNestedManyWithoutProductInput
		favorite?: FavoriteCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsCreateNestedManyWithoutProductInput
		orderItem?: OrderItemCreateNestedManyWithoutProductInput
	}

	export type ProductUncheckedCreateWithoutCommentsInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		categoryId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		cart?: CartUncheckedCreateNestedManyWithoutProductInput
		favorite?: FavoriteUncheckedCreateNestedManyWithoutProductInput
		ingredients?: ProductIngredientsUncheckedCreateNestedManyWithoutProductInput
		orderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
	}

	export type ProductCreateOrConnectWithoutCommentsInput = {
		where: ProductWhereUniqueInput
		create: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
	}

	export type AccountCreateWithoutProductCommentsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutProductCommentsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutProductCommentsInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutProductCommentsInput, AccountUncheckedCreateWithoutProductCommentsInput>
	}

	export type ProductCommentUpsertWithoutRepliesInput = {
		update: XOR<ProductCommentUpdateWithoutRepliesInput, ProductCommentUncheckedUpdateWithoutRepliesInput>
		create: XOR<ProductCommentCreateWithoutRepliesInput, ProductCommentUncheckedCreateWithoutRepliesInput>
		where?: ProductCommentWhereInput
	}

	export type ProductCommentUpdateToOneWithWhereWithoutRepliesInput = {
		where?: ProductCommentWhereInput
		data: XOR<ProductCommentUpdateWithoutRepliesInput, ProductCommentUncheckedUpdateWithoutRepliesInput>
	}

	export type ProductCommentUpdateWithoutRepliesInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		parent?: ProductCommentUpdateOneWithoutRepliesNestedInput
		product?: ProductUpdateOneRequiredWithoutCommentsNestedInput
		account?: AccountUpdateOneRequiredWithoutProductCommentsNestedInput
	}

	export type ProductCommentUncheckedUpdateWithoutRepliesInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCommentUpsertWithWhereUniqueWithoutParentInput = {
		where: ProductCommentWhereUniqueInput
		update: XOR<ProductCommentUpdateWithoutParentInput, ProductCommentUncheckedUpdateWithoutParentInput>
		create: XOR<ProductCommentCreateWithoutParentInput, ProductCommentUncheckedCreateWithoutParentInput>
	}

	export type ProductCommentUpdateWithWhereUniqueWithoutParentInput = {
		where: ProductCommentWhereUniqueInput
		data: XOR<ProductCommentUpdateWithoutParentInput, ProductCommentUncheckedUpdateWithoutParentInput>
	}

	export type ProductCommentUpdateManyWithWhereWithoutParentInput = {
		where: ProductCommentScalarWhereInput
		data: XOR<ProductCommentUpdateManyMutationInput, ProductCommentUncheckedUpdateManyWithoutParentInput>
	}

	export type ProductUpsertWithoutCommentsInput = {
		update: XOR<ProductUpdateWithoutCommentsInput, ProductUncheckedUpdateWithoutCommentsInput>
		create: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
		where?: ProductWhereInput
	}

	export type ProductUpdateToOneWithWhereWithoutCommentsInput = {
		where?: ProductWhereInput
		data: XOR<ProductUpdateWithoutCommentsInput, ProductUncheckedUpdateWithoutCommentsInput>
	}

	export type ProductUpdateWithoutCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
		cart?: CartUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateWithoutCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		categoryId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
	}

	export type AccountUpsertWithoutProductCommentsInput = {
		update: XOR<AccountUpdateWithoutProductCommentsInput, AccountUncheckedUpdateWithoutProductCommentsInput>
		create: XOR<AccountCreateWithoutProductCommentsInput, AccountUncheckedCreateWithoutProductCommentsInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutProductCommentsInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutProductCommentsInput, AccountUncheckedUpdateWithoutProductCommentsInput>
	}

	export type AccountUpdateWithoutProductCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutProductCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountCreateWithoutPostsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutPostsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutPostsInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutPostsInput, AccountUncheckedCreateWithoutPostsInput>
	}

	export type PostCommentCreateWithoutPostInput = {
		id?: string
		comment: string
		createdAt?: Date | string
		updatedAt?: Date | string
		author: AccountCreateNestedOneWithoutPostCommentsInput
	}

	export type PostCommentUncheckedCreateWithoutPostInput = {
		id?: string
		comment: string
		authorId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCommentCreateOrConnectWithoutPostInput = {
		where: PostCommentWhereUniqueInput
		create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
	}

	export type PostCommentCreateManyPostInputEnvelope = {
		data: PostCommentCreateManyPostInput | PostCommentCreateManyPostInput[]
		skipDuplicates?: boolean
	}

	export type PostLikeCreateWithoutPostInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutPostLikesInput
	}

	export type PostLikeUncheckedCreateWithoutPostInput = {
		id?: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostLikeCreateOrConnectWithoutPostInput = {
		where: PostLikeWhereUniqueInput
		create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
	}

	export type PostLikeCreateManyPostInputEnvelope = {
		data: PostLikeCreateManyPostInput | PostLikeCreateManyPostInput[]
		skipDuplicates?: boolean
	}

	export type AccountUpsertWithoutPostsInput = {
		update: XOR<AccountUpdateWithoutPostsInput, AccountUncheckedUpdateWithoutPostsInput>
		create: XOR<AccountCreateWithoutPostsInput, AccountUncheckedCreateWithoutPostsInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutPostsInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutPostsInput, AccountUncheckedUpdateWithoutPostsInput>
	}

	export type AccountUpdateWithoutPostsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutPostsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type PostCommentUpsertWithWhereUniqueWithoutPostInput = {
		where: PostCommentWhereUniqueInput
		update: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
		create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
	}

	export type PostCommentUpdateWithWhereUniqueWithoutPostInput = {
		where: PostCommentWhereUniqueInput
		data: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
	}

	export type PostCommentUpdateManyWithWhereWithoutPostInput = {
		where: PostCommentScalarWhereInput
		data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutPostInput>
	}

	export type PostLikeUpsertWithWhereUniqueWithoutPostInput = {
		where: PostLikeWhereUniqueInput
		update: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
		create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
	}

	export type PostLikeUpdateWithWhereUniqueWithoutPostInput = {
		where: PostLikeWhereUniqueInput
		data: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
	}

	export type PostLikeUpdateManyWithWhereWithoutPostInput = {
		where: PostLikeScalarWhereInput
		data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostInput>
	}

	export type AccountCreateWithoutPostCommentsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutPostCommentsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutPostCommentsInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutPostCommentsInput, AccountUncheckedCreateWithoutPostCommentsInput>
	}

	export type PostCreateWithoutCommentsInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		author: AccountCreateNestedOneWithoutPostsInput
		likes?: PostLikeCreateNestedManyWithoutPostInput
	}

	export type PostUncheckedCreateWithoutCommentsInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		authorId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
	}

	export type PostCreateOrConnectWithoutCommentsInput = {
		where: PostWhereUniqueInput
		create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
	}

	export type AccountUpsertWithoutPostCommentsInput = {
		update: XOR<AccountUpdateWithoutPostCommentsInput, AccountUncheckedUpdateWithoutPostCommentsInput>
		create: XOR<AccountCreateWithoutPostCommentsInput, AccountUncheckedCreateWithoutPostCommentsInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutPostCommentsInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutPostCommentsInput, AccountUncheckedUpdateWithoutPostCommentsInput>
	}

	export type AccountUpdateWithoutPostCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutPostCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type PostUpsertWithoutCommentsInput = {
		update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
		create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
		where?: PostWhereInput
	}

	export type PostUpdateToOneWithWhereWithoutCommentsInput = {
		where?: PostWhereInput
		data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
	}

	export type PostUpdateWithoutCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		author?: AccountUpdateOneRequiredWithoutPostsNestedInput
		likes?: PostLikeUpdateManyWithoutPostNestedInput
	}

	export type PostUncheckedUpdateWithoutCommentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		authorId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
	}

	export type PostCreateWithoutLikesInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
		author: AccountCreateNestedOneWithoutPostsInput
		comments?: PostCommentCreateNestedManyWithoutPostInput
	}

	export type PostUncheckedCreateWithoutLikesInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		authorId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
	}

	export type PostCreateOrConnectWithoutLikesInput = {
		where: PostWhereUniqueInput
		create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
	}

	export type AccountCreateWithoutPostLikesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutPostLikesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutPostLikesInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutPostLikesInput, AccountUncheckedCreateWithoutPostLikesInput>
	}

	export type PostUpsertWithoutLikesInput = {
		update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
		create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
		where?: PostWhereInput
	}

	export type PostUpdateToOneWithWhereWithoutLikesInput = {
		where?: PostWhereInput
		data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
	}

	export type PostUpdateWithoutLikesInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		author?: AccountUpdateOneRequiredWithoutPostsNestedInput
		comments?: PostCommentUpdateManyWithoutPostNestedInput
	}

	export type PostUncheckedUpdateWithoutLikesInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		authorId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
	}

	export type AccountUpsertWithoutPostLikesInput = {
		update: XOR<AccountUpdateWithoutPostLikesInput, AccountUncheckedUpdateWithoutPostLikesInput>
		create: XOR<AccountCreateWithoutPostLikesInput, AccountUncheckedCreateWithoutPostLikesInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutPostLikesInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutPostLikesInput, AccountUncheckedUpdateWithoutPostLikesInput>
	}

	export type AccountUpdateWithoutPostLikesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutPostLikesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountCreateWithoutTokensInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutTokensInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutTokensInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutTokensInput, AccountUncheckedCreateWithoutTokensInput>
	}

	export type AccountUpsertWithoutTokensInput = {
		update: XOR<AccountUpdateWithoutTokensInput, AccountUncheckedUpdateWithoutTokensInput>
		create: XOR<AccountCreateWithoutTokensInput, AccountUncheckedCreateWithoutTokensInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutTokensInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutTokensInput, AccountUncheckedUpdateWithoutTokensInput>
	}

	export type AccountUpdateWithoutTokensInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutTokensInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountCreateWithoutNotificationsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutNotificationsInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutNotificationsInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
	}

	export type AccountUpsertWithoutNotificationsInput = {
		update: XOR<AccountUpdateWithoutNotificationsInput, AccountUncheckedUpdateWithoutNotificationsInput>
		create: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutNotificationsInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutNotificationsInput, AccountUncheckedUpdateWithoutNotificationsInput>
	}

	export type AccountUpdateWithoutNotificationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutNotificationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountCreateWithoutSentMessagesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutSentMessagesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutSentMessagesInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutSentMessagesInput, AccountUncheckedCreateWithoutSentMessagesInput>
	}

	export type AccountCreateWithoutReceivedMessagesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
	}

	export type AccountUncheckedCreateWithoutReceivedMessagesInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		accountLoyalty?: AccountLoyaltyUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
	}

	export type AccountCreateOrConnectWithoutReceivedMessagesInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutReceivedMessagesInput, AccountUncheckedCreateWithoutReceivedMessagesInput>
	}

	export type AccountUpsertWithoutSentMessagesInput = {
		update: XOR<AccountUpdateWithoutSentMessagesInput, AccountUncheckedUpdateWithoutSentMessagesInput>
		create: XOR<AccountCreateWithoutSentMessagesInput, AccountUncheckedCreateWithoutSentMessagesInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutSentMessagesInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutSentMessagesInput, AccountUncheckedUpdateWithoutSentMessagesInput>
	}

	export type AccountUpdateWithoutSentMessagesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutSentMessagesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUpsertWithoutReceivedMessagesInput = {
		update: XOR<AccountUpdateWithoutReceivedMessagesInput, AccountUncheckedUpdateWithoutReceivedMessagesInput>
		create: XOR<AccountCreateWithoutReceivedMessagesInput, AccountUncheckedCreateWithoutReceivedMessagesInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutReceivedMessagesInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutReceivedMessagesInput, AccountUncheckedUpdateWithoutReceivedMessagesInput>
	}

	export type AccountUpdateWithoutReceivedMessagesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
	}

	export type AccountUncheckedUpdateWithoutReceivedMessagesInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		accountLoyalty?: AccountLoyaltyUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
	}

	export type AccountLoyaltyCreateWithoutLoyaltyLevelInput = {
		id?: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutAccountLoyaltyInput
		transactions?: LoyaltyTransactionCreateNestedManyWithoutAccountLoyaltyInput
	}

	export type AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput = {
		id?: string
		accountId: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutAccountLoyaltyInput
	}

	export type AccountLoyaltyCreateOrConnectWithoutLoyaltyLevelInput = {
		where: AccountLoyaltyWhereUniqueInput
		create: XOR<AccountLoyaltyCreateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput>
	}

	export type AccountLoyaltyCreateManyLoyaltyLevelInputEnvelope = {
		data: AccountLoyaltyCreateManyLoyaltyLevelInput | AccountLoyaltyCreateManyLoyaltyLevelInput[]
		skipDuplicates?: boolean
	}

	export type AccountLoyaltyUpsertWithWhereUniqueWithoutLoyaltyLevelInput = {
		where: AccountLoyaltyWhereUniqueInput
		update: XOR<AccountLoyaltyUpdateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedUpdateWithoutLoyaltyLevelInput>
		create: XOR<AccountLoyaltyCreateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedCreateWithoutLoyaltyLevelInput>
	}

	export type AccountLoyaltyUpdateWithWhereUniqueWithoutLoyaltyLevelInput = {
		where: AccountLoyaltyWhereUniqueInput
		data: XOR<AccountLoyaltyUpdateWithoutLoyaltyLevelInput, AccountLoyaltyUncheckedUpdateWithoutLoyaltyLevelInput>
	}

	export type AccountLoyaltyUpdateManyWithWhereWithoutLoyaltyLevelInput = {
		where: AccountLoyaltyScalarWhereInput
		data: XOR<AccountLoyaltyUpdateManyMutationInput, AccountLoyaltyUncheckedUpdateManyWithoutLoyaltyLevelInput>
	}

	export type AccountLoyaltyScalarWhereInput = {
		AND?: AccountLoyaltyScalarWhereInput | AccountLoyaltyScalarWhereInput[]
		OR?: AccountLoyaltyScalarWhereInput[]
		NOT?: AccountLoyaltyScalarWhereInput | AccountLoyaltyScalarWhereInput[]
		id?: StringFilter<'AccountLoyalty'> | string
		accountId?: StringFilter<'AccountLoyalty'> | string
		loyaltyLevelId?: StringFilter<'AccountLoyalty'> | string
		points?: IntFilter<'AccountLoyalty'> | number
		totalSpent?: FloatFilter<'AccountLoyalty'> | number
		ordersCount?: IntFilter<'AccountLoyalty'> | number
		lastActivity?: DateTimeFilter<'AccountLoyalty'> | Date | string
		achievements?: JsonNullableFilter<'AccountLoyalty'>
		createdAt?: DateTimeFilter<'AccountLoyalty'> | Date | string
		updatedAt?: DateTimeFilter<'AccountLoyalty'> | Date | string
	}

	export type AccountCreateWithoutAccountLoyaltyInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleCreateNestedManyWithoutAccountInput
		cart?: CartCreateNestedManyWithoutAccountInput
		favorites?: FavoriteCreateNestedManyWithoutAccountInput
		orders?: OrderCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressCreateNestedManyWithoutAccountInput
		notifications?: NotificationCreateNestedManyWithoutAccountInput
		posts?: PostCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeCreateNestedManyWithoutAccountInput
		tokens?: TokenCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageCreateNestedManyWithoutReceiverInput
	}

	export type AccountUncheckedCreateWithoutAccountLoyaltyInput = {
		id?: string
		email: string
		password: string
		userName: string
		picture?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
		roles?: AccountRoleUncheckedCreateNestedManyWithoutAccountInput
		cart?: CartUncheckedCreateNestedManyWithoutAccountInput
		favorites?: FavoriteUncheckedCreateNestedManyWithoutAccountInput
		orders?: OrderUncheckedCreateNestedManyWithoutAccountInput
		productComments?: ProductCommentUncheckedCreateNestedManyWithoutAccountInput
		deliveryAdresses?: DeliveryAddressUncheckedCreateNestedManyWithoutAccountInput
		notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
		posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
		postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
		postLikes?: PostLikeUncheckedCreateNestedManyWithoutAccountInput
		tokens?: TokenUncheckedCreateNestedManyWithoutAccountInput
		accountSettings?: AccountSettingsUncheckedCreateNestedOneWithoutAccountInput
		sentMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
		receivedMessages?: SupportMessageUncheckedCreateNestedManyWithoutReceiverInput
	}

	export type AccountCreateOrConnectWithoutAccountLoyaltyInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutAccountLoyaltyInput, AccountUncheckedCreateWithoutAccountLoyaltyInput>
	}

	export type LoyaltyLevelCreateWithoutAccountLoyaltiesInput = {
		id?: string
		name: string
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery?: boolean
		hasPersonalManager?: boolean
		hasExclusiveAccess?: boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type LoyaltyLevelUncheckedCreateWithoutAccountLoyaltiesInput = {
		id?: string
		name: string
		minPoints: number
		bonusPercentage: number
		hasPriorityDelivery?: boolean
		hasPersonalManager?: boolean
		hasExclusiveAccess?: boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type LoyaltyLevelCreateOrConnectWithoutAccountLoyaltiesInput = {
		where: LoyaltyLevelWhereUniqueInput
		create: XOR<LoyaltyLevelCreateWithoutAccountLoyaltiesInput, LoyaltyLevelUncheckedCreateWithoutAccountLoyaltiesInput>
	}

	export type LoyaltyTransactionCreateWithoutAccountLoyaltyInput = {
		id?: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId?: string | null
		description?: string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
	}

	export type LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput = {
		id?: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId?: string | null
		description?: string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
	}

	export type LoyaltyTransactionCreateOrConnectWithoutAccountLoyaltyInput = {
		where: LoyaltyTransactionWhereUniqueInput
		create: XOR<LoyaltyTransactionCreateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput>
	}

	export type LoyaltyTransactionCreateManyAccountLoyaltyInputEnvelope = {
		data: LoyaltyTransactionCreateManyAccountLoyaltyInput | LoyaltyTransactionCreateManyAccountLoyaltyInput[]
		skipDuplicates?: boolean
	}

	export type AccountUpsertWithoutAccountLoyaltyInput = {
		update: XOR<AccountUpdateWithoutAccountLoyaltyInput, AccountUncheckedUpdateWithoutAccountLoyaltyInput>
		create: XOR<AccountCreateWithoutAccountLoyaltyInput, AccountUncheckedCreateWithoutAccountLoyaltyInput>
		where?: AccountWhereInput
	}

	export type AccountUpdateToOneWithWhereWithoutAccountLoyaltyInput = {
		where?: AccountWhereInput
		data: XOR<AccountUpdateWithoutAccountLoyaltyInput, AccountUncheckedUpdateWithoutAccountLoyaltyInput>
	}

	export type AccountUpdateWithoutAccountLoyaltyInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUpdateManyWithoutAccountNestedInput
		cart?: CartUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUpdateManyWithoutAccountNestedInput
		orders?: OrderUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUpdateManyWithoutAccountNestedInput
		posts?: PostUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUpdateManyWithoutAccountNestedInput
		tokens?: TokenUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUpdateManyWithoutReceiverNestedInput
	}

	export type AccountUncheckedUpdateWithoutAccountLoyaltyInput = {
		id?: StringFieldUpdateOperationsInput | string
		email?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		userName?: StringFieldUpdateOperationsInput | string
		picture?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		roles?: AccountRoleUncheckedUpdateManyWithoutAccountNestedInput
		cart?: CartUncheckedUpdateManyWithoutAccountNestedInput
		favorites?: FavoriteUncheckedUpdateManyWithoutAccountNestedInput
		orders?: OrderUncheckedUpdateManyWithoutAccountNestedInput
		productComments?: ProductCommentUncheckedUpdateManyWithoutAccountNestedInput
		deliveryAdresses?: DeliveryAddressUncheckedUpdateManyWithoutAccountNestedInput
		notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
		posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
		postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
		postLikes?: PostLikeUncheckedUpdateManyWithoutAccountNestedInput
		tokens?: TokenUncheckedUpdateManyWithoutAccountNestedInput
		accountSettings?: AccountSettingsUncheckedUpdateOneWithoutAccountNestedInput
		sentMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
		receivedMessages?: SupportMessageUncheckedUpdateManyWithoutReceiverNestedInput
	}

	export type LoyaltyLevelUpsertWithoutAccountLoyaltiesInput = {
		update: XOR<LoyaltyLevelUpdateWithoutAccountLoyaltiesInput, LoyaltyLevelUncheckedUpdateWithoutAccountLoyaltiesInput>
		create: XOR<LoyaltyLevelCreateWithoutAccountLoyaltiesInput, LoyaltyLevelUncheckedCreateWithoutAccountLoyaltiesInput>
		where?: LoyaltyLevelWhereInput
	}

	export type LoyaltyLevelUpdateToOneWithWhereWithoutAccountLoyaltiesInput = {
		where?: LoyaltyLevelWhereInput
		data: XOR<LoyaltyLevelUpdateWithoutAccountLoyaltiesInput, LoyaltyLevelUncheckedUpdateWithoutAccountLoyaltiesInput>
	}

	export type LoyaltyLevelUpdateWithoutAccountLoyaltiesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		minPoints?: IntFieldUpdateOperationsInput | number
		bonusPercentage?: FloatFieldUpdateOperationsInput | number
		hasPriorityDelivery?: BoolFieldUpdateOperationsInput | boolean
		hasPersonalManager?: BoolFieldUpdateOperationsInput | boolean
		hasExclusiveAccess?: BoolFieldUpdateOperationsInput | boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyLevelUncheckedUpdateWithoutAccountLoyaltiesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		minPoints?: IntFieldUpdateOperationsInput | number
		bonusPercentage?: FloatFieldUpdateOperationsInput | number
		hasPriorityDelivery?: BoolFieldUpdateOperationsInput | boolean
		hasPersonalManager?: BoolFieldUpdateOperationsInput | boolean
		hasExclusiveAccess?: BoolFieldUpdateOperationsInput | boolean
		additionalBenefits?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionUpsertWithWhereUniqueWithoutAccountLoyaltyInput = {
		where: LoyaltyTransactionWhereUniqueInput
		update: XOR<LoyaltyTransactionUpdateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedUpdateWithoutAccountLoyaltyInput>
		create: XOR<LoyaltyTransactionCreateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedCreateWithoutAccountLoyaltyInput>
	}

	export type LoyaltyTransactionUpdateWithWhereUniqueWithoutAccountLoyaltyInput = {
		where: LoyaltyTransactionWhereUniqueInput
		data: XOR<LoyaltyTransactionUpdateWithoutAccountLoyaltyInput, LoyaltyTransactionUncheckedUpdateWithoutAccountLoyaltyInput>
	}

	export type LoyaltyTransactionUpdateManyWithWhereWithoutAccountLoyaltyInput = {
		where: LoyaltyTransactionScalarWhereInput
		data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutAccountLoyaltyInput>
	}

	export type LoyaltyTransactionScalarWhereInput = {
		AND?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
		OR?: LoyaltyTransactionScalarWhereInput[]
		NOT?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
		id?: StringFilter<'LoyaltyTransaction'> | string
		accountLoyaltyId?: StringFilter<'LoyaltyTransaction'> | string
		points?: IntFilter<'LoyaltyTransaction'> | number
		type?: EnumLoyaltyTransactionTypeFilter<'LoyaltyTransaction'> | $Enums.LoyaltyTransactionType
		orderId?: StringNullableFilter<'LoyaltyTransaction'> | string | null
		description?: StringNullableFilter<'LoyaltyTransaction'> | string | null
		metadata?: JsonNullableFilter<'LoyaltyTransaction'>
		createdAt?: DateTimeFilter<'LoyaltyTransaction'> | Date | string
	}

	export type AccountLoyaltyCreateWithoutTransactionsInput = {
		id?: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
		account: AccountCreateNestedOneWithoutAccountLoyaltyInput
		loyaltyLevel: LoyaltyLevelCreateNestedOneWithoutAccountLoyaltiesInput
	}

	export type AccountLoyaltyUncheckedCreateWithoutTransactionsInput = {
		id?: string
		accountId: string
		loyaltyLevelId: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountLoyaltyCreateOrConnectWithoutTransactionsInput = {
		where: AccountLoyaltyWhereUniqueInput
		create: XOR<AccountLoyaltyCreateWithoutTransactionsInput, AccountLoyaltyUncheckedCreateWithoutTransactionsInput>
	}

	export type AccountLoyaltyUpsertWithoutTransactionsInput = {
		update: XOR<AccountLoyaltyUpdateWithoutTransactionsInput, AccountLoyaltyUncheckedUpdateWithoutTransactionsInput>
		create: XOR<AccountLoyaltyCreateWithoutTransactionsInput, AccountLoyaltyUncheckedCreateWithoutTransactionsInput>
		where?: AccountLoyaltyWhereInput
	}

	export type AccountLoyaltyUpdateToOneWithWhereWithoutTransactionsInput = {
		where?: AccountLoyaltyWhereInput
		data: XOR<AccountLoyaltyUpdateWithoutTransactionsInput, AccountLoyaltyUncheckedUpdateWithoutTransactionsInput>
	}

	export type AccountLoyaltyUpdateWithoutTransactionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutAccountLoyaltyNestedInput
		loyaltyLevel?: LoyaltyLevelUpdateOneRequiredWithoutAccountLoyaltiesNestedInput
	}

	export type AccountLoyaltyUncheckedUpdateWithoutTransactionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		loyaltyLevelId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountRoleCreateManyRoleInput = {
		id?: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountRoleUpdateWithoutRoleInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutRolesNestedInput
	}

	export type AccountRoleUncheckedUpdateWithoutRoleInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountRoleUncheckedUpdateManyWithoutRoleInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCreateManyCategoryInput = {
		id?: string
		title: string
		description?: string | null
		weight?: number
		imageUrl?: string | null
		price?: number
		onSale?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductUpdateWithoutCategoryInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateWithoutCategoryInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		cart?: CartUncheckedUpdateManyWithoutProductNestedInput
		favorite?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
		ingredients?: ProductIngredientsUncheckedUpdateManyWithoutProductNestedInput
		orderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
		comments?: ProductCommentUncheckedUpdateManyWithoutProductNestedInput
	}

	export type ProductUncheckedUpdateManyWithoutCategoryInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		weight?: FloatFieldUpdateOperationsInput | number
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		price?: FloatFieldUpdateOperationsInput | number
		onSale?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsCreateManyIngredientInput = {
		id?: string
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductIngredientsUpdateWithoutIngredientInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		product?: ProductUpdateOneRequiredWithoutIngredientsNestedInput
	}

	export type ProductIngredientsUncheckedUpdateWithoutIngredientInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsUncheckedUpdateManyWithoutIngredientInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartCreateManyProductInput = {
		id?: string
		accountId: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type FavoriteCreateManyProductInput = {
		id?: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductIngredientsCreateManyProductInput = {
		id?: string
		ingredientId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderItemCreateManyProductInput = {
		id?: string
		orderId?: string | null
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductCommentCreateManyProductInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CartUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutCartNestedInput
	}

	export type CartUncheckedUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartUncheckedUpdateManyWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutFavoritesNestedInput
	}

	export type FavoriteUncheckedUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteUncheckedUpdateManyWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		ingredient?: IngredientUpdateOneRequiredWithoutProductIngredientsNestedInput
	}

	export type ProductIngredientsUncheckedUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		ingredientId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductIngredientsUncheckedUpdateManyWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		ingredientId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		order?: OrderUpdateOneWithoutItemsNestedInput
	}

	export type OrderItemUncheckedUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemUncheckedUpdateManyWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCommentUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		parent?: ProductCommentUpdateOneWithoutRepliesNestedInput
		replies?: ProductCommentUpdateManyWithoutParentNestedInput
		account?: AccountUpdateOneRequiredWithoutProductCommentsNestedInput
	}

	export type ProductCommentUncheckedUpdateWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		replies?: ProductCommentUncheckedUpdateManyWithoutParentNestedInput
	}

	export type ProductCommentUncheckedUpdateManyWithoutProductInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountRoleCreateManyAccountInput = {
		id?: string
		roleId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type CartCreateManyAccountInput = {
		id?: string
		productId: string
		quantity?: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type FavoriteCreateManyAccountInput = {
		id?: string
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderCreateManyAccountInput = {
		id?: string
		status?: $Enums.OrderStatus
		firstName: string
		lastName: string
		phone: string
		email?: string | null
		deliveryAddressId?: string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType: $Enums.DeliveryType
		paymentMethod: $Enums.PaymentMethod
		paymentStatus: $Enums.PaymentStatus
		comment?: string | null
		total: number
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductCommentCreateManyAccountInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		parentId?: string | null
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type DeliveryAddressCreateManyAccountInput = {
		id?: string
		city: string
		street: string
		house: string
		flat: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type NotificationCreateManyAccountInput = {
		id?: string
		title: string
		message: string
		link: string
		type: $Enums.NotificationType
		isRead?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCreateManyAuthorInput = {
		id?: string
		title: string
		description?: string | null
		imageUrl?: string | null
		published?: boolean
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCommentCreateManyAuthorInput = {
		id?: string
		comment: string
		postId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostLikeCreateManyAccountInput = {
		id?: string
		postId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type TokenCreateManyAccountInput = {
		id?: string
		token: string
		type: $Enums.TokenTypes
		expiresIn: Date | string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type SupportMessageCreateManySenderInput = {
		id?: string
		message: string
		receiverId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type SupportMessageCreateManyReceiverInput = {
		id?: string
		message: string
		senderId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountRoleUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		role?: RoleUpdateOneRequiredWithoutAccountRolesNestedInput
	}

	export type AccountRoleUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		roleId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountRoleUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		roleId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		product?: ProductUpdateOneRequiredWithoutCartNestedInput
	}

	export type CartUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type CartUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		product?: ProductUpdateOneRequiredWithoutFavoriteNestedInput
	}

	export type FavoriteUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type FavoriteUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		items?: OrderItemUpdateManyWithoutOrderNestedInput
	}

	export type OrderUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
	}

	export type OrderUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		phone?: StringFieldUpdateOperationsInput | string
		email?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddressId?: NullableStringFieldUpdateOperationsInput | string | null
		deliveryAddress?: NullableJsonNullValueInput | InputJsonValue
		deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
		paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
		paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		total?: FloatFieldUpdateOperationsInput | number
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCommentUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		parent?: ProductCommentUpdateOneWithoutRepliesNestedInput
		replies?: ProductCommentUpdateManyWithoutParentNestedInput
		product?: ProductUpdateOneRequiredWithoutCommentsNestedInput
	}

	export type ProductCommentUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		replies?: ProductCommentUncheckedUpdateManyWithoutParentNestedInput
	}

	export type ProductCommentUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		parentId?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type DeliveryAddressUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type DeliveryAddressUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type DeliveryAddressUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		city?: StringFieldUpdateOperationsInput | string
		street?: StringFieldUpdateOperationsInput | string
		house?: StringFieldUpdateOperationsInput | string
		flat?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type NotificationUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type NotificationUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type NotificationUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		link?: StringFieldUpdateOperationsInput | string
		type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
		isRead?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostUpdateWithoutAuthorInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		comments?: PostCommentUpdateManyWithoutPostNestedInput
		likes?: PostLikeUpdateManyWithoutPostNestedInput
	}

	export type PostUncheckedUpdateWithoutAuthorInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
		likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
	}

	export type PostUncheckedUpdateManyWithoutAuthorInput = {
		id?: StringFieldUpdateOperationsInput | string
		title?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		published?: BoolFieldUpdateOperationsInput | boolean
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentUpdateWithoutAuthorInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		post?: PostUpdateOneRequiredWithoutCommentsNestedInput
	}

	export type PostCommentUncheckedUpdateWithoutAuthorInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentUncheckedUpdateManyWithoutAuthorInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		post?: PostUpdateOneRequiredWithoutLikesNestedInput
	}

	export type PostLikeUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		postId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type TokenUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type TokenUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type TokenUncheckedUpdateManyWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		type?: EnumTokenTypesFieldUpdateOperationsInput | $Enums.TokenTypes
		expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageUpdateWithoutSenderInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		receiver?: AccountUpdateOneRequiredWithoutReceivedMessagesNestedInput
	}

	export type SupportMessageUncheckedUpdateWithoutSenderInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		receiverId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageUncheckedUpdateManyWithoutSenderInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		receiverId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageUpdateWithoutReceiverInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		sender?: AccountUpdateOneRequiredWithoutSentMessagesNestedInput
	}

	export type SupportMessageUncheckedUpdateWithoutReceiverInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		senderId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SupportMessageUncheckedUpdateManyWithoutReceiverInput = {
		id?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		senderId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemCreateManyOrderInput = {
		id?: string
		quantity: number
		price: number
		productTitle: string
		productDescription?: string | null
		productImageUrl?: string | null
		productId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type OrderItemUpdateWithoutOrderInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
	}

	export type OrderItemUncheckedUpdateWithoutOrderInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
		id?: StringFieldUpdateOperationsInput | string
		quantity?: IntFieldUpdateOperationsInput | number
		price?: FloatFieldUpdateOperationsInput | number
		productTitle?: StringFieldUpdateOperationsInput | string
		productDescription?: NullableStringFieldUpdateOperationsInput | string | null
		productImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
		productId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ProductCommentCreateManyParentInput = {
		id?: string
		comment?: string | null
		rating?: number | null
		productId: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type ProductCommentUpdateWithoutParentInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		replies?: ProductCommentUpdateManyWithoutParentNestedInput
		product?: ProductUpdateOneRequiredWithoutCommentsNestedInput
		account?: AccountUpdateOneRequiredWithoutProductCommentsNestedInput
	}

	export type ProductCommentUncheckedUpdateWithoutParentInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		replies?: ProductCommentUncheckedUpdateManyWithoutParentNestedInput
	}

	export type ProductCommentUncheckedUpdateManyWithoutParentInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: NullableStringFieldUpdateOperationsInput | string | null
		rating?: NullableIntFieldUpdateOperationsInput | number | null
		productId?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentCreateManyPostInput = {
		id?: string
		comment: string
		authorId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostLikeCreateManyPostInput = {
		id?: string
		accountId: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type PostCommentUpdateWithoutPostInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		author?: AccountUpdateOneRequiredWithoutPostCommentsNestedInput
	}

	export type PostCommentUncheckedUpdateWithoutPostInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		authorId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostCommentUncheckedUpdateManyWithoutPostInput = {
		id?: StringFieldUpdateOperationsInput | string
		comment?: StringFieldUpdateOperationsInput | string
		authorId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeUpdateWithoutPostInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutPostLikesNestedInput
	}

	export type PostLikeUncheckedUpdateWithoutPostInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type PostLikeUncheckedUpdateManyWithoutPostInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type AccountLoyaltyCreateManyLoyaltyLevelInput = {
		id?: string
		accountId: string
		points: number
		totalSpent?: number
		ordersCount?: number
		lastActivity?: Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type AccountLoyaltyUpdateWithoutLoyaltyLevelInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		account?: AccountUpdateOneRequiredWithoutAccountLoyaltyNestedInput
		transactions?: LoyaltyTransactionUpdateManyWithoutAccountLoyaltyNestedInput
	}

	export type AccountLoyaltyUncheckedUpdateWithoutLoyaltyLevelInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutAccountLoyaltyNestedInput
	}

	export type AccountLoyaltyUncheckedUpdateManyWithoutLoyaltyLevelInput = {
		id?: StringFieldUpdateOperationsInput | string
		accountId?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		totalSpent?: FloatFieldUpdateOperationsInput | number
		ordersCount?: IntFieldUpdateOperationsInput | number
		lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
		achievements?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionCreateManyAccountLoyaltyInput = {
		id?: string
		points: number
		type: $Enums.LoyaltyTransactionType
		orderId?: string | null
		description?: string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: Date | string
	}

	export type LoyaltyTransactionUpdateWithoutAccountLoyaltyInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionUncheckedUpdateWithoutAccountLoyaltyInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type LoyaltyTransactionUncheckedUpdateManyWithoutAccountLoyaltyInput = {
		id?: StringFieldUpdateOperationsInput | string
		points?: IntFieldUpdateOperationsInput | number
		type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
		orderId?: NullableStringFieldUpdateOperationsInput | string | null
		description?: NullableStringFieldUpdateOperationsInput | string | null
		metadata?: NullableJsonNullValueInput | InputJsonValue
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	/**
	 * Batch Payload for updateMany & deleteMany & createMany
	 */

	export type BatchPayload = {
		count: number
	}

	/**
	 * DMMF
	 */
	export const dmmf: runtime.BaseDMMF
}
